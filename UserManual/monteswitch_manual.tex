\documentclass{report}

\usepackage[english]{babel}

\usepackage{graphicx}% Needed for figure files
\usepackage{hyperref}% Gives hyperlinks
\usepackage{amsmath,amsthm,amssymb}% Extra maths stuff
\usepackage{enumitem} % For a,b,c,... bullet points 
\usepackage{longtable} % Split long tables over many pages
\usepackage{lscape} % For rotating certain pages to landscape

\usepackage{nomencl} % Needed for abbreviations
\makenomenclature

\begin{document}
\sloppy

\title{\emph{monteswitch} user manual\\ (v 1.0.0)}
\author{Tom L. Underwood}
\date{\today}
\maketitle


\addcontentsline{toc}{chapter}{Contents}
\tableofcontents


\addcontentsline{toc}{chapter}{Acknowledgements}
\chapter*{Acknowledgements}
The development of \emph{monteswitch} was supported by funding from the Engineering and Physical Sciences Research Council (EPSRC),
under the supervision of Graeme Ackland. Valuable discussions with Mikhail Mendelev, Nigel Wilding, Andrey Brukhno and Kevin Stratford 
are gratefully acknowledged.

\addcontentsline{toc}{chapter}{Disclaimer}
\chapter*{Disclaimer}
While we have endeavoured to ensure \emph{monteswitch} is free from error, we cannot guarantee this. Hence you use \emph{monteswitch}
at your own risk.

\addcontentsline{toc}{chapter}{List of Abbreviations}
\renewcommand{\nomname}{List of Abbreviations}
\printnomenclature

\addcontentsline{toc}{chapter}{Conventions used in this manual}
\chapter*{Conventions used in this manual}
Throughout this manual we use:
\begin{itemize}
\item \texttt{typewriter font} to signify file and program names, command-line arguments to programs, and shell
commands and shell output. Shell commands are always provided on stand-alone lines starting with a `\verb|$|', e.g.,
\begin{verbatim}
$ echo "I am a shell command"
$ echo "So am I"
\end{verbatim}
Furthermore, long shell commands which do not fit on a single line are wrapped on to the following line without the presence of
a `\verb|$|', e.g.,
\begin{verbatim}
$ echo "I am a loooooooooooooooooooooooooooooooooooooooooooo
ooong shell command"
$ echo "I am not"
\end{verbatim}
Note however that `\verb|$|' is often used in the shell command itself. It should be clear from the context whether this is the
significance of any given `\verb|$|' or not.
\item \textbf{Bold font} to signify the names of variables in input and output files for the \emph{monteswitch} programs.
\item \texttt{UPPER CASE TYPEWRITER FONT} to signify Fortran statements and variables. Note however that the \emph{monteswitch} 
source code is predominantly lower case (Fortran is case-insensitive). Furthermore, for clarity we sometimes use lower case, e.g.,
the type of a \texttt{REAL} array of size \textbf{M\_grid\_size} is signified as \texttt{REAL(M\_grid\_size)}.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
Lattice-switch Monte Carlo (LSMC) \cite{Bruce_1997,Bruce_2000} is a method which enables the free energy difference between pairs of solid
phases to be efficiently evaluated to a high precision.
\nomenclature{LSMC}{Lattice-switch Monte Carlo}%
\emph{monteswitch} is a package whose primary purpose is to enable LSMC simulations to be performed, and can treat 
`atomic' systems (i.e., those in which the constituent particles do not have rotational degrees of 
freedom), and pairs of phases which can be represented by an orthorhombic unit cell, in the NVT and NPT ensembles.
Note that the two `phases' need not be homogeneous crystals, though we expect that this will be the main use for \emph{monteswitch}; 
possible applications for \emph{monteswitch} include evaluating the free energy cost of creating
point defects and interfaces.

%While steps have been taken to implement LSMC in existing general-purpose Monte Carlo codes, we believe that \emph{monteswitch} will fulfill
%an important `gap in the market' for the foreseeable futue for several reasons. Firstly, \emph{monteswitch} is a bespoke LSMC code, and as such
%one would expect it to require less computational resources than general-purpose codes for similar LSMC calculations. Secondly, \emph{monteswitch} 
%was designed from the outset to be highly customisable: users can readily implement their own inter-particle interactions, which may include
%interfacing \emph{monteswitch} with an external program.

This document describes how to use \emph{monteswitch}. Note that this document does not provide details regarding the structure of the source code. 
Similarly, this document does not provide thorough details of how the LSMC method is implemented in \emph{monteswitch}. We direct readers
interested in such things to the HTML source code documentation -- which can be generated from the source code (see Chapter
\ref{chapter:preliminaries}) -- or failing that the source code itself. We assume that the reader is already competent with the unix shell, 
including utilities such as \texttt{grep}, \texttt{sed} and \texttt{awk}. Often we provide examples of commands which utilise the shell and the 
aforementioned utilities to perform certain tasks. However we never describe exactly how these commands work for the sake of brevity; interested users are 
referred to the relevant documentation online or elsewhere. In a similar vein, when we describe Fortran-related issues we assume the reader has 
an expertise in Fortran 95 . We also assume that the user is familiar with the Monte Carlo method (in the sense of computational
chemistry), but not necessarily with LSMC. For further information regarding Monte Carlo simulations in condensed 
matter physics, see, e.g., Ref. \cite{book:Frenkel}. 

The layout of this document is as follows. In Chapter \ref{chapter:background} we describe the theory behind LSMC to a depth which enables the user to 
competently perform LSMC simulations using \emph{monteswitch}. The rest of this document pertains to \emph{monteswitch} itself.
In Chapter \ref{chapter:preliminaries} we describe how to install \emph{monteswitch}, and provide
an overview of the package. Then in Chapter \ref{chapter:simulation_programs} we describe how to use the main Monte Carlo programs within
\emph{monteswitch}. Chapter \ref{chapter:interactions} describes the various interatomic potentials included with \emph{monteswitch}, and
describes how users can implement their own potentials. Chapter \ref{chapter:utility_programs} describes how to use the various utility
programs included with \emph{monteswitch} for the creation of input files and post-processing of output files. In Chapter \ref{chapter:example}
we provide a worked example which elucidates how \emph{monteswitch} can be used to solve a `real' problem. Finally in Chapter \ref{chapter:tests}
we describe the test cases included with \emph{monteswitch} which, as well as validating \emph{monteswitch}, serve as an archive of examples.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background Theory}\label{chapter:background}
In this chapter we describe the LSMC methodology as relevant to \emph{monteswitch}. Further information regarding LSMC,
and its generalisations to solid--fluid transitions and molecular systems, can be found in Refs.  
\cite{Bruce_1997,Bruce_2000,Wilding_2000,Jackson_2002,Errington_2004,McNeil-Watson_2006,Jackson_2007,Bridgwater_2014}.
\footnote{The incarnation of LSMC suitable for solid--fluid transitions is referred to as \emph{phase-switch Monte Carlo}. Furthermore
the reader should be aware that the term lattice-\emph{switching} Monte Carlo has also been applied to LSMC.}

\section{Calculating free energy differences}
Consider a system which is free to visit two phases 1 and 2 (and only phases 1 and 2) within the NVT ensemble. At this point we do not specify what the
phases are, but the reader should bear in mind that \emph{monteswitch} deals with pairs of \emph{solid} phases. We consider only
the NVT ensemble here for the sake of simplicity; however what follows can easily be adapted to apply to the NPT ensemble.
Of phases 1 and 2, the equilibrium phase is that with the lower Helmholtz free energy $F$; it is the free energy difference between the phases 
$\Delta F\equiv F_1-F_2$ which we wish to evaluate, where $F_1$ and $F_2$ denote the free energies of phases 1 and 2.

We now derive an expression for $\Delta F$ which allows $\Delta F$ to be determined from the relative time $t_1$ and $t_2$ which the system spends 
in each phase 1 and 2 during a sufficiently long simulation. It is this expression which is ultimately used in LSMC to calculate $\Delta F$. 
Consider the free energy of phase $\alpha$:
\begin{equation}\label{Falpha_def}
F_{\alpha}=-\beta^{-1}\ln Z_{\alpha},
\end{equation}
where
\begin{equation}\label{Zalpha_def}
Z_{\alpha}=\sum_{\sigma\in\alpha}\exp(-\beta E_{\sigma})
\end{equation}
is the partition function for phase $\alpha$, $\beta\equiv 1/(k_BT)$, $k_B$ is Boltzmann's constant, $\sigma$ denotes a state of the system, $E_{\sigma}$ 
denotes the energy of state $\sigma$, and the summation in the above equation is over all microstates which `belong' to phase $\alpha$. 
From Eqn. \eqref{Falpha_def} it follows that
\begin{equation}\label{DeltaF_Z}
\Delta F=\beta^{-1}\ln\biggl(\frac{Z_2}{Z_1}\biggr).
\end{equation}
Now,
\begin{equation}\label{MC_prob}
p_{\sigma}=\frac{1}{Z}e^{-\beta E_{\sigma}}, \quad Z\equiv Z_1+Z_2
\end{equation}
is the probability that the system, free to explore both phases 1 and 2, is in state $\sigma$. Hence the probability of the system being in
phase $\alpha$ is
\begin{equation}
p_{\alpha} = \sum_{\sigma\in \alpha}p_{\sigma} = Z_{\alpha}/Z,
\end{equation}
where we have used Eqn. \eqref{Zalpha_def}. Finally, substituting this into Eqn. \eqref{DeltaF_Z} gives
\begin{equation}\label{DeltaF_stat_mech}
\Delta F=\beta^{-1}\ln\biggl(\frac{p_2}{p_1}\biggr),
\end{equation}
where $p_1$ and $p_2$ denote the probability of the system being in phase 1 and 2 respectively.  

The above equation suggests the following method for calculating $\Delta F$ from, e.g. a molecular dynamics simulation: measure the relative time $t_1$ 
and $t_2$ which the system spends in each phase 1 and 2 during the simulation, and substitute these quantities into the above equation -- bearing in mind 
that $t_2/t_1=p_2/p_1$. However, this method is often intractable in practice for two solid phases, 
because the time taken for the system to transition between the two phases is too long to allow a reasonable estimate of $t_2/t_1$ to be deduced 
in a reasonable simulation time; it may be the case that, regardless of the phase in which the simulation is initialised, the system \emph{never} 
transitions to the `other' phase during the course of the simulation.
The problem is that, while the regions of phase space corresponding to phase 1 and phase 2 both correspond to probable states of the system
at thermodynamic equilibrium, these regions are separated by an \emph{entropic barrier} -- a region of phase space associated
with states which are very improbable at thermodynamic equilibrium. This entropic barrier inhibits transitions between the `islands of
stability' in phase space associated with phase 1 and phase 2.

This problem can in principle be circumvented within the Monte Carlo method.
In the original incarnation of Monte Carlo, which we refer to as \emph{Metropolis Monte Carlo}\cite{Metropolis_1953} (which we contrast later to 
\emph{multicanonical Monte Carlo}), the system is evolved throughout the simulation as follows. Each timestep we generate a trial state of the system 
$\sigma'$, and attempt to change the system from its current state $\sigma$, to the trial state. We change the state from $\sigma$ to $\sigma'$ with 
probability
\begin{equation}\label{p_Metropolis}
p_{\sigma\to\sigma'}=\text{max}\Bigl[1,e^{\beta(E_{\sigma'}-E_{\sigma})}\Bigr].
\end{equation}
The end result is that each state $\sigma$ is sampled with a probability corresponding to the NVT ensemble, i.e., Eqn. \eqref{MC_prob}.
Hence the equilibrium value of any physical quantity $X$ can be obtained by evaluating the average of $X$ over all timesteps in a sufficiently long 
simulation. In this manner $t_1$ and $t_2$, and hence $\Delta F$ (via Eqn. \eqref{DeltaF_stat_mech}) can be calculated; 
$t_{\alpha}$ is the time average of the quantity $\theta_{\alpha}$, where $\theta_{\alpha}=1$ if the system is in phase $\alpha$ and 0 otherwise.
The traditional approach for NVT ensmbles is to perform a `particle move' to generate a trial state. In this, the trial state differs from the
current state in that one of the particle's positions differs. In NPT ensembles particle moves are supplemented by `volume moves', in which the 
shape of the entire system is altered, along with a commensurate rescaling of the particle positions.
Crucially however, the important properties of the Metropolis algorithm do not rely upon the choice of mechanism used to generate trial states. 
One has considerable freedom in this regard, and is by no means limited to the aforementioned `traditional' move set. The prospect therefore exists 
of generating trial states in a manner which results in the system traversing a path in phase space which allows $\Delta F$ to be calculated 
relatively quickly. Such a path would involve frequent transitions between both phases 1 and 2 by `jumping over' the entropic barrier. 

\section{Lattice switch Monte Carlo moves}\label{sec:lattice_switch}
In LSMC a new type of move, a \emph{lattice switch}, is introduced to supplement the traditional move set mentioned above. Let $\mathbf{r}_i$ 
denote the position of particle $i$. Now, in an NVT emsemble, the set of particle positions $\lbrace\mathbf{r}_i\rbrace$ amounts to a specification 
of the state of the system. We are interested in evaluating free energy differences between pairs of crystalline solid phases. Accordingly, it 
makes sense to characterise a given state of the system as belonging to a solid phase $\alpha$ if the positions of the particles `approximately' 
form a crystal lattice characteristic of $\alpha$. In this case one can express the position $\mathbf{r}_i$ of particle $i$ as follows:
\begin{equation}
\mathbf{r}_i=\mathbf{R}^{\alpha}_i+\mathbf{u}_i,
\end{equation}
where $\mathbf{R}^{\alpha}_i$ denotes the position of the site in the analogous $\alpha$ crystal lattice which is closest to $i$, and $\mathbf{u}_i$ denotes 
the displacement of $i$ from that lattice site. Note that the displacements $\lbrace\mathbf{u}_i\rbrace$ are necessarily small since the particle
positions form an approximate $\alpha$ crystal lattice. In a lattice switch from phase $\alpha$ to the `other' phase $\alpha'$ we transform the 
underlying lattice $\lbrace\mathbf{R}^{\alpha}_i\rbrace$ to $\lbrace\mathbf{R}^{\alpha'}_i\rbrace$, \emph{while keeping the particle displacements 
$\lbrace\mathbf{u}_i\rbrace$ unchanged}.
\footnote{One could in principle alter the particle displacements during a lattice switch. It is conceivable that this would lead to a more efficient
exploration of both phases for some systems. However, this is not implemented in \emph{monteswitch}: in \emph{monteswitch} lattice switches always
keep the particle displacements unchanged.}
The effect is that the trial state belongs to phase $\alpha'$: the positions of the particles in the trial state form an approximate $\alpha'$ crystal 
lattice. Hence every time a lattice switch is accepted, the system transitions to the `other' phase. 

\section{Multicanonical Monte Carlo}
One might expect that by regularly making lattice switches, the system will regularly transition between phases, allowing $\Delta F$ to be efficiently 
evaluated as described earlier. Unfortunately, if one does this in Metropolis Monte Carlo, one finds that lattice switches are too rarely accepted for 
this approach to be useful. 
The problem is that the trial state $\sigma'$ generated by a lattice switch is almost always of much higher energy than the current state $\sigma$, 
and hence will almost always be rejected by the Metropolis algorithm (Eqn. \eqref{p_Metropolis}). 
The solution to this problem is to use \emph{multicanonical Monte Carlo}\cite{Berg_1991,Berg_1992,Smith_1995} instead of Metropolis Monte Carlo.
\footnote{Multicanonical Monte Carlo belongs to the class of extended/expanded ensemble techniques; see, e.g., Ref. \cite{Iba_2001}.}
The former is a straightforward generalisation of the latter in which, instead of Eqn. \eqref{p_Metropolis}, one has
\begin{equation}\label{p_multicanonical}
\tilde{p}_{\sigma\to\sigma'}=\text{max}\Bigl[1,e^{\beta(E_{\sigma'}-E_{\sigma})}e^{(\eta_{\sigma'}-\eta_{\sigma})}\Bigr],
\end{equation}
where $\eta_{\sigma}$, known as the \emph{weight function}, is chosen according to the aims of the simulation. In this case each state $\sigma$ is 
sampled with probability
\begin{equation}\label{MCMC_prob}
\tilde{p}_{\sigma}=\frac{1}{\tilde{Z}}e^{-\beta E_{\sigma}}e^{\eta_{\sigma}}, \quad \tilde{Z}\equiv\sum_{\sigma}e^{-\beta E_{\sigma}}e^{\eta_{\sigma}}
\end{equation}
Using Eqn. \eqref{MC_prob}, it can be shown that
\begin{equation}\label{MCMC_prob_2}
\tilde{p}_{\sigma}=\frac{1}{\tilde{Z}'}p_{\sigma}e^{\eta_{\sigma}}, \quad \tilde{Z}'=\sum_{\sigma}p_{\sigma}e^{\eta_{\sigma}},
\end{equation}
where recall that $p_{\sigma}$ is the probability of observing state $\sigma$ in the NVT ensemble. From this it can be seen that if 
$\eta_{\sigma}>0$ then state $\sigma$ is \emph{over-sampled} relative to Metropolis Monte Carlo. On the other hand if $\eta_{\sigma}<0$ then 
$\sigma$ is \emph{under-sampled}. 
The strength of this approach is that, through judicious choice of the weight function, one can `choose' the path the system traverses 
through phase space. To elaborate, a multicanonical Monte Carlo simulation can be regarded as a Metropolis Monte Carlo 
simulation, but if the energy for each state $\sigma$ were 
\begin{equation}
\tilde{E}_{\sigma}=E_{\sigma}-\eta_{\sigma}/\beta
\end{equation}
instead of $E_{\sigma}$. Hence a multicanonical Monte Carlo simulation samples states with probabilities corresponding to, say, an NVT ensemble,
but if energy were $\tilde{E}_{\sigma}$ instead of $E_{\sigma}$. Noting that the modification to the `true' energy function, $-\eta_{\sigma}/\beta$, is
proportional to the weight function, it can be seen that the weight function defines an additional `force' on the system which affects its
trajectory through phase space. Therefore by choosing $\eta_{\sigma}$, one can choose the system's path through phase space. 

Of course, in a multicanonical simulation the states are not longer sampled with probabilities corresponding to the `true' NVT ensemble -- 
which \emph{is} the case for Metropolis Monte Carlo. Accordingly the time average of some physical quantity $X$ throughout a long multicanonical 
Monte Carlo simulation is not equivalent to the equilibrium value of $X$ for the NVT ensemble in question, like it is in a Metropolis Monte Carlo
simulation. Nevertheless one can obtain the equilibrium value of $X$ from a multicanonical simulation by exploiting the fact that, since the 
weight function is known, then so is the degree of over- or under-sampling of each state. To elaborate, to evaluate the equilibrium value of 
$X$ in a Metropolis Monte Carlo simulation, we use the following expression:
\begin{equation}
\langle X\rangle\approx\frac{1}{\tau}\sum_{t=1}^{\tau}X(t),
\end{equation}
where $X(t)$ denotes the value of the physical quantity $X$ at timestep $t$ of the simulation, and $\tau$ denotes the total number of timesteps.
For reasons which will become clear in a moment, $\langle X\rangle$ could equivalently be expressed as
\begin{equation}
\langle X\rangle\approx\frac{\displaystyle\sum_{t=1}^{\tau}w(t)X(t)}{\displaystyle\sum_{t=1}^{\tau}w(t)}
\end{equation}
with $w(t)$ taking the same constant value for all $t$, where $w(t)$ is the \emph{weight} (not to be confused with the weight function) associated 
with the state at timestep $t$.
Now, Eqn. \eqref{MCMC_prob_2} reveals that state $\sigma$ is sampled in a multicanonical Monte Carlo simulation a factor of
$e^{\eta_{\sigma}}/\tilde{Z}'$ more often than for the true NVT ensemble. Associating a weight $(e^{\eta_{\sigma}}/\tilde{Z}')^{-1}$ to $\sigma$ corrects for
this; the effect is that states which are over-sampled are counted less, and under-sampled states are counted more, in the evaluation of $\langle X\rangle$.
Hence the expression for $\langle X\rangle$ pertaining to a multicanonical simulation is the same as above, but with $w(t)=(e^{\eta(t)}/\tilde{Z}')^{-1}$:
\begin{equation}\label{equilX_MCMC}
\langle X\rangle\approx\frac{\displaystyle\sum_{t=1}^{\tau}e^{-\eta(t)}X(t)}{\displaystyle\sum_{t=1}^{\tau}e^{-\eta(t)}},
\end{equation}
where we have canceled the factors of $\tilde{Z}'^{-1}$ from the numerator and denominator.

Why is this helpful to us? As mentioned above, most states are such that lattice switches will be almost certainly be rejected from them. There 
are, however, a small number of states from which a lattice switch yields a trial state which is of comparable energy to $\sigma$. From such 
states a lattice switch has a good chance of being accepted. (Note that the same is also true for the trial state corresponding to a lattice switch:
a lattice switch from the trial state, which brings us back to the current state, would also have a good chance of success). We refer to 
such states as \emph{gateway states}, since they provide the key to jumping between both phases. It is these states which we wish to over-sample,
and we set the weight function accordingly. The result is that lattice switches are accepted reasonably often, encouraging switching between the 
two phases. Thus the multicanonical simulation samples both phases in a reasonable simulation time, which enables us to obtain 
$t_1$ and $t_2$ (which recall are the time averages of $\theta_1$ and $\theta_2$ defined earlier, i.e. $t_1=\langle\theta_1\rangle$ and 
$t_2=\langle\theta_2\rangle$) via Eqn. \eqref{equilX_MCMC}, enabling us to obtain $\Delta F$ via Eqn. \eqref{DeltaF_stat_mech}.

How should the weight function be engineered such that gateway states are over-sampled? Let us define the quantity
\begin{equation}
M(\lbrace\mathbf{u}_i\rbrace)=E(\lbrace\mathbf{R}^{1}_i+\mathbf{u}_i\rbrace)
-E(\lbrace\mathbf{R}^{2}_i+\mathbf{u}_i\rbrace),
\end{equation}
where $E(\lbrace\mathbf{r}_i\rbrace)$ denotes the energy of the state with positions $\lbrace\mathbf{r}_i\rbrace$. The first term on the right-hand side
is the energy associated with the state in phase 1 where the displacements are $\lbrace\mathbf{u}_i\rbrace$ for phase 1, and the second term is the 
analogous quantity for phase 2. Note that the states $\lbrace\mathbf{r}_i\rbrace=\lbrace\mathbf{R}^{1}_i+\mathbf{u}_i\rbrace$ and 
$\lbrace\mathbf{r}_i\rbrace=\lbrace\mathbf{R}^{2}_i+\mathbf{u}_i\rbrace$ differ by a lattice switch: performing a lattice switch from the former yields 
the latter and \emph{vice versa}. Note also that $M(\lbrace\mathbf{u}_i\rbrace)=0$ if the energies of both these states are identical. In this
case the energy cost of a lattice switch is zero, an attempted lattice switch from either state would be successful, and hence both states are gateway 
states. By contrast, if $|M(\lbrace\mathbf{u}_i\rbrace)|\gg 0$, then the two states have significanly different energies. In this case, while
switching from the higher-energy state to the lower-energy state is guaranteed, the converse is not: the two states are not concordant with switching
\emph{to and from} both phases.
$|M(\lbrace\mathbf{u}_i\rbrace)|$ therefore provides a measure of how `un-gateway-like' a state with displacements $\lbrace\mathbf{u}_i\rbrace$ 
is, with zero corresponding to a gateway state. With this in mind, if we choose the weight function $\eta_{\sigma}$ to take the same value $\eta_{M}$ 
for all states with the same $M$, and also choose $\eta_{M}$ to be peaked at $M=0$ and to decay monotonically with 
$|M|$, then the weight function corresponds to a `force' which drives the system towards gateway states.
This is, of course, just a \emph{qualitative} description of a form for $\eta_{M}$ which is sufficient for our purposes. As one might expect, 
the quantitative details of the weight function $\eta_{M}$ strongly affect the efficiency of the path traversed though phase space with regards 
to calculating $\Delta F$; a `bad' weight function might result in the system getting stuck in one phase, or an unimportant region of phase space, for
a long time. Furthermore, it is not obvious \emph{a priori} what a suitable weight function for a given system should be. Hence one must 
\emph{generate} a weight function which leads to an efficient sampling of phase space. After this \emph{weight function generation simulation},
the resulting weight function can be used in a \emph{production simulation} to calculate $\Delta F$ as described above.

Given that we are constraining the weight function to take the same value for all states with the same $M$, it is convenient to define a
macrostate, which we also denote as $M$, which is comprised of all such states. Thus in implementing multicanonical Monte Carlo
in the computer, it is sufficient to store the value of the weight function for each $M$ considered, instead of for each state - which is
intractable. Of course, it is impossible to treat $M$ as a continuous variable in the computer; in reality the considered range of $M$ will
be split into $N_{\text{macro}}$ bins each corresponding to a range of $M$. Each bin itself corresponds to a macrostate: the macrostate is the
collection of states corresponding to the range of $M$ covered by the bin. We will henceforth explicitly take the discretisation of $M$ into
account. Let $\mathcal{M}$ denote the macrostate corresponding to the $\mathcal{M}$th bin, where $\mathcal{M}=1,2,\dotsc,N_{\text{macro}}$.
Accordingly let $\eta_{\mathcal{M}}$ denote the weight function for macrostate $\mathcal{M}$.

\section{Weight function generation}\label{sec:weight_generation}
We will now describe how weight functions can be generated for use in a production simulation.
In multicanonical Monte Carlo the `ideal' weight function, which we denote as $\eta_{\mathcal{M}}^*$, is regarded as that which leads to 
all macrostates within an `allowed range' of order parameter to be sampled with equal probability in the multicanonical Monte Carlo simulation.
Let $\tilde{p}_{\mathcal{M}}$ denote the probability that the multicanonical Monte Carlo simulation is in macrostate $\mathcal{M}$; formally,
\begin{equation}
\tilde{p}_{\mathcal{M}}=\sum_{\sigma\in\mathcal{M}}\tilde{p}_{\sigma}.
\end{equation}
Thus $\eta_{\mathcal{M}}^*$ would yield $\tilde{p}_{\mathcal{M}}=C$ for all $\mathcal{M}$ within the allowed range, where $C$ is some constant.
$\eta^*_{\mathcal{M}}$, or at least a close estimate of it, can be determined using various methods; below we 
describe the methods supported by \emph{monteswitch}. 
However we emphasise that strictly speaking it is unnecessary to use the ideal weight function, which samples all macrostates with exactly equal 
probablility, during the
production simulation. The choice of weight function affects the accuracy of physical quantities determined during the production simulation
(evaluated using Eqn. \eqref{equilX_MCMC}) only in that it determines the efficiency with which phase space is explored. For this reason though a
weight function close
to the ideal is desirable because it enables gateway states to be visited often, hence allowing both phases to be explored regularly: 
a weight function which is `far from ideal' may not result in gateway states being visited often enough to enable useful estimates
of $t_1$ and $t_2$ to be obtained. However, using the latter weight function would enable useful estimates for $t_1$ and $t_2$ to be obtained
\emph{eventually}.

\subsection{Visited states method}\label{sec:visited_states}
The \emph{visited states method} (see Ref. \cite{Smith_1995} and references therein) is arguably the simplest method for generating the weight function. 
In this method, the simulation consists of a number of
`blocks', which themselves consist of a large number of Monte Carlo sweeps. Multicanonical Monte Carlo is used, and the weight function is updated at
the end of each block. The weight function is different -- closer to the ideal -- in each subsequent block, and information
collected during each block is used to inform the weight function to be used in the next block. Eventually the weight function converges on the 
ideal: it provides a `flat' macrostate histogram; the weight function is such that all macrostates are sampled with equal probability.

Let $H^{(n)}_{\mathcal{M}}$ denote the number of states belonging to macrostate $\mathcal{M}$ which were visited during block $n$.
The specific equation used to obtain the weight function for the next block $n+1$ is
\begin{equation}
\eta^{(n+1)}_{\mathcal{M}}=\eta^{(n)}_{\mathcal{M}}-\ln\Biggl\lbrace
\frac{H^{(n)}_{\mathcal{M}}+1}{\sum_{\mathcal{M}'}\bigl(H^{(n)}_{\mathcal{M}'}+1\bigr)}
\Biggr\rbrace
+k,
\end{equation}
where $\eta^{(n)}_{\mathcal{M}}$ denotes the weight function for block $n$; the summation over $\mathcal{M}'$ on the denominator of the fraction is
over all macrostates $1,2,\dotsc,N_{\text{macro}}$; and $k$ is an inconsequential arbitrary constant,
\footnote{Only differences in the values of the weight function between states are `physically significant'; the absolute values 
of the weight function are not. See, e.g., Eqn. \eqref{p_multicanonical}.}
which we choose such that the minimum value of $\eta^{(n+1)}_{\mathcal{M}}$ over all $\mathcal{M}$ is 0.
The above equation acts to enhance the value of the weight function for macrostates which have not been visited often during the previous block, and
diminish the weight function for macrostates which have been visited. Eventually the weight function is such that all macrostates are visited equally
often. 
With regards to the choice of initial weight function for the simulation, i.e., $\eta^{(0)}_{\mathcal{M}}$, we use $\eta^{(0)}_{\mathcal{M}}=1$
for all $\mathcal{M}$. 

In practice the visited states method converges to the ideal weight function very slowly, and is not amenable to parallelisation. 
For this reason we do not recommend that it is the sole method used to 
generate weight function with \emph{monteswitch}, but primarily, or perhaps entirely, use the other methods for generating weight functions described 
in a moment. These other methods are much more efficient at obtaining a weight function close to the ideal. However, these methods, as implemented in 
\emph{monteswitch}, perhaps never converge on the ideal, while the visited states method does \cite{Smith_1995}. 
This limitation of the other methods is in practice probably
unimportant; as mentioned earlier, it is unnecessary to use the `exact' ideal weight function, just a weight function `close' to the ideal, which
these methods provide. Nevertheless the visited states method is included within \emph{monteswitch} in order that the exact ideal weight function can
be calculated if required, possibly after a weight function close to the ideal has already been obtained using the aforementioned faster methods.


\subsection{Transition matrix method}\label{sec:transition_matrix}
$\eta_{\mathcal{M}}^*$ can be related to $p_{\mathcal{M}}$, the \emph{canonical} probability of the system being in macrostate $\mathcal{M}$. Firstly,
note that $\tilde{p}_{\mathcal{M}}$ for a multicanonical simulation using weight function $\eta_{\mathcal{M}}$ obeys
\begin{equation}
\tilde{p}_{\mathcal{M}}\propto e^{\eta_{\mathcal{M}}}p_{\mathcal{M}}.
\end{equation}
This follows from Eqn. \eqref{MCMC_prob_2}: summing over all $\sigma\in\mathcal{M}$ on the left-hand expression, and recalling that 
$\eta_{\sigma}=\eta_{\mathcal{M}}$ for such $\sigma$. Applying the condition $\tilde{p}_{\mathcal{M}}=C$ for $\eta_{\mathcal{M}}=\eta_{\mathcal{M}}^*$ yields
\begin{equation}
C\propto e^{\eta^*_{\mathcal{M}}}p_{\mathcal{M}},
\end{equation}
which can be rearranged to give
\begin{equation}\label{ideal_wf}
\eta^*_{\mathcal{M}}=C'-\ln p_{\mathcal{M}},
\end{equation}
where $C'$ is a constant. Eqn. \eqref{ideal_wf} reveals that $\eta^*_{\mathcal{M}}$ can be obtained from $p_{\mathcal{M}}$. $p_{\mathcal{M}}$ 
in turn can be determined from the \emph{macrostate transition probability matrix} $\mathcal{T}_{\mathcal{MM}'}$, which describes the probability that
the system, currently in macrostate $\mathcal{M}$, transitions to macrostate $\mathcal{M}'$. 
In the \emph{transition matrix method} \cite{Smith_1995,Fitzgerald_1999}
we keep track of the transitions between all pairs of macrostates, use that information to calculate 
$\mathcal{T}_{\mathcal{MM}'}$, then $p_{\mathcal{M}}$, and finally $\eta_{\mathcal{M}}^*$ via Eqn. \eqref{ideal_wf}.

The first step is to calculate $\mathcal{T}_{\mathcal{MM}'}$. To do this, we keep a histogram of the number of \emph{supposed} transitions between 
each pair of macrostates -- where the meaning of `inferred' will become clear in a moment. Let $H_{\mathcal{M}\mathcal{M}'}$ denote the number of inferred 
transitions between macrostates $\mathcal{M}$ and $\mathcal{M}'$. Again, note that the aforementioned transitions pertain to the true ensemble, 
\emph{not to the multicanonical one}. We update $H_{\mathcal{M}\mathcal{M}'}$ and $H_{\mathcal{M}\mathcal{M}}$ every time a trial state is generated which, if 
accepted, would take the system from macrostate $\mathcal{M}$ to macrostate $\mathcal{M}'$. The update scheme is as follows
\begin{equation}
\begin{split}
H_{\mathcal{M}\mathcal{M}'}\to H_{\mathcal{M}\mathcal{M}'}+p_{\text{Metro}}, \\
H_{\mathcal{M}\mathcal{M}}\to H_{\mathcal{M}\mathcal{M}}+1-p_{\text{Metro}},
\end{split}
\end{equation}
where $p_{\text{Metro}}$ is the probability of the move being accepted according to the \emph{Metropolis algorithm} (Eqn. \eqref{p_Metropolis}) --
\emph{not} the analogous algorithm for multicanonical Monte Carlo (Eqn. \eqref{p_multicanonical}). To restate, for every trial move, we determine the
probability of the move being accepted according to the Metropolis algorithm, and update the histogram $H_{\mathcal{M}\mathcal{M}'}$, not with
the number of \emph{observed} transitions, but with the number of transitions \emph{supposed} to occur given the probability given by the
Metropolis algorithm. 
The benefit of this approach is that $H_{\mathcal{M}\mathcal{M}}$ can be obtained even if Metropolis sampling is not used, i.e.
if multicanonical sampling is used. To elaborate, note that in the above equation while the Metropolis probability $p_{\text{Metro}}$ is used to update 
$H_{\mathcal{M}\mathcal{M}'}$, the actual algorithm used to determine whether the move is accepted or not does not necessarily have to be the Metropolis
algorithm -- the multicanonical algorithm could be used. This is useful because Metropolis sampling alone would not explore the full range of
macrostates $\mathcal{M}$, which is necessary to `fill up' the matrix $H_{\mathcal{M}\mathcal{M}'}$. We discuss methods for exploring the phase space
in a transition matrix simulation in a moment.
From the matrix $H_{\mathcal{M}\mathcal{M}'}$ we obtain an estimate for $\mathcal{T}_{\mathcal{MM}'}$ using the following equation:
\begin{equation}\label{T_estimate}
\mathcal{T}_{\mathcal{M}\mathcal{M}'}\approx \frac{H_{\mathcal{M}\mathcal{M}'}+1}
{\displaystyle\sum_{\mathcal{M}^{\prime\prime}}\bigl(H_{\mathcal{M}\mathcal{M}^{\prime\prime}}+1\bigr)}.
\end{equation}

The second step is to use our estimate of $\mathcal{T}_{\mathcal{MM}'}$ to calculate $p_{\mathcal{M}}$. It can be shown that the macrostates obey a
detailed balance condition
\begin{equation}
\mathcal{T}_{\mathcal{M}'\mathcal{M}}p_{\mathcal{M}'}=\mathcal{T}_{\mathcal{MM}'}p_{\mathcal{M}}.
\end{equation}
Setting $\mathcal{M}'=\mathcal{M}+1$ and rearranging gives
\begin{equation}\label{shooting}
p_{(\mathcal{M}+1)}=\frac{\mathcal{T}_{\mathcal{M}(\mathcal{M}+1)}}{\mathcal{T}_{(\mathcal{M}+1)\mathcal{M}}}p_{\mathcal{M}}.
\end{equation}
Using this equation, $p_{\mathcal{M}}$ can be obtained from the matrix $\mathcal{T}_{\mathcal{M}\mathcal{M}'}$ using the following procedure.
Firstly, one chooses some arbitrary value for $p_1$. With this $p_2$ can be obtained from the above equation ($\mathcal{M}=1$ in Eqn. \eqref{shooting}). 
This in turn can be used to obtain $p_3$ ($\mathcal{M}=2$ in Eqn. \eqref{shooting}), which in turn can be used to obtain $p_4$, etc., until
$p_{N_{\text{macro}}}$ is obtained. Finally, one normalises the resulting function $p_{\mathcal{M}}$ such that
\begin{equation}
\sum_{\mathcal{M}=1}^{N_{\text{macro}}}p_{\mathcal{M}}=1,
\end{equation}
as is required. The final step is to use $p_{\mathcal{M}}$ to obtain an estimate for the ideal weight function. This is done simply by substituting 
$p_{\mathcal{M}}$ into Eqn. \eqref{ideal_wf}. The accuracy of the resulting ideal weight function depends on how good our statistics are with regards to
the matrix $H_{\mathcal{M}\mathcal{M}'}$ (specifically the elements in the diagonals immediately above and below the main diagonal), which is used to
estimate $\mathcal{T}_{\mathcal{M}\mathcal{M}'}$ via Eqn. \eqref{T_estimate}, and ultimately $\eta_{\mathcal{M}}$. 


\subsubsection{Methods for exploring phase space}
As alluded to above, since the updates to $H_{\mathcal{M}\mathcal{M}'}$ always use the Metropolis probabilities, with the transition matrix method one
can \emph{choose} how phase space is explored. Effectively the only constraint is that there is fast local equilibration within each macrostate. We will now
describe the various methods which can be implemented in \emph{monteswitch}.

The first method is to use multicanonical sampling to explore phase space with an evolving weight function, where the weight function
at a given time is the current estimate for the ideal weight function derived from the current $H_{\mathcal{M}\mathcal{M}'}$ as described above.
This is the `natural' way of applying the transition state method.

The second method is to use \emph{artificial dynamics} to force the system to explore all macrostates in a reasonable amount of time. In this
method, the system is first locked into a macrostate for a certain period of time. After that period of time has elapsed, the `barrier' preventing
the system from moving into an adjacent macrostate is moved such that the system is free to transition into the adjacent macrostate. Once this occurs,
the system is locked into this new macrostate, and the procedure starts again. There is of course the question of which adjacent macrostate to `open'
to the system. Assuming we are not in macrostate $\mathcal{M}=1$ or $N_{\text{macro}}$, then there are two options: $(\mathcal{M}+1)$ and $(\mathcal{M}-1)$.
In \emph{monteswitch} one can specify whether to select the new macrostate at random \cite{thesis:Jackson}, 
or whether to sweep through the macrostates systematically, e.g.,
to explore macrostates $3,4,5,\dotsc,(N_{\text{macro}}-1),N_{\text{macro}},(N_{\text{macro}}-1),\dotsc,3,2,1,2,3,\dotsc$. This method is faster than that
just described because one does not have to `wait' for the weight function to evolve such that it pushes the system to explore macrostates which
are unlikely in the true NVT ensemble.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Preliminaries}\label{chapter:preliminaries}

\section{Compiling \emph{monteswitch}}
\emph{monteswitch} is provided as an archive. This should be extracted to create a directory which consitutes the \emph{monteswitch} package. The 
package should then be compiled using the Make utility: see the `README' section in the file \texttt{Makefile}, which contains details regarding how to
specify the Fortran and MPI compiler and any flags used during compilation, as well as how to compile only the serial (i.e., non-MPI) programs
if the user's platform does not contain MPI.
The default paths to the Fortran and MPI compilers in \texttt{Makefile} are \texttt{gfortran} and \texttt{mpif90} respectively; for platforms in which
these paths apply \emph{monteswitch} can be compiled `out of the box' by invoking the command 
\begin{verbatim}
$ make serial
\end{verbatim} 
(to compile only serial executables) or 
\begin{verbatim}
$ make mpi
\end{verbatim}
(to compile \emph{all} executables).


\section{Differences in \emph{monteswitch} between platforms and compilers}
\emph{monteswitch} has not yet been tested on many platforms, and hence there may be unforeseen problems when implementing \emph{monteswitch} on
the user's platform. We have overwhelmingly used GFortran and Open MPI compilers with \emph{monteswitch}; hence these compilers can be considered 
to be the most `safe'.

[***************************** NOTE ABOUT PLATFORM-DEPENDENCE OF SCRIPTS FOR SED AND AWK IN RUN.SH IN TESTS *************************]

One issue we have found with regards to using \emph{monteswitch} on different platforms stems from the fact that \emph{monteswitch} uses Fortran's 
list-directed input and output. This means the nature of the output from \emph{monteswitch} programs is noticeably compiler-dependent. This in itself
is not a problem, though the post-processing commands given in forthcoming chapters may need to be subtly modified to work with programs compiled using 
something other than GFortran.

\section{Package overview}
After compilation, the \emph{monteswitch} directory will contain the following programs:
\begin{itemize}
\item\texttt{monteswitch}
\item\texttt{monteswitch\_mpi}
\item\texttt{monteswitch\_post}
\item\texttt{lattices\_in\_hcp\_fcc}
\item\texttt{lattices\_in\_bcc\_fcc}
\item\texttt{lattices\_in\_bcc\_hcp}
\end{itemize}
\texttt{monteswitch} and \texttt{monteswitch\_mpi} are the key programs of the package: they perform Monte Carlo simulations. 
By contrast \texttt{monteswitch\_post}, \texttt{lattices\_in\_hcp\_fcc}, \texttt{lattices\_in\_bcc\_fcc} and 
\texttt{lattices\_in\_bcc\_hcp} are utility programs: \texttt{monteswitch\_post} is for post-processing one of the output files created 
by the main programs; and \texttt{lattices\_in\_hcp\_fcc}, \texttt{lattices\_in\_bcc\_fcc} and \texttt{lattices\_in\_bcc\_hcp} are for generating 
one of the input files for the main programs. We will elaborate upon the function of each of these programs later.

\subsection{Test cases and examples}
There are a number of subdirectories within the package. The directory \texttt{Tests} contains a suite of test cases for the main programs. 
Chapter \ref{chapter:tests} contains descriptions of the tests, including how to run each test and what results 
to expect. We recommend that the tests be performed by the user to ensure that the Monte Carlo programs, as compiled by their system, work
correctly. Furthermore, these tests are also instructive, providing examples of how to perform various tasks which the typical user would be 
interested in performing. Finally, the tests serve to validate the Monte Carlo programs by illustrating that they reproduce known results.

While the test cases serve as examples, more pedagogical examples can be found in the directory \texttt{Examples}, including the worked example
of Chapter \ref{chapter:example}.

\subsection{Plug-ins for various interatomic potentials}
The directory \texttt{Interactions} contains Fortran files corresponding to various interatomic potentials. However, only one of these can be implemented 
by \texttt{monteswitch} at a time. The module which is implemented is stored in the file \texttt{interactions.f95} in the main directory; it is only the 
contents of this file which is used in the package -- after compilation. Hence to implement a specific interatomic potential one must copy
the desired `\texttt{interactions\_} file' in \texttt{Interactions} to \texttt{interactions.f95}, and then (re-)compile the package.

Note that by default the \texttt{interactions.f95} is identical to the file \texttt{interactions\_EAM.f95}, and hence compiling \emph{monteswitch}
out-of-the-box yields a version which pertains to EAM potentials.

Further information regarding interatomic potentials is provided in Chapter \ref{chapter:interactions}.

\section{Source code documentation}
HTML documentation for the source code can be generated from `marked-up' comments in the source code files. Invoking the command 
\begin{verbatim}
$ make srcdocs
\end{verbatim}
generates this documentation: each HTML file corresponds to a particular source code file.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Monte Carlo simulation programs}\label{chapter:simulation_programs}
The key programs in the package are \texttt{monteswitch} and \texttt{monteswitch\_mpi}, which run (LSMC) Monte Carlo simulations. 
The latter is the MPI-parallelised analogue of the former, and the two programs are almost identical in terms of usage.
In this chapter we describe the usage of \texttt{monteswitch} in detail. Unless otherwise stated, the following information
is also pertinent to \texttt{monteswitch\_mpi}. Information specific to \texttt{monteswitch\_mpi} can be found in 
the final section of this chapter.

\section{Starting a new simulation: the argument \texttt{-new}}
There are three allowed command-line arguments to \texttt{monteswitch}: 
\begin{itemize}
\item\texttt{-new}
\item\texttt{-resume}
\item\texttt{-reset}
\end{itemize}
The command-line argument \texttt{-new} (Example usage: \texttt{monteswitch -new}) runs a new simulation. 
The simulation is initialized using information contained in the input files \texttt{params\_in}, \texttt{lattices\_in} and \texttt{interactions\_in} in
the current directory. The file \texttt{lattices\_in} contains specifications of two microstates. This file determines the two phases which will be 
considered, and defines the lattice switch which will be used in the simulation. The file \texttt{interactions\_in} contains variables pertaining to 
the interatomic potential. All other variables which determine the nature of the simulation are contained within the file \texttt{params\_in}.
We will now describe the format of these files.

\section{Input file: \texttt{lattices\_in}}
The input file \texttt{lattices\_in} contains specifications of two microstates (i.e., supercell dimensions and particle positions), one for
each phase. The format of this file is as follows. The 1st line is a comment line, and is ignored by the main programs. The 2nd line contains
the number of particles $N$ in both phases (and must be the same for both phases). The 3rd, 4th and 5th lines contain the dimensions of the
supercell for phase 1 in the x-, y- and z-directions respectively. The next $N$ lines contain the `species' and positions of the particles within 
the supercell for phase 1 \emph{in fractional coordinates}: each line contains the fractional x-, y- and z-coordinates for the particle, followed 
by an integer which signifies its species. (A particle's species potentially determines how it interacts with other particles; \emph{monteswitch} 
allows different interatomic potentials between sets of particles belonging to different species. The specifics of this are determined by the file 
\texttt{interactions.f95} -- see Chapter \ref{chapter:interactions}). The remaining lines in \texttt{lattices\_in} similarly specify the supercell 
for phase 2: the next 3 lines contains the dimensions of the supercell for phase 2 in the x-, y- and z-directions respectively; and the next $N$ 
lines contain the fractional positions and species of the particles for phase 2.
Here is an example of a \texttt{lattices\_in} file corresponding to phase 1 being an 8-atom bcc supercell and phase 2 being an 8-atom fcc supercell,
where both phases consist entirely of atoms belonging to species `1':
\begin{verbatim}
 bcc-hcp, rho = 0.5, nx,ny,nz = 1, 1, 2
   8
 2.2449241     
 1.5874012     
 4.4898482
   0.0000000   0.0000000   0.0000000   1
   0.5000000   0.5000000   0.0000000   1
   0.5000000   0.0000000   0.2500000   1
   0.0000000   0.5000000   0.2500000   1
   0.0000000   0.0000000   0.5000000   1
   0.5000000   0.5000000   0.5000000   1
   0.5000000   0.0000000   0.7500000   1
   0.0000000   0.5000000   0.7500000   1
 2.4494897     
 1.4142136     
 4.6188021     
   0.0000000   0.0000000   0.0000000   1
   0.5000000   0.5000000   0.0000000   1
   0.3333333   0.0000000   0.2500000   1
   0.8333333   0.5000000   0.2500000   1
   0.0000000   0.0000000   0.5000000   1
   0.5000000   0.5000000   0.5000000   1
   0.3333333   0.0000000   0.7500000   1
   0.8333333   0.5000000   0.7500000   1
\end{verbatim}

The two microstates in \texttt{lattices\_in} are used in two ways by \texttt{monteswitch}. Firstly, they serve as the initial microstate: if the 
simulation is to be initialised in phase 1, then it will be initialised in the phase 1 microstate specified in \texttt{lattices\_in}; and 
similarly for phase 2. Secondly, they define the lattice switch. Let $\tilde{\mathbf{R}}^{\alpha}_i$ denote the position of the lattice site $i$
for phase $\alpha$ in fractional coordinates. (Recall our earlier discussion of lattice sites in Sec. \ref{sec:lattice_switch}). To elaborate,
the position of the lattice site in `real' coordinates is 
\begin{equation}
\mathbf{R}^{\alpha}_i=(L_x^{\alpha}\tilde{\mathbf{R}}^{\alpha}_{i,x},L_y^{\alpha}\tilde{\mathbf{R}}^{\alpha}_{i,y},L_z^{\alpha}\tilde{\mathbf{R}}^{\alpha}_{i,z}),
\end{equation}
where $L_x^{\alpha}$ denotes the current x-dimension of the supercell for phase $\alpha$ -- the current phase the system is in -- and similarly for
$L_y^{\alpha}$ and $L_z^{\alpha}$. Now, the vectors $\tilde{\mathbf{R}}^{\alpha}_i$ used by the main program are the fractional positions specified in 
\texttt{lattices\_in}: $\tilde{\mathbf{R}}^{\alpha}_i$ is taken to be the $i$th specified fractional coordinates pertaining to phase $\alpha$.
With this in mind, the lattice switch from phase 1 to 2 in a simulation consists of:
\begin{itemize}
\item A scaling of the x-dimension of the supercell of which reflects the relative sizes of the x-dimensions of both lattices specified in 
\texttt{lattices\_in}. E.g., in the above example the x-dimension would be scaled by a factor of $2.2449/2.2449=1$, i.e., not at all.
\item A similar scaling for the y-dimension of the supercell. E.g., in the above example the y-dimension would be scaled by a factor of
$1.414/1.587=0.891$.
\item A similar scaling for the z-dimension of the supercell. E.g., in the above example the y-dimension would be scaled by a factor of
$4.619/4.490=1.029$.
\item A change in the fractional position of each lattice site $i$ from $\tilde{\mathbf{R}}^{1}_i$ to $\tilde{\mathbf{R}}^{2}_i$.
\end{itemize}
The lattice switch from phase 2 to 1 is the reverse of the above.

Note that in a \texttt{monteswitch} LSMC simulation, the vectors $\tilde{\mathbf{R}}^{\alpha}_i$ do not change. This means that
if the volume of the system is expanded in an NPT simulation, then there is a commensurate scaling of the lattice sites 
$\mathbf{R}^{\alpha}_i$.

\section{Input file: \texttt{interactions\_in}}
The file \texttt{interactions\_in} contains variables which parametrise the interatomic potential. The format of this file depends on
the nature of the \texttt{interactions.f95} file used when compiling \emph{monteswitch}, a topic which is discussed in detail in Chapter
\ref{chapter:interactions}.

\section{Input file: \texttt{params\_in}}\label{section:params_in}
The input file \texttt{params\_in} contains the variables which determine the nature of the simulation. Each variable corresponds to a
specific single line in the file, and each line must consist of a string (we recommend the name of the variable followed immediately
by an `=' character with no spaces), followed by whitespace, followed by the value of the variable. The variables which must appear
in a \texttt{params\_in}, as well as a description of their function, are given in Table \ref{table:params_in_variables}. 
\emph{Note that the variables must appear in params\_in in the order that they appear in the table}. E.g., the first 
variable must be \textbf{init\_lattice}, the second must be \textbf{M\_grid\_size}, etc. Examples of \texttt{params\_in} files can
be found in the \texttt{Tests} and \texttt{Examples} directories, which can serve as templates for the user.
%
Note that by `move' we mean one of either a: particle move, in which one particle is moved to generate a trial microsate; a lattice move, in 
which the lattice is switched; and a volume move, in which the unit cell itself is altered. Furthermore if the move is rejected then it is 
still deemed to have taken place. For an NVT ensemble with lattice moves enabled the following move `cycle' is performed: particle move, 
lattice move. For an NPT ensemble with lattice moves enabled the move cycle is: particle move, lattice move, (volume move, lattice move), 
where the set of moves in the brackets occur on average \textbf{vol\_freq} times per sweep, where a `sweep' consists of $N$ move cycles,
where $N$ is the number of particles in the system.

\begin{landscape}
\begin{center}\label{table:params_in_variables}
\begin{longtable}{l l l p{8cm}}
\caption{Control variables for \texttt{monteswitch}, and descriptions of their functions. These variables must be specified in the \texttt{params\_in} file, 
one per line, in the order specified in the table. `Line' refers to the line number in \texttt{params\_in} on which the corresponding variable must appear.}
\\

Line & Variable & Type & Description \\
\hline
1 & \textbf{init\_lattice}  &  \texttt{INTEGER}  & Starting phase for the simulation (1 or 2). \\
2 & \textbf{M\_grid\_size}  &  \texttt{INTEGER}  & Number of macrostates to divide the considered order parameter range (\textbf{M\_grid\_min} to \textbf{M\_grid\_max})
into. \\
3 & \textbf{M\_grid\_min}  &  \texttt{REAL}  & Minimum of considered order parameter range. Note that moves which take the system outwith the considered range are
automatically rejected. In other words, the system is constrained to have an order parameter between \textbf{M\_grid\_min} and \textbf{M\_grid\_max}. Hence
if one wants to perform a simulation in which the order parameter is unconstrained, one should set \textbf{M\_grid\_min} and \textbf{M\_grid\_max} to
values which would never be realised by the system, e.g., $-1\times 10^{100}$ and $1\times 10^{100}$ respectively. This would be the case if one wishes
to use \texttt{monteswitch} to perform a conventional Monte Carlo simulation. \\
4 & \textbf{M\_grid\_max}  &  \texttt{REAL}  & Maximum of considered order parameter range. (See also comments for \textbf{M\_grid\_min})  \\
5 & \textbf{enable\_multicanonical}  &  \texttt{LOGICAL}  & \texttt{T} enables multicanonical sampling using the current weight function; \texttt{F} enables canonical sampling \\
6 & \textbf{beta}  &  \texttt{REAL}  & Thermodynamic beta.  \\
7 & \textbf{P}  &  \texttt{REAL}  & Pressure (only relevant in NPT ensemble simulations)  \\
8 & \textbf{enable\_lattice\_moves}  &  \texttt{LOGICAL}  & \texttt{T} enables lattice-switch moves (performed after evey particle and volume move). \\
9 & \textbf{enable\_part\_moves}  &  \texttt{LOGICAL}  & \texttt{T} enables particle moves. Of course this should be set to \texttt{T}; however disabling particle moves and 
enabling volume moves may be useful for `relaxing' the volume of the system before simulations with particle moves are performed. \\
10 & \textbf{enable\_vol\_moves}  &  \texttt{LOGICAL}  & \texttt{T} enables volume moves and selects the NPT ensemble; \texttt{F} selects the NVT ensemble. A volume move will be
attempted on average \textbf{vol\_freq} times per sweep. We recommend that this be set to 1. \\
11 & \textbf{part\_select}  &  \texttt{CHARACTER(30)}  & Flag determining how the next particle to move is selected: \texttt{cycle} selects particles sequentially, \texttt{rand} selects
particles at random.  \\
12 & \textbf{part\_step}  &  \texttt{REAL}  & Particle move maximum size; particles are moved according to a random walk, with a maximum move size of \textbf{part\_step}
in any Cartesian direction.  \\
13 & \textbf{enable\_COM\_frame}  &  \texttt{LOGICAL}  & \texttt{T} performs the simulation in the center-of-momentum reference frame; \texttt{F} uses the lab frame. Using the 
centre-of-momentum frame prevents `drift' in the centre-of-momentum. This is especially important for lattice-switch simulations. Hence this should be set 
to \texttt{T} unless the user has a very good reason not to. \\
14 & \textbf{vol\_dynamics}  &  \texttt{CHARACTER(30)}  & Flag determining which type of volume moves are performed: \texttt{FVM} (fixed volume move) keeps the supercell 
shape unchanged during a volume move; \texttt{UVM} (unconstrained volume move) allows the x-, y- and z-dimensions to move independently. Note that currently
lattice moves are forbidden in conjunction with unconstrained volume moves, though this may be relaxed in the future. \\
15 & \textbf{vol\_freq}  &  \texttt{INTEGER}  & Number of volume moves performed per sweep on average.  \\
16 & \textbf{vol\_step}  &  \texttt{REAL}  & Volume move maximum step size; the volume is moved according to a random walk in `$\ln(V)$-space', with a maximum move size 
of \textbf{vol\_step}.  \\
17 & \textbf{stop\_sweeps}  &  \texttt{INTEGER}  & Total number of sweeps to perform in the simulation. If this is set to 0 then no Monte Carlo moves are performed,
but tasks performed periodically during the Monte Carlo loop (i.e, updating the weight function, checking whether or not the system has melted, checking for
`divergences' in the energy, calculating equilibrium quantities and their uncertainties) are performed. \\
18 & \textbf{equil\_sweeps}  &  \texttt{INTEGER}  & Number of sweeps to disregard before the system is considered to be equilibrated; statistics are not gathered during
these sweeps. \\
19 & \textbf{enable\_melt\_checks}  &  \texttt{LOGICAL}  & \texttt{T} enables periodic checks of whether the system has `melted', i.e., if one or more of the particles has
moved more than a distance of \textbf{melt\_threshold} from its lattice site in any Cartesian direction then the system is considered to have `melted'.
We recommend that this feature is used, since the LSMC method relies upon the fact that the two phases under consideration are metastable,
and that particles will not move too far from their lattice sites on the timescale of the simulation. \\
20 & \textbf{melt\_sweeps}  &  \texttt{INTEGER}  & Period (sweeps) to check for melting.  \\
21 & \textbf{melt\_threshold}  &  \texttt{REAL}  & See \textbf{enable\_melt\_checks}.  \\
22 & \textbf{melt\_option}  &  \texttt{CHARACTER(30)}  & Flag determining what the simulation does if the system has `melted': \texttt{zero\_1} and \texttt{zero\_2} move the system 
to the zero-displacement microstates in phases 1 and 2, respectively; \texttt{zero\_current} does the same but for the current phase; \texttt{stop} stops the simulation
with an exit status of 2. For \texttt{zero\_1}, \texttt{zero\_2}, \texttt{zero\_current} the system is allowed to re-equilibrate before statistics are gathered. Also, the
current block with regards to the calculation of equilibrium quantities is disregarded. \\
23 & \textbf{enable\_divergence\_checks}  &  \texttt{LOGICAL}  & \texttt{T} enables periodic checks of whether the energy of the system is correct. To elaborate, for particle 
moves, the energy of the trial microstate is not calculated exactly because it is very computationally expensive and unnecessary. Instead the energy 
\emph{change} with respect to the current microstate is calculated. This is far less demanding to calculate. If the move is accepted this change is 
\emph{ammended} to the total energy. However, over time it is possible that this `running total' approach will yield incorrect energies due to the finite 
precision of the computer. Hence one should periodically recalculate the energy exactly. This is done during volume moves. If 
\textbf{enable\_divergence\_checks} is set to \texttt{T}, then this is also done every \textbf{divergence\_sweeps} sweeps, after which the recalculated energy 
is compared to the 'current' energy, and the simulation is stopped with an exit status of 3 if they are different -- outwith a tolerence of 
\textbf{divergence\_tol}. Note that the order parameter is also ammended after the energy (for phases 1 and 2) is recalculated. We recommend that this 
feature is used in NVT simulations, since it forces the energy of the system to be recalculated from scratch every so often. For NPT simulations this 
should not an issue since the energy is calculated from scratch every accepted volume move. \\
24 & \textbf{divergence\_sweeps}  &  \texttt{INTEGER}  & Period (sweeps) to check for `energy divergences' as just mentioned. Note that checking entails re-calculating
the energy from scratch.  \\
25 & \textbf{divergence\_tol}  &  \texttt{REAL}  & See \textbf{enable\_divergence\_checks}.  \\
26 & \textbf{output\_file\_period}  &  \texttt{INTEGER}  & Period (sweeps) at which information is output to the file \texttt{data}. See Section \ref{sec:output}. \\
27 & \textbf{output\_file\_Lx}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
28 & \textbf{output\_file\_Ly}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
29 & \textbf{output\_file\_Lz}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
30 & \textbf{output\_file\_V}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
31 & \textbf{output\_file\_R\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
32 & \textbf{output\_file\_R\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
33 & \textbf{output\_file\_u}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
34 & \textbf{output\_file\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
35 & \textbf{output\_file\_E}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
36 & \textbf{output\_file\_M}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
37 & \textbf{output\_file\_eta}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
38 & \textbf{output\_file\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
39 & \textbf{output\_file\_accepted\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
40 & \textbf{output\_file\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
41 & \textbf{output\_file\_accepted\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
42 & \textbf{output\_file\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
43 & \textbf{output\_file\_accepted\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
44 & \textbf{output\_file\_rejected\_moves\_M\_OOB}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
45 & \textbf{output\_file\_M\_OOB\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
46 & \textbf{output\_file\_M\_OOB\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
47 & \textbf{output\_file\_barrier\_macro\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
48 & \textbf{output\_file\_barrier\_macro\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
49 & \textbf{output\_file\_rejected\_moves\_M\_barrier}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
50 & \textbf{output\_file\_moves\_since\_lock}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
51 & \textbf{output\_file\_melts}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
52 & \textbf{output\_file\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
53 & \textbf{output\_file\_sigma\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
54 & \textbf{output\_file\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
55 & \textbf{output\_file\_sigma\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
56 & \textbf{output\_file\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
57 & \textbf{output\_file\_sigma\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
58 & \textbf{output\_file\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
59 & \textbf{output\_file\_sigma\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
60 & \textbf{output\_file\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
61 & \textbf{output\_file\_sigma\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
62 & \textbf{output\_file\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
63 & \textbf{output\_file\_sigma\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
64 & \textbf{output\_file\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
65 & \textbf{output\_file\_sigma\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
66 & \textbf{output\_file\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
67 & \textbf{output\_file\_sigma\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
68 & \textbf{output\_file\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
69 & \textbf{output\_file\_sigma\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
70 & \textbf{output\_stdout\_period}  &  \texttt{INTEGER}  & Period (sweeps) at which information is output to stdout. See Section \ref{sec:output}. \\
71 & \textbf{output\_stdout\_Lx}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
72 & \textbf{output\_stdout\_Ly}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
73 & \textbf{output\_stdout\_Lz}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
74 & \textbf{output\_stdout\_V}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
75 & \textbf{output\_stdout\_R\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
76 & \textbf{output\_stdout\_R\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
77 & \textbf{output\_stdout\_u}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
78 & \textbf{output\_stdout\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
79 & \textbf{output\_stdout\_E}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
80 & \textbf{output\_stdout\_M}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
81 & \textbf{output\_stdout\_eta}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
82 & \textbf{output\_stdout\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
83 & \textbf{output\_stdout\_accepted\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
84 & \textbf{output\_stdout\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
85 & \textbf{output\_stdout\_accepted\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
86 & \textbf{output\_stdout\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
87 & \textbf{output\_stdout\_accepted\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
88 & \textbf{output\_stdout\_rejected\_moves\_M\_OOB}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
89 & \textbf{output\_stdout\_M\_OOB\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
90 & \textbf{output\_stdout\_M\_OOB\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
91 & \textbf{output\_stdout\_barrier\_macro\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
92 & \textbf{output\_stdout\_barrier\_macro\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
93 & \textbf{output\_stdout\_rejected\_moves\_M\_barrier}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
94 & \textbf{output\_stdout\_moves\_since\_lock}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
95 & \textbf{output\_stdout\_melts}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
96 & \textbf{output\_stdout\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
97 & \textbf{output\_stdout\_sigma\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
98 & \textbf{output\_stdout\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
99 & \textbf{output\_stdout\_sigma\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
100 & \textbf{output\_stdout\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
101 & \textbf{output\_stdout\_sigma\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
102 & \textbf{output\_stdout\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
103 & \textbf{output\_stdout\_sigma\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
104 & \textbf{output\_stdout\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
105 & \textbf{output\_stdout\_sigma\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
106 & \textbf{output\_stdout\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
107 & \textbf{output\_stdout\_sigma\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
108 & \textbf{output\_stdout\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
109 & \textbf{output\_stdout\_sigma\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
110 & \textbf{output\_stdout\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
111 & \textbf{output\_stdout\_sigma\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
112 & \textbf{output\_stdout\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
113 & \textbf{output\_stdout\_sigma\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
114 & \textbf{checkpoint\_period}  &  \texttt{INTEGER}  & Period (sweeps) at which the simulation is checkpointed, i.e., how often all simulation variables are
output to the file \texttt{state}. If \textbf{checkpoint\_period} is $\leq 0$ then \texttt{state} will be an empty file. See Section \ref{sec:output}. \\
115 & \textbf{update\_eta}  &  \texttt{LOGICAL}  & \texttt{T} results in the weight function being periodically updated every \textbf{update\_eta\_sweeps} sweeps, according
to the method specified in \textbf{update\_eta\_method}; \texttt{F} results in the weight function not being updated -- it remains frozen at its current state.  \\
116 & \textbf{update\_eta\_sweeps}  &  \texttt{INTEGER}  & Period (seeps) at which the weight function is updated. \\
117 & \textbf{update\_trans}  &  \texttt{LOGICAL}  & \texttt{T} results in the transition matrix being updated; \texttt{F} results in it not being updated.  \\
118 & \textbf{update\_eta\_method}  &  \texttt{CHARACTER(30)}  & Method used to update the weight function: \texttt{VS} uses the visited states method; \texttt{shooting} uses the
shooting method (using the current transition matrix). ELABORATE.  \\
119 & \textbf{enable\_barriers}  &  \texttt{LOGICAL}  & \texttt{T} enables artificial dynamics; for \texttt{F} the system is free to explore any macrostate, but is constrained to
reside within the considered order parameter range (\textbf{M\_grid\_min} to \textbf{M\_grid\_max}).  \\
120 & \textbf{barrier\_dynamics}  &  \texttt{CHARACTER(30)}  & Flag determining how the macrostate barriers will evolve during artificial dynamics. 
All methods lock the system into a single
macrostate for \textbf{lock\_moves} moves, before unlocking an adjacent macrostate. Once the system has moved into the adjacent macrostate, the system
is then locked into that macrostate, and the procedure starts again. \texttt{random} evolves the macrostate the system is locked into via a random walk: the
next macrostate is decided with equal probability to be that above or that below the current macrostate. \texttt{pong\_up} moves to increasingly higher 
macrostates until the upper limit of the supported order parameter range is encountered, at which point it reverses direction and proceeds to 
increasingly lower macrostates until it reaches the lower limit of the order parameter range, at which point it reverses direction, etc. \texttt{pong\_down}
instead moves initially to increasingly lower macrostates.  \\
121 & \textbf{lock\_moves}  &  \texttt{INTEGER}  & The number of moves to lock the system into one macrostate for if artificial dynamics is used. 
This should be greater than 0. \\
122 & \textbf{calc\_equil\_properties}  &  \texttt{LOGICAL}  & \texttt{T} enables calculation of equilibrium quantities using block analysis. ELABORATE.  \\
123 & \textbf{block\_sweeps}  &  \texttt{INTEGER}  & The number of sweeps which comprise a 'block' which will be used to evaluate equilibrium properties and
their uncertainties as just described. This should be greater than 0. \\
\end{longtable}
\end{center}
\end{landscape}

\section{Output: stdout, \texttt{state} and \texttt{data}}\label{sec:output}
During a simulation,information is periodically output to stdout and the file \texttt{data}. The variables with names beginning with 
\textbf{output\_file\_} and \textbf{output\_stdout\_} determine which variables are output to \texttt{data} and stdout respectively.
The variable \textbf{output\_file\_X}, where \textbf{X} is the name of a simulation variable (a list is given below), when set to \texttt{T}, 
will result in a line consisting of \texttt{X: } followed by the number of completed sweeps, followed by the current value of \textbf{X} 
being printed to \texttt{data} every \textbf{output\_file\_period} sweeps. However, if \textbf{output\_file\_period} is set to 0, then instead 
the output is after every move; and if \textbf{output\_file\_period} is a negative integer, then there is no output to the file, i.e., the
output is suppressed. The above also applies to \textbf{output\_stdout\_X}, but for the output to stdout. 
The only exceptions to the aforedescribed significance of variables beginning with \textbf{output\_file\_} and \textbf{output\_stdout\_}
are \textbf{output\_file\_eta} and \textbf{output\_stdout\_eta}. For these quantities \textbf{eta} refers to the
value of the weight function \emph{for the current microstate} -- as opposed to the entire weight function. This point is reiterated below.
Note that there is no internal variable named \textbf{eta} in \verb|monteswitch|: the entire weight function is refered to as \textbf{eta\_grid}
in \verb|monteswitch|; \textbf{eta} is calculated on-the-fly when required from \textbf{eta\_grid} and never stored in memory.

The file \texttt{data} can be used to deduce how the system evolves with time during the simulation. For instance, one can use the information contained 
within \texttt{data} to check whether or not the system has equilibrated within a certain number of Monte Carlo sweeps. In a production simulation it
can also be used to store the `observations' performed on the system, which could be used in subsequent analysis.

In addition to \texttt{data}, a file \texttt{state} is also created by the program periodically throughout a simulation. This file contains all of the 
simulation variables, and can be used to `resume' the simulation by running \texttt{monteswitch} with the \texttt{-resume} or \texttt{-reset} argument
(see Sections \ref{sec:resume} and \ref{sec:reset}), or to extract the `results' of the simulation, e.g., equilibrium quantities, the current weight 
function, the number of accepted vs. rejected Monte Carlo moves of a certain type -- perhaps using the \texttt{monteswitch\_post} program 
(see Section \ref{sec:monteswitch_post}).
The variable \textbf{checkpoint\_period} determines how often the simulation is checkpointed: a file \texttt{state} is created every 
\textbf{checkpoint\_period} sweeps. It is also \emph{always} created at the completion of the program. Note that if \textbf{checkpoint\_period} is $\leq 0$, 
then there is no output to \texttt{state}, i.e., the file will be empty.
In the \texttt{state} file, similarly to \texttt{params\_in}, each line corresponds to a particular variable: for variable $X$ the corresponding line contains
\texttt{X=} followed by the value of that variable. The relevant line can be extracted from \texttt{state} using the utility \texttt{grep}. E.g. the command
\begin{verbatim}
$ grep "E=" state
\end{verbatim}
can be used to extract the current energy of the system from \texttt{state}.
Note that \texttt{state} contains \emph{all} the simulation variables, including those
pertaining to the interatomic potential. Hence the format of \texttt{state} depends on the details of the \texttt{interactions.f95} file. However,
all variables pertaining to the interatomic potential are stored at the end of \texttt{state}. Hence the format of \texttt{state} files down to the
point where the variables pertaining to the interatomic potential are stored is universal.

Table \ref{table:state_variables} contains a list of \texttt{monteswitch} internal variables, not already covered by Table \ref{table:params_in_variables},
which have corresponding \textbf{output\_file\_} or \textbf{output\_stdout\_} flags, or can be found in \texttt{state} and could possibly be of interest
to the user. Note that there are other variables in \texttt{state} which are not mentioned in Tables \ref{table:params_in_variables} or 
\ref{table:state_variables} -- aside from those stemming from \texttt{interactions.f95}. We do not mention them because these are not likely to be of
interest to the user; for more information see the HTML documentation for \texttt{monteswitch\_mod.f95}.
Note that the internal variable names output in \texttt{state} are case-sensitive, and exactly reflect the names given in Tables 
\ref{table:params_in_variables} and \ref{table:state_variables}.

\begin{landscape}
\begin{center}\label{table:state_variables}
\begin{longtable}{ l l p{8cm}}
\caption{Useful variables found in the file \texttt{state}.}
\\

Variable & Fortran type & Description \\
\hline
\textbf{n\_part} & \texttt{INTEGER} & Number of particles in the system. \\
\textbf{Lx} & \texttt{REAL(2)} & Dimension of supercells in x-direction: the first value pertains to phase 1 while the second pertains to phase 2.\\
\textbf{Ly} & \texttt{REAL(2)} & Dimension of supercells in y-direction: the first value pertains to phase 1 while the second pertains to phase 2.\\
\textbf{Lz} & \texttt{REAL(2)} & Dimension of supercells in z-direction: the first value pertains to phase 1 while the second pertains to phase 2.\\
\textbf{V} & \texttt{REAL} & Current volume of the system.\\
\textbf{lattice} & \texttt{INTEGER} & Current phase of the system (1 or 2).\\
\textbf{E\_1} & \texttt{REAL} & Energy of phase 1 for the current displacements. \\
\textbf{E\_2} & \texttt{REAL} & Energy of phase 2 for the current displacements. \\
\textbf{E} & \texttt{REAL} & Current energy of the system. This is \textbf{E\_1} if we are in phase 1 and \textbf{E\_2} if we are in phase 2.\\
\textbf{M} & \texttt{REAL} & Current order parameter of the system.\\
\textbf{switchscalex} & \texttt{REAL} & Scaling of the supercell in the x-dimension when performing a lattice switch from phase 1 to phase 2. The 
reciprocal of this is the scaling when performing a lattice switch from phase 2 to phase 1.\\
\textbf{switchscaley} & \texttt{REAL} & Scaling of the supercell in the x-dimension when performing a lattice switch from phase 1 to phase 2. The 
reciprocal of this is the scaling when performing a lattice switch from phase 2 to phase 1. \\
\textbf{switchscalez} & \texttt{REAL} & Scaling of the supercell in the x-dimension when performing a lattice switch from phase 1 to phase 2. The 
reciprocal of this is the scaling when performing a lattice switch from phase 2 to phase 1. \\
\textbf{sweeps} & \texttt{INTEGER} & Number of sweeps performed so far, including over previous simulations if we have used the \texttt{-resume} argument.\\
\textbf{moves} & \texttt{INTEGER} & Total number of moves performed so far in total, including over previous simulations if we have used the \texttt{-resume} 
argument.\\
\textbf{moves\_lattice} & \texttt{INTEGER} & Number of lattice moves performed so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{accepted\_moves\_lattice} & \texttt{INTEGER} & Number of accepted lattice moves so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{moves\_part} & \texttt{INTEGER} & Number of particle moves performed so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{accepted\_moves\_part} & \texttt{INTEGER} & Number of accepted particle moves so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{moves\_vol} &\texttt{INTEGER} & Number of volume moves performed so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{accepted\_moves\_vol} & \texttt{INTEGER} & Number of accepted volume moves so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{rejected\_moves\_M\_OOB} & \texttt{INTEGER} & Number of moves rejected because the order parameter of the trial state was outwith the considered range 
(`OOB' means `out of bounds'), i.e., \textbf{M\_grid\_min} to \textbf{M\_grid\_max}.\\
\textbf{M\_OOB\_high} & \texttt{INTEGER} & The highest order parameter value to be rejected because the order parameter of the trial state was outwith the 
considered range.\\
\textbf{M\_OOB\_low} & \texttt{INTEGER} & The lowest order parameter value to be rejected because the order parameter of the trial state was outwith the considered 
range.\\
\textbf{melts} & \texttt{INTEGER} & The number of times the system has melted. \\
\textbf{barrier\_macro\_low} & \texttt{INTEGER} & The macrostate number corresponding to the lowest currently allowed macrostate (relevant only when artificial
dynamics is enabled). \\
\textbf{barrier\_macro\_high} & \texttt{INTEGER} & The macrostate number corresponding to the highest currently allowed macrostate (relevant only when artificial
dynamics is enabled). \\
\textbf{rejected\_moves\_M\_barrier} & \texttt{INTEGER} & The number of moves rejected because the order parameter of the trial state was outwith the range
corresponding to the macrostate barriers (relevant only when artificial dynamics is enabled).\\
\textbf{block\_counts} & \texttt{INTEGER} & The total number of `blocks' considered so far for evaluating equilibrium quantities and their uncertainties.  \\
\textbf{equil\_DeltaF} & \texttt{REAL} & The free energy difference between the phases ($F_1-F_2$; extensive) evaluated using block analysis.\\
\textbf{sigma\_equil\_DeltaF} & \texttt{REAL} & The uncertainty in \textbf{equil\_DeltaF}.\\
\textbf{block\_counts\_DeltaF} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_DeltaF} and \textbf{sigma\_equil\_DeltaF}. Note that
blocks are disregarded if during the block the system melts, or if the system does not visit both phases. \\
\textbf{equil\_H\_1} & \texttt{REAL} & The energy (for NVT simulations) or enthalpy (for NPT simulations) of phase 1 evaluated using block analysis.\\
\textbf{equil\_H\_2} & \texttt{REAL} & The energy (for NVT simulations) or enthalpy (for NPT simulations) of phase 2 evaluated using block analysis.\\
\textbf{sigma\_equil\_H\_1} & \texttt{REAL} & The uncertainty in \textbf{equil\_H\_1}.\\
\textbf{sigma\_equil\_H\_2} & \texttt{REAL} & The uncertainty in \textbf{equil\_H\_2}.\\
\textbf{block\_counts\_H\_1} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_H\_1} and \textbf{sigma\_equil\_H\_1}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{block\_counts\_H\_2} & \texttt{INTEGER} &  The number of blocks used in evaluating \textbf{equil\_H\_2} and \textbf{sigma\_equil\_H\_2}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{equil\_V\_1} & \texttt{REAL} & The volume of phase 1 evaluated using block analysis.\\
\textbf{equil\_V\_2} & \texttt{REAL} & The volume of phase 2 evaluated using block analysis.\\
\textbf{sigma\_equil\_V\_1} & \texttt{REAL} &  The uncertainty in \textbf{equil\_V\_1}.\\
\textbf{sigma\_equil\_V\_2} & \texttt{REAL} &  The uncertainty in \textbf{equil\_V\_2}.\\
\textbf{block\_counts\_V\_1} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_V\_1} and \textbf{sigma\_equil\_V\_1}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{block\_counts\_V\_2} & \texttt{INTEGER} &  The number of blocks used in evaluating \textbf{equil\_V\_2} and \textbf{sigma\_equil\_V\_2}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{block\_counts\_umsd\_1} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_umsd\_1} and \textbf{sigma\_equil\_umsd\_1}. 
Note that blocks are disregarded if during the block the system melts. \\
\textbf{block\_counts\_umsd\_2} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2}. 
Note that blocks are disregarded if during the block the system melts. \\
\textbf{R\_1} & \texttt{REAL(n\_part,3)} & The current lattice vectors for phase 1. \\
\textbf{R\_2} & \texttt{REAL(n\_part,3)} & The current lattice vectors for phase 2.\\
\textbf{u} & \texttt{REAL(n\_part,3)} & The current displacement vectors.\\
\textbf{M\_grid} & \texttt{REAL(M\_grid\_size)} & Array containing the minimum order parameter for each macrostate: macrostate $n$ corresponds to 
order parameters between \textbf{M\_grid}$(n)$ and \textbf{M\_grid}$(n+1)$.\\
\textbf{M\_counts\_1} & \texttt{INTEGER(M\_grid\_size)} & \textbf{M\_counts\_1}($n$) is the number of times macrostate $n$ has been visited while the
system was in phase 1 so far, including over previous simulations if we have used the \texttt{-resume} argument.\\
\textbf{M\_counts\_2} & \texttt{INTEGER(M\_grid\_size)} & \textbf{M\_counts\_2}($n$) is the number of times macrostate $n$ has been visited while the
system was in phase 2 so far, including over previous simulations if we have used the \texttt{-resume} argument. \\
\textbf{eta\_grid} & \texttt{REAL(M\_grid\_size)} & \textbf{eta\_grid}($n$) is the value o the weight function for macrostate $n$. \\
\textbf{trans} & \texttt{REAL(M\_grid\_size,M\_grid\_size)} & \textbf{eta\_grid}($m,n$) is the number of inferred transitions from macrostate
$m$ to macrostate $n$; it is the matrix $H_{\mathcal{M}\mathcal{M}'}$ in Section \ref{sec:transition_matrix}. \\
\textbf{equil\_umsd\_1} & \texttt{REAL(n\_part)} & \textbf{equil\_umsd\_1}($n$) is the mean-squared displacement of particle $n$ from its lattice site
in phase 1, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{equil\_umsd\_2} & \texttt{REAL(n\_part)} & \textbf{equil\_umsd\_2}($n$) is the mean-squared displacement of particle $n$ from its lattice site
in phase 2, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{sigma\_equil\_umsd\_1} & \texttt{REAL(n\_part)} & \textbf{sigma\_equil\_umsd\_1}($n$) is the uncertainty in \textbf{equil\_umsd\_1}($n$). \\
\textbf{sigma\_equil\_umsd\_2} & \texttt{REAL(n\_part)} & \textbf{sigma\_equil\_umsd\_2}($n$) is the uncertainty in \textbf{equil\_umsd\_2}($n$). \\

\textbf{equil\_L\_1} & \texttt{REAL(3)} & The 1st, 2nd and 3rd values in the array \textbf{equil\_L\_1} are the mean x-, y- and z-dimensions of the
supercell in phase 1, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{equil\_L\_2} & \texttt{REAL(3)} &  The 1st, 2nd and 3rd values in the array \textbf{equil\_L\_2} are the mean x-, y- and z-dimensions of the
supercell in phase 2, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{sigma\_equil\_L\_1} & \texttt{REAL(3)} & \textbf{sigma\_equil\_L\_1}($n$) is the uncertainty in \textbf{equil\_L\_1}($n$). \\
\textbf{sigma\_equil\_L\_2} & \texttt{REAL(3)} & \textbf{sigma\_equil\_L\_2}($n$) is the uncertainty in \textbf{equil\_L\_2}($n$). \\
\end{longtable}
\end{center}
\end{landscape}


\section{Resuming a simulation: the argument \texttt{-resume}}\label{sec:resume}
The command-line argument \texttt{-resume} continues an `old' simulation, whose variables are contained in the file \texttt{state} in the current 
directory. The `resumed' simulation is run for the number of Monte Carlo sweeps specified in the variable \textbf{stop\_sweeps} in \texttt{state}.
By default this is the number of sweeps which were performed in the old simulation, though one of course this can be manually altered if one wants
the resumed simulation to be of a different length to the old simulation.

For a simulation invoked using the argument \texttt{-resume}, the file \texttt{data} is ammended: the resumed simulation does not overwrite the
\texttt{data} file; all information from the old simulation is retained in it.

\section{`Resetting' a simulation: the argument \texttt{-reset}}\label{sec:reset}
The command-line argument \texttt{-reset} invokes a simulation from an old \texttt{state} file similarly to \texttt{-resume}, except that it
resets all `counter variables' to zero. This has the effect of starting a `new' simulation whose nature corresponds to the old simulation, 
but instead uses the microstate of the system specified in \texttt{state}. By contrast, the command-line argument \texttt{-new} initialises the 
microstate to be such that the particles form a perfect crystal lattice, which usually does not correspond to an equilibrated microstate.
By `counter variables' we mean those such as variables describing the number of moves performed for each move type, the number of accepted moves 
for each move type, and variables pertaining to equilibrium quantities. However, note that the weight function (\textbf{eta\_grid}) and the
collection transition matrix (\textbf{trans}) are \emph{not} regarded as counter variables, and are as such retained from the old simulation
if one uses the \texttt{-reset} argument.

Note that for a simulation invoked using the argument \texttt{-reset}, the file \texttt{data} is overwritten, i.e., the information from the `old'
simulation is not retained.

\section{Exit statuses}
\texttt{monteswitch} exits with a non-zero exit status of 1 for most errors. However, if the system has melted, and \textbf{melt\_option} is set to
`stop', then the exit status is 2, and if the energy has diverged from its true value then the exit status is 3. 
Note though that exit statuses are not part of the Fortran standard, and may not work for all operating systems or compilers. 

\section{MPI simulations: \texttt{monteswitch\_mpi}}
As mentioned at the beginning of this chapter, the program \texttt{monteswitch\_mpi} is the MPI-parallelised analogue of \texttt{monteswitch}. 
It is identical to the program \texttt{monteswitch}, except that instead of a single simulation for \textbf{stop\_sweeps} Monte Carlo sweeps, 
\texttt{monteswitch\_mpi} runs $n$ simulations -- replicas -- in parallel using MPI, each being approximately \textbf{stop\_sweeps}$/n$ sweeps in 
length. Accordingly, during the simulation multiple \texttt{data}- and \texttt{state}-format files are created -- one for each replica. These 
are named \texttt{state\_0}, \texttt{state\_1}, \texttt{state\_2}, etc., and similarly for the \texttt{data}-format files. At the completion of 
all replicas, the statistics from all are combined, and the results are stored in the file \texttt{state}. The microstate stored in state
corresponds to the microstate in \texttt{state\_0}. 
Note that, since \texttt{state}-format files can be large, by default the files \texttt{state\_0}, \texttt{state\_1}, 
\texttt{state\_2}, etc. created by \texttt{monteswitch\_mpi} are empty. This can be disabled if \texttt{-explicit} is used as the second command line 
argument to \texttt{monteswitch\_mpi}, e.g., \texttt{mpiexec -n 4 monteswitch\_mpi -new -explicit}. Similar applies to the arguments \texttt{-resume} and 
\texttt{-reset}.

Further details of the parallelisation are as follows. All replicas are always initialised to be in the same microstate. For a new simulation this is 
determined by the \textbf{init\_lattice} variable in \texttt{params\_in} similarly to \texttt{monteswitch}. For a resumed simulation this is the microstate 
contained in the \texttt{state} file from which the simulation is to be resumed. We emphasise that \emph{all replicas of the system are initialised with 
the same microstate} when the \texttt{-resume} argument is used with \texttt{monteswitch\_mpi}. In future we hope to allow `true' checkpointing 
whereby a simulation picks up exactly where it left off , i.e., by having the $n$th replica initialised from the file \texttt{state\_}$n$ instead of having
all replicas initialised from \texttt{state}, and to ammend \texttt{data\_}$n$ with information pertaining to replica $n$ during the resumed
simulation. Note that the files \texttt{data\_}$n$ are thus always overwritten by \texttt{monteswitch\_mpi} when the \texttt{-resume} argument is
invoked since, given the nature of the parallelisation, there is no continuity between the replicas in subsequent simulations. The excpetion is replica `0',
whose microstate is always stored in the file \texttt{state}, as well as \texttt{state\_0}.

To expand upon what was just said, in a resumed simulation, only replica 0 -- the `master' replica -- inherits the counter variables from the previous 
simulation via the file \texttt{state}. All other replicas have counter variables initialised to zero at the start of the resumed simulation.
During the simulation, the counter variables for each replica are of course ammended according to the evolution of the replica. Once all replicas have
completed their allocated number of sweeps, the variables for the $n$th replica are exported to the file \texttt{state\_}$n$. Then 
the counter variables of all replicas, other than replica 0, are summed and ammended to replica 0. At the end of the simulation replica 0 thus has
variables which corresponding to an evolution of, if there are $N$ tasks, approximately \textbf{stop\_sweeps}$/N$ sweeps from the starting state, 
but with counter variables which correspond to \textbf{stop\_sweeps} sweeps worth of information. The variables in replica 0 are then updated to reflect 
its new counters, e.g., the weight function is recalculated using the information from the new counters. Finally, the variables are
exported to the file \texttt{state}. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interatomic potentials}\label{chapter:interactions}
As mentioned in Chapter \ref{chapter:preliminaries}, the file \texttt{interactions.f95} determines the interatomic potential implemented by
\emph{monteswitch}. The \texttt{Interactions} directory contains files which correspond to a number of commonly-used potentials. Copying, say,
\texttt{interactions\_LJ.f95} to \texttt{interactions.f95} in the main directory, and then (re-)compiling \emph{monteswitch} results in a version 
of \emph{monteswitch} in which the particles interact via a Lennard-Jones potential. While \texttt{interactions.f95} selects the `class' of potential
used in \emph{monteswitch}, the specific parametrisation of the potential used for a specific simulation is specified in the input file
\texttt{interactions\_in}. E.g. for the Lennard-Jones potential one specifies the Lennard-Jones parameters $\epsilon$ and $\sigma$ (among other
variables, see below) in the file \texttt{interactions\_in}. In this chapter we first describe the potentials included with \emph{monteswitch},
i.e., we describe the interatomic potential corresponding to each `\texttt{interactions\_} file' in the directory \texttt{Interactions}, and the
corresponding format of the \texttt{interactions\_in} file. Then in Section \ref{sec:user_defined} we describe how users can write their own
\texttt{interactions\_in} files to implement their own potentials. In time we expect more potentials to be added to \emph{monteswitch}.
Note that all potentials included with \emph{monteswitch} are for single-component systems, do not exploit the ability of \emph{monteswitch} 
to treat multicomponent systems.

\section{Embedded atom model}
The file \texttt{interactions\_EAM.f95} corresponds to the embedded atom model (EAM) \cite{Daw_1984}. Here the energy of the system 
is given by
\begin{equation}
E = \frac{1}{2}\sum_{i,j\neq i}\phi(r_{ij}) + \sum_iF(\rho_i),
\end{equation}
\begin{equation}
\rho_i=\sum_{j\neq i}\rho(r_{ij}),
\end{equation}
where $r_{ij}$ is the separation between particles $i$ and $j$, and $\phi$, $F$ and $\rho$ are functions which must be specified
and constitute the parametrisation of the EAM potential. If \texttt{interactions\_EAM.f95} is used then the \texttt{interactions\_in}
file must be a description of the potential in DYNAMO/LAMMPS `setfl' format. A file with this format is often indicated with the 
suffix `\texttt{.eam.alloy}', and a description of the format can be found at \url{http://lammps.sandia.gov/doc/pair\_eam.html}. 
Since \emph{monteswitch} currently only supports unary systems, \texttt{interactions\_in} must not correspond to a 
multicomponent system -- an error is returned if this is the case. Furthermore, at initialisation three additional files are created by the
Monte Carlo programs in \emph{monteswitch} if \texttt{interactions\_EAM.f95} is used: \texttt{F.dat}, \texttt{rho.dat} and \texttt{rphi.dat}. 
\texttt{F.dat} and \texttt{rho.dat} contain plots of the functions $F$ and $\rho$ read from \texttt{interactions\_in}, while 
\texttt{rphi.dat} contains a plot of $r\times\phi(r)$ vs. $r$ read from \texttt{interactions\_in}. 

By default \texttt{interactions.f95} is the same as \texttt{interactions\_EAM.f95}.

\section{Analytical pair potentials}\label{section:pair_potentials}
Table \ref{table:pair_potentials} gives a list of analytical (as opposed to tabulated) 
pair potentials included with \emph{monteswitch}, and the name of the corresponding
\texttt{interactions\_} file in \texttt{Interactions}. All of these potentials are implemented in the same way.
Firstly, the pair potential $\phi(r)$ is assumed to be 0 for inter-particle separations $r$ greater than some cut-off distance $r_{\text{c}}$.
Secondly, only pairs of particles within a distance $r_{\text{list}}$ of each other \emph{in the initial microstate for the simulation} interact
with each other throughout the entire simulation. To elaborate, a `list' of particles which particle $i$ interacts with in phase $p$ is created at 
the start of a simulation: the list consists of all those particles which are initially within distance $r_{\text{list}}$ of $i$ in phase $p$. Note that
\emph{monteswitch} stores two sets of lists, one for each phase, and that $r_{\text{list}}$ applies to the initial microstate for both phases. For
example if the simulation is to be initialised in phase 1 (\textbf{init\_lattice} is 1), then the initial microstate for phase 1 will correspond to
all particles being at their lattice sites in phase 1, and the initial microstate for phase 2 will correspond to all particles being at their lattice 
sites in phase 2; the lists are constructed using the same cut-off $r_{\text{list}}$ for both microstates.


[EXPLAIN LIST SIZE BETTER]
The format of the \texttt{interactions\_in} files for these potentials is similar to \texttt{params\_in} described in Section \ref{section:params_in}:
each variable which parametrises the potential corresponds to a specific line in \texttt{interactions\_in}, and each line must contain a string
(we recommend the name of the variable followed immediately by an `=' character with no spaces), followed by whitespace, followed by the value
of the variable. The final column of Table \ref{table:pair_potentials} gives the order of variables as they should appear, one per line, in
\texttt{interactions\_in} for each potential. In this column the names of the variables are those used by \emph{monteswitch}, as opposed to those
used in the preceding mathematical expression for the potential $\phi(r)$. Where it is not obvious to which variable in the mathematical expression
a variable in the last column relates, the analogous variable in the mathematical expression is given in parenthesis immediately after it. In all
cases the variables \textbf{cutoff} and \textbf{list\_cutoff} correspond to $r_{\text{c}}$ and $r_{\text{list}}$ described above. \textbf{list\_size} is the
maximum size of the list of particles which any particle in the system interacts with, + 1. If $N_{\text{list},i,p}$ denotes the number of particles within
$r_{\text{list}}$ of particle $i$, including particle $i$ itself,
in the initial microstate for phase $p$, and $N_{\text{list}}$ denotes the maximum value of $N_{\text{list},i,p}$ over all particles
$i$ and both phases $p=1$ and 2, then \textbf{list\_size} should be greater than $N_{\text{list}}$ -- it should be at least $(N_{\text{list}}+1)$ (note the
$+1$!). To illustrate the above, here is an example \texttt{interactions\_in} file for the Lennard-Jones potential (\texttt{interactions\_LJ.f95}) for
a system with 480 particles:
\begin{verbatim}
lj_epsilon= 1.0
lj_sigma= 1.0
cutoff= 3.0
list_cutoff= 100.0
list_size= 481
\end{verbatim}
Note that \textbf{list\_size} is set to 481, and not 480! Of course depending on $r_{\text{c}}$ and the density of the system one could get away with 
setting this to a smaller value. E.g. if only nearest neighbours within the fcc lattice are ever to interact, then setting \textbf{list\_size} to
$14$ would be sufficient, and save on computer memory. It is 14 because there are 12 nearest neighbours, which means that there are 13 
Note that 14 is necessary instead of 13 because there are 13 particles within (and including at)
the nearest neighbour distance of \emph{including the particle iteslf}.

\begin{landscape}
\begin{center}\label{table:pair_potentials}
\begin{longtable}{ l l l p{5cm} }
\caption{Pair potentials included with \emph{monteswitch}}
\\
Potential & File name & Expression for potential & Order of variables in \texttt{interactions\_in}  \\

\hline

12-10 & \texttt{interactions\_12-10.f95} & $\phi(r)=A/r^{12}-B/r^{10}$ 
& \textbf{A}, \textbf{B}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

12-6  &  \texttt{interactions\_12-6.f95} & $\phi(r)=A/r^{12}-B/r^{6}$ 
& \textbf{A}, \textbf{B}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Buckingham & \texttt{interactions\_Buckingham.f95} & $\phi(r)=A\exp(-r/\rho)-C/r^6$ 
& \textbf{A}, \textbf{rho}, \textbf{C}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Gaussian & \texttt{interactions\_Gaussian.f95} & $\phi(r)=-A\exp(-Br^2)$ 
& \textbf{A}, \textbf{B}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Lennard-Jones & \texttt{interactions\_LJ.f95} & $\phi(r)=\phi_{\text{LJ}}(r)=4\epsilon\bigl[(\sigma/r)^{12}-(\sigma/r)^6\bigr]$
& \textbf{lj\_epsilon} ($\epsilon$), \textbf{lj\_sigma} ($\sigma$), \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Lennard-Jones - shifted  & \texttt{interactions\_LJ\_shifted.f95} & $\phi(r)=\phi_{\text{LJ}}(r)-\phi_{\text{LJ}}(r_{\text{c}})$ 
& \textbf{lj\_epsilon} ($\epsilon$), \textbf{lj\_sigma} ($\sigma$), \textbf{lj\_cutoff} ($r_{\text{c}}$), \textbf{list\_cutoff}, \textbf{list\_size} \\

Lennard-Jones - 9-6 & \texttt{interactions\_LJ\_9-6.f95} & $\phi(r)=4\epsilon\bigl[(\sigma/r)^9-(\sigma/r)^6\bigr]$
& \textbf{lj\_epsilon} ($\epsilon$), \textbf{lj\_sigma} ($\sigma$), \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Morse & \texttt{interactions\_Morse.f95} & $\phi(r)=E_0\bigg\lbrace \Bigl[1-\exp\bigl(-k(r-r_0)\bigr)\Bigr]^2 -1 \biggr\rbrace$ 
& \textbf{E0}, \textbf{k}, \textbf{r0}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

$n$-$m$ & \texttt{interactions\_n-m.f95} & $\displaystyle\phi(r)=\bigl[E_0/(n-m)\bigr]\bigl[m(r_0/r)^n-n(r_0/r)^m\bigr]$
& \textbf{E0}, \textbf{npot} ($n$), \textbf{mpot} ($m$), \textbf{r0}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Yukawa & \texttt{interactions\_Yukawa.f95} & $\phi(r)=A\exp(-kr)/r$ 
& \textbf{A}, \textbf{k}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

\end{longtable}
\end{center}
\end{landscape}


\section{Tabulated pair potential}
\texttt{interactions\_pair\_table.f95} implements a tabulated pair potential $\phi(r)$, defined at regularly spaced values of $r$. 
The format of the \texttt{interactions\_in} file in this case is as follows.
The first line is a comment line. The second line contains \textbf{Nr}, then \textbf{dr}, then \textbf{cutoff}, which are, respectively, the 
number of elements in the table, the separation between points on the `distance grid', and the cut-off distance for the
potential. The next line, and all subsequent lines, contain the \textbf{Nr} values which defines the pair potential:
the $i$th value corresponds to the value of the potential for inter-particle separation $(i-1)dr$, i.e., $\phi((i-1)dr)$. Here is an example
of the first few lines of a \texttt{interactions\_in} file for \texttt{interactions\_pair\_table.f95} (the large values of $\phi$ on
lines 3 and above reflect the fact that the potential is very high for very short separations -- in later lines they fall to `reasonable'
values):
\begin{verbatim}
Lennard-Jones potential: epsilon=0.5; sigma=2; cut-off=5
10001 0.0005 5.0
1.0E100
33554432000000001423400392163144272170713088
8192000000000000347509861367955144572928
63138583586889161214127441051941601280
2000000000000000084841274748035923968
137438953471999997694156990786306048
15414693258517861624542832288071680
2424227711825515114228133912379392
488281250000000020713201842782208
118806384127098045049066032726016
33554431999999990429850791837696
\end{verbatim}
Note that in \texttt{interactions\_pair\_table.f95} the potential is implemented using linear interpolation between tabulated values.
Furthermore, similarly to \texttt{interactions\_EAM.f95}, at initialisation a file \texttt{phi.dat} is created which contains a plot of $\phi(r)$
read from \texttt{interactions\_in}.


\section{Penetrable (including hard) spheres}
\texttt{interactions\_penetrable\_spheres.f95} implements the penetrable spheres model:
\begin{equation}
\phi(r)=
\begin{cases} 
\epsilon & \text{if }r<\sigma \\
0 & \text{if }r>\sigma.
\end{cases}
\end{equation}
The format for \texttt{interactions\_in}, and the implementation of the potential, is similar to the analytical pair potentials 
described earlier in Section \ref{section:pair_potentials}; the order of variables as they should occur in \texttt{interactions\_in} 
is \textbf{epsilon}, \textbf{sigma}, \textbf{list\_cutoff}, then \textbf{list\_size}, where the significance of 
\textbf{list\_cutoff} and \textbf{list\_size} is the same as for the analytical pair potentials.

Hard spheres are realised in the limit $\beta\epsilon\to\infty$, where $\beta=1/(k_BT)$. Thus hard spheres can be modeled by 
setting either $\epsilon$ or $\beta$, or both, to a very high value. We recommend setting $\beta=1$ and $\epsilon=100000$ to realise
hard spheres. In this case $\epsilon$ is not so high that numerical issues occur,
\footnote{The Fortran procedure which determines the move acceptance probability can fail if the system exhibits
unreasonably large energy differences: we found that setting $\beta=1$ and $\epsilon=1\times 10^{100}$ caused moves which should always
be rejected in the hard-sphere system to be occasionally accepted. The source of this erronous behaviour is an overflow, which will
not occur if `reasonable' values for $\beta$ and $\epsilon$ are used.} 
but also not so small that moves which lead to overlapping spheres -- which are always possible unless $\epsilon$ is actually
$\infty$ -- are likely to happen during even a very long simulation.

Note that the order parameter $M$ has a straightforward physical interpretation for penetrable spheres: if the system is
currently in phase 1(2) then $-(+)M/\epsilon$ is the number of overlapping spheres which result from performing a lattice switch from the 
current microstate. This is similar to the definition of $M$ used in the original LSMC papers (Refs. \cite{Bruce_1997,Bruce_2000}).


\section{Other potentials included with \emph{monteswitch}}
Some other \texttt{interactions\_} files are included in the directory \texttt{Interactions}, namely \texttt{interactions\_EC.f95}, 
\texttt{interactions\_EC\_NPT.f95}, \texttt{interactions\_LJ\_hcp\_fcc.f95} and \texttt{interactions\_PAIR\_TEMPLATE.f95}. The last of
these is a template to assist users in creating an \texttt{interactions.f95} file corresponding to a pair potential of their own
design, and will be discussed in more detail in a moment. The other files correspond to potentials which we do not anticipate will
be of any interest to most users; these potentials were used to validate \emph{monteswitch} via test cases described in Chapter
\ref{chapter:tests}. Hence we do not describe them here; interested parties should inspect the files themselves for further information.


\section{User-defined pair potentials}\label{sec:user_defined}
The file \texttt{interactions\_PAIR\_TEMPLATE.f95} is a template which can be used to easily create \texttt{interactions.f95} files for `new'
pair potentials. In fact this template was used to create the files for almost all of the potentials described in Section
\ref{section:pair_potentials}. Instructions are provided in the file regarding how the file should be modified to realise the user's potential
of interest. The resulting implementation of the potential, and the required format of the \texttt{interactions\_in} file, will be the same as described 
in Section \ref{section:pair_potentials}. Regarding the order in which the variables which parametrise the potential are read from 
\texttt{interactions\_in}, the user-defined variables are read first, and then the variables \textbf{cutoff}, \textbf{list\_cutoff}, 
\textbf{list\_size} are read.

Note that one is by no means limited to using \texttt{interactions\_PAIR\_TEMPLATE.f95} to create `analytical' pair potentials. For instance
piecewise pair potentials could be created from \texttt{interactions\_PAIR\_TEMPLATE.f95}, e.g., the soft sphere model:
\begin{equation}
\phi(r)=
\begin{cases} 
\epsilon(\sigma/r)^n & \text{if }r\leq\sigma \\
0 & \text{if }r>\sigma.
\end{cases}
\end{equation}

Note also that \texttt{interactions.f95} is actually a part of the Fortran module \verb|MONTESWITCH_MOD| (located in the file 
\texttt{monteswitch\_mod.f95}) -- it is included in the file via Fortran's \verb|INCLUDE| statement. As such, when choosing variable names
in \texttt{interactions.f95} one should be aware that the module variables of \verb|MONTESWITCH_MOD| are `in scope'.


\section{Guide to implementing more complicated potentials}
To conclude this chapter we describe the procedures in \texttt{interactions.f95} which are used in \emph{monteswitch} (via the module
\texttt{monteswitch\_mod.f95}, with the aim of enabling interested users in writing their own \texttt{interactions.f95} files to implement
more complicated potentials within \emph{monteswitch}. Note that the format of \texttt{interactions.f95} has deliberately allowed for 
flexibility with regards to the potential. Possibilities include boundary conditions other than 3D-periodic, different Hamiltonians
for each phase, and many-body potentials. However recall that \emph{monteswitch} is limited to single-component atomic (i.e., particles
cannot have rotational degrees of freedom).

Note that, as mentioned above \texttt{interactions.f95} is included in \texttt{monteswitch\_mod.f95} via Fortran's \verb|INCLUDE| statement, and hence
all variables in this module are `in scope'. This allows maximal flexibility with regards to the potential; e.g., the potential can vary
with the dimensions of the supercell if one wishes (see \texttt{interactions\_EC\_NPT.f95} in \texttt{Interactions}). The downside is that one
must take a bit more care while naming variables in \texttt{interactions.f95} so not to accidentally refer to a variable in 
\texttt{monteswitch\_mod.f95} when one wishes to refer to a local variable. 

\texttt{interactions.f95} should firstly declare any necessary variables, conforming to the Fortran \verb|INTEGER| and \verb|REAL| kinds defined
in the file \texttt{kinds\_mod.f95}: \verb|REAL| variables should be of kind \verb|rk| and \verb|INTEGER| variables should be of kind \verb|IK|.
After the declarations there should be a \verb|CONTAINS| statement.
The procedures described below must be included in \texttt{interactions.f95}, though of course other procedures are allowed in the file.
Examples of \texttt{interactions.f95} files can be found in the directory \texttt{Interactions}; users wishing to create their own
\texttt{interactions.f95} file may find it useful to examine these files. 
Note that there is no implicit procedure for determining the separation between two particles in \emph{monteswitch}: it is up to the
user to decide how a separation should be calculated. It is for this reason that we mentioned above that \emph{monteswitch} supports non-standard
boundary conditions. However, note that the utility programs may in some cases tacitly assume 3D periodic boundary conditions. 

\subsection{Compulsory procedures in \texttt{interactions.f95}}

\subsubsection{\texttt{SUBROUTINE INITIALISE\_INTERACTIONS(FILENAME)}}
This procedure should open Fortran unit 10, and read 
the variables which are required to initialise the potential from the file \verb|FILENAME|.
In practice the file will be \texttt{interactions\_in}. After reading these variables, the potential should be initialised. This may include
initialisation of, e.g., neighbour lists, or work arrays to speed up calculations. Note that this procedure is called after \texttt{lattices\_in}
and \texttt{params\_in} have been read, and the corresponding variables initialised. Hence by the time \verb|INITIALISE_INTERACTIONS| is called 
variables pertaining to the supercell geometry, i.e. the number of particles, particle positions and the supercell dimensions 
\emph{for each of the two phases} will be initialised, and can be used to initialise the variables in \texttt{interactions.f95} if need be.
\verb|FILENAME| should be of type \verb|CHARACTER(*)|, and \verb|INTENT(IN)|.

\subsubsection{\texttt{SUBROUTINE INITIALISE\_INTERACTIONS(FILENAME)}}
The first required procedure we will describe is \verb|INITIALISE_INTERACTIONS|. This procedure should open Fortran unit 10, and read 
the variables which are required to initialise the potential from the file \verb|FILENAME|.
In practice the file will be \texttt{interactions\_in}. After reading these variables, the potential should be initialised. This may include
initialisation of, e.g., neighbour lists, or work arrays to speed up calculations. Note that this procedure is called after \texttt{lattices\_in}
and \texttt{params\_in} have been read, and the corresponding variables initialised. Hence by the time \verb|INITIALISE_INTERACTIONS| is called 
variables pertaining to the supercell geometry, i.e. the number of particles, particle positions and the supercell dimensions 
\emph{for each of the two phases} will be initialised, and can be used to initialise the variables in \texttt{interactions.f95} if need be.
\verb|FILENAME| should be of type \verb|CHARACTER(*)|, and \verb|INTENT(IN)|.

\subsubsection{\texttt{SUBROUTINE EXPORT\_INTERACTIONS\_STATE(UNIT)}}
This procedure writes the variables in \texttt{interactions.f95} to the specified Fortran unit. The primary purpose of this procedure is checkpointing: 
this procedure is used to output the variables pertaining to the potential interaction variables to the file \texttt{state}, for reading again later
by the procedure \verb|IMPORT_INTERACTIONS_STATE|. Hence the format output by \verb|EXPORT_INTERACTIONS_STATE| and the format read by 
\verb|IMPORT_INTERACTIONS_STATE| must match exactly. \verb|UNIT| should be of type \verb|INTEGER(IK)|, and \verb|INTENT(IN)|.

\subsubsection{\texttt{SUBROUTINE IMPORT\_INTERACTIONS\_STATE(UNIT)}}
Read the variables in \texttt{interactions.f95} from the specified Fortran unit. Complementary to \verb|EXPORT_INTERACTIONS_STATE|; see 
above. \verb|UNIT| should be of type \verb|INTEGER(IK)|, and \verb|INTENT(IN)|.

\subsubsection{\texttt{SUBROUTINE AFTER\_ACCEPTED\_INTERACTIONS()}}
This procedure is called in \texttt{monteswitch\_mod.f95} after a particle or volume move (but not a lattice move) has been accepted. It can be used 
as a means to update variables which require updating if the microstate of the system changes, e.g., neighbour lists. Note that for almost all of
the \texttt{interactions.f95} files included with \emph{monteswitch} (in the \texttt{Interactions} directory) this procedure is unrequired and hence
does nothing.

\subsubsection{\texttt{FUNCTION CALC\_ENERGY\_SCRATCH(LATTICE,LX\_IN,LY\_IN,LZ\_IN,R)}}
This function returns the energy for the supercell corresponding to a given phase (labeled here as \verb|LATTICE|, type \verb|INTEGER(IK)|) for 
an orthorhomic supercell with the specified dimensions (\verb|LX_IN|, \verb|LY_IN| and \verb|LZ_IN|, all of type \verb|REAL(RK)|) and particle 
positions (\verb|R|, type \verb|REAL(RK), DIMENSION(:,:)|). All arguments are of course \verb|INTENT(IN)|. Furthermore in \verb|R| the first dimension
refers to the particle number and the second dimension refers to the Cartesian dimension, e.g. \verb|R(3,2)| is the y-coordinate of particle 3.
The same applies to \verb|R| and \verb|R_NEW| in \verb|CALC_ENERGY_PART_MOVE| below. 

\subsubsection{\texttt{FUNCTION CALC\_ENERGY\_PART\_MOVE(LATTICE,LX,LY,LZ,R,R\_NEW,I)}}
This function returns the energy for the supercell corresponding to a given phase (labeled here as \verb|LATTICE|, type \verb|INTEGER(IK)|) for 
an orthorhomic supercell with the specified dimensions (\verb|LX|, \verb|LY| and \verb|LZ|, all of type \verb|REAL(RK)|), given that particle
number \verb|I| has just been moved: \verb|R_NEW| (type \verb|REAL(RK), DIMENSION(:,:)|) are the positions of the particles after the move
and \verb|R| (type \verb|REAL(RK), DIMENSION(:,:)|) are the positions before the move. All arguments are of course \verb|INTENT(IN)|. 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Utility programs}\label{chapter:utility_programs}
In this chapter we describe the utility programs included in the package, which assist with post-processing of the data and the construction
of input files.

\section{Programs for generating \texttt{lattices\_in} files}
The programs \texttt{lattices\_in\_hcp\_fcc}, \texttt{lattices\_in\_bcc\_fcc} and \texttt{lattices\_in\_bcc\_hcp} generate \texttt{lattices\_in} 
files corresponding to, respectively, hcp--fcc, bcc--fcc and bcc--hcp pairs of phases.
Each program takes four arguments. The first is the density, i.e., the number of atoms per unit volume, of the pair of microstates to
construct. The second, third and fourth arguments are the integers which correspond
to the number of unit cells (described in a moment) which will be tiled in the x-, y- and z-directions respectively to construct the
supercell for each phase. The program outputs the text for the \texttt{lattices\_in} file to stdout. Hence one must redirect the output
to create the required \texttt{lattices\_in} file.
For example, to generate a \texttt{lattices\_in} file for hcp--fcc corresponding to a density of 0.25, consisting
of 2, 3 and 5 unit cells tiled in the z-, y-, and z-directions, the command is (assuming the \texttt{lattices\_in\_hcp\_fcc} executable
is in the current directory)
\begin{verbatim}
$ ./lattices\_in\_hcp\_fcc 0.5 2 3 5 > lattices\_in
\end{verbatim}
Note that the \texttt{lattices\_in} files created by these programs have the species of all particles set to `1'.

What follows is a description of the unit cells for each pair of phases for each program. More specific information regarding the unit
cells can be obtained by invoking the programs with `1' for the second, third and fourth arguments. 

\subsection{\texttt{lattices\_in\_hcp\_fcc}}
The unit cell here contains 12 atoms. The atoms are spread over 6 planes in the z-direction; each plane contains two atoms. The positions
of the atoms corresponds to a stacking sequence for the planes of ABCABC for the fcc unit cell, and  ABABAB for the hcp unit cell. 
Note that the unit cell is far longer in the z-directon than the x- and y-directions. Hence one should normally use more unit cells in 
the x- and y-directions than the z-direction to construct the supercells. In the output of this program lattice 1 corresponds to hcp and
lattice 2 corresponds to fcc.

\subsection{\texttt{lattices\_in\_bcc\_fcc}}
The unit cell here is the conventional 2-atom body-centred tetragonal (bct) unit cell; for the bcc(fcc) lattice the relative dimensions of 
the bct unit cell in each Cartesian direction correspond to the bct representation of the bcc(fcc) lattice. In the output of this program
lattice 1 corresponds to bcc and lattice 2 corresponds to fcc.

\subsection{\texttt{lattices\_in\_bcc\_hcp}}
The unit cell here contains 4 atoms. The bcc unit cell is the 4-atom face-centred tetragonal (fct) corresponding to the fct representation of 
the bcc lattice. The hcp unit cell is the `fct-like' representation of the hcp lattice. In the output of this program
lattice 1 corresponds to bcc and lattice 2 corresponds to hcp.


\section{Post-processing \texttt{state} files: \texttt{monteswitch\_post}}\label{sec:monteswitch_post}
\texttt{monteswitch\_post} is for post-processing a file \texttt{state} generated by \texttt{monteswitch} or \texttt{monteswitch\_mpi}, and can
be used to extract useful information from that file. The \texttt{state} file which the program operates on is that in the current directory.
The command-line arguments determine the task performed by the program, and are as follows.

\subsection{\texttt{-extract\_wf}}
Extract the weight function from \texttt{state} and output it to stdout. In the output the first token on each line is the order parameter, 
and the second is the corresponding value of the weight function.

\subsection{\texttt{-extract\_M\_counts}}
Extract order parameter histograms from \texttt{state} and output them to stdout. In the output the first token on each line is the order 
parameter, the second is the corresponding number of counts for lattice type 1, and the third is the corresponding number of counts for 
lattice type 2. 

\subsection{\texttt{-extract\_pos}}
Extract the current positions of the particles, and output them to stdout. In the output the first, second and third tokens on each line 
are the x-, y- and z-coordinates respectively for a particle. 

\subsection{\texttt{-extract\_R\_1}}
Extract the current positions of the lattice sites for lattice type 1, and output them to stdout. In the output the first, second and third 
tokens on each line are the x-, y- and z-coordinates respectively for a particle. 

\subsection{\texttt{-extract\_R\_2}}
Extract the current positions of the lattice sites for lattice type 2, and output them to stdout. In the output the first, second and third 
tokens on each line are the x-, y- and z-coordinates respectively for a particle.

\subsection{\texttt{-extract\_u}}
Extract the displacements of the particles, and output them to stdout. In the output the first, second and third tokens on each line are 
the x-, y- and z-displacements respectively for a particle. 

\subsection{\texttt{-calc\_rad\_dist bins}}
Calculate the radial distribution function, based on the current microstate, and output it to stdout. In the output, each line corresponds 
to a distance, which is the first token, and the second token contains the average number of particles at this distance from a particle. The 
output is like a histogram, with each line corresponding to a bin, the first token corresponding to the minimum of the range covered by the 
bin, and the second token corresponding to the number of counts for that bin. The range of the bin is inclusive at its minimum, and 
exclusive at its maximum. The upper distance considered for the radial distribution function is the lowest of $L_x/2$, $L_y/2$ and $L_z/2$,
where $L_x$ denotes the length of the current supercell in the x-direction, and similarly for $L_y$ and $L_z$; and the number of bins for 
the histogram is specified in the second argument \texttt{bins}. Note that the upper distance corresponds to the 'limit of periodicity' for the system. 

\subsection{\texttt{-merge\_trans} \texttt{state\_in\_1}  \texttt{state\_in\_2} \texttt{state\_out}}
Combine the \textbf{trans} matrices from the files \texttt{state\_in\_1} and \texttt{state\_in\_2}, and store the result in the 
file \texttt{state\_out}, where all variables in \texttt{state\_out} other than the matrix \textbf{trans} are inherited from 
\texttt{state\_in\_1}. Note that \textbf{M\_grid} must be the same for both input files (in which case the matrices \textbf{trans} for
each are of the same size). This argument can be used for pooling the results of multiple simulations which utilise the same underlying
`order parameter grid' \textbf{M\_grid}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Worked example}\label{chapter:example}
We now provide a worked example to elucidate how the \emph{monteswitch} package as a whole can be used to solve a `real' problem.
Specifically, we use \emph{monteswitch} to calculate the Gibbs free energy difference $\Delta G$ between the bcc and hcp
phases of Zr, modeled using the EAM potential of Ref. \cite{Mendelev_2007}, at 1234K and 0 pressure. 
In our calculation we use artificial dynamics to quickly determine a reasonable weight function, and \texttt{monteswitch\_mpi} to
parallelise the calculations. Below we go through the entire procedure we used to obtain the free energy
difference. Of course, the procedure here will surely not be applicable to all problems, though it provides a good starting point. 
For this reason we try to anticipate problems that the user may encounter more generally, and provide remarks accordingly.

The example can be found in the \texttt{Examples/EAM\_Zr\_bcc\_hcp} directory of the \emph{monteswitch} package. Within 
\texttt{Examples/EAM\_Zr\_bcc\_hcp} there are a number of subdirectories which correspond to different simulations, all of which are 
necessary to obtain the free energy difference. The subdirectories are \texttt{bcc\_preliminary}, \texttt{hcp\_preliminary},
\texttt{weight\_function\_generation}, \texttt{weight\_function\_verification} and \texttt{production\_simulation}. We will describe the
purpose of the corresponding simulations in a moment. For now we wish to elaborate upon the contents of the subdirectories. Firstly, each 
subdirectory contains the input and output files for the corresponding simulation. Recall that the input files for `new' 
\texttt{monteswitch} and \texttt{monteswitch\_mpi} simulations (i.e., using the \texttt{-new} argument)
are \texttt{params\_in}, \texttt{interactions\_in} and \texttt{lattices\_in}, and that the output files are \texttt{state} and \texttt{data} 
for serial simulations (using the \texttt{monteswitch} program), and \texttt{data\_0}, \texttt{state\_0}, \texttt{data\_1}, \texttt{state\_1},
\texttt{data\_2}, \texttt{state\_2}, etc. and \texttt{state} for MPI simulations (using the \texttt{monteswitch\_mpi} program). Regarding the input
files, those for new simulations differ only in the \texttt{params\_in} files: the \texttt{interactions\_in} and \texttt{lattices\_in} files,
which define, respectively, the interatomic potential, and the phases and lattice switch, for a simulation, 
are the same for all simulations. Hence we have annotated the \texttt{params\_in} file corresponding to each simulation
to highlight the important variable choices. Recall that for resumed simulations (which use the \texttt{-resume} or \texttt{-reset} arguments)
an existing \texttt{state} file is the input file. To distinguish the input input state file from the state file output
by such simulations, we name the input file \texttt{state\_start}. To restate, in directories corresponding to resumed simulations,
\texttt{state\_start} is the input state file for the simulation, while \texttt{state} is the output state file.
Recall also that \texttt{monteswitch} and \texttt{monteswitch\_mpi} output information to stdout. 
In each subdirectory the file \texttt{stdout} contains a copy of the output to stdout -- if there is any. Finally, the 
subdirectories may contain other files (\texttt{.dat} files) which correspond to data obtained from post-processing. These files,
and how they were created, will be described.


\section{The \texttt{interactions\_in} and \texttt{lattices\_in} files}
Before performing any simulations, we must first construct the input files \texttt{interactions\_in} and \texttt{lattices\_in}
which specify, respectively, the interatomic potential, and pair of supercells we will use in all simulations. 
For the EAM version of monteswitch (which uses \texttt{interactions\_EAM.f95} as \texttt{interactions.f95} - which is the case by
default) the \texttt{interactions\_in} file must be a `setfl'-format description of the EAM potential of interest.
We wish to use the aforementioned Zr potential. It can be seen by inspecting the \texttt{interactions\_in} in the main
directory for the worked example that it (and the \texttt{interactions\_in} files in all subdirectories - they 
are all identical) corresponds to a `setfl'-format description of the aforementioned Zr potential - as required.

Consider now the \texttt{lattices\_in} file. Recall that this contains specifications of the supercells for both phases;
the atomic positions specified in \texttt{lattices\_in} define the crystal lattices which define each phase.
Given that we are considering the bcc and hcp phases, we can use the \texttt{lattices\_in\_bcc\_hcp} program to generate
a \texttt{lattices\_in} file, as opposed to creating it from scratch. We know the density of both phases is about
0.043\AA$^{-3}$ at the temperature under consideration. Hence we use this as the first argument to \texttt{lattices\_in\_bcc\_hcp}.
We generated  \texttt{lattices\_in} using the command
\begin{verbatim}
$ ../../lattices_in_bcc_hcp 0.042710367 4 6 4 > lattices_in
\end{verbatim}
Recall that the second, third and fourth arguments to \texttt{lattices\_in\_bcc\_hcp} give how many unit cells to tile in the
x-, y- and z-directions. As can be seen from inspection of the resulting \texttt{lattices\_in} file, a copy of which can be found in
the current directory, the above command yields a supercell of reasonable size (384 atoms), and supercell
dimensions which are greater than twice the cut-off of the EAM potential (which is 7.6\AA -- the last value on the second
line of \texttt{interactions\_in}) as is required to avoid finite size effects associated with `missing' neighbours.

\section{Preliminary simulations}
Now we turn to simulations. Before performing lattice-switch Monte Carlo simulations, it is necessary to first perform
preliminary conventional Monte Carlo simulations for each phase, bcc and hcp. The directories \texttt{bcc\_preliminary}
and \texttt{hcp\_preliminary} correspond to these simulations. The aim of these simulations is to determine:
\begin{enumerate}
\item the appropriate Monte Carlo maximum particle and volume move sizes;
\item an estimate for the equilibration time;
\item the appropriate range of order parameter to use in subsequent simulations.
\end{enumerate}

\subsection{\texttt{params\_in} files}
The salient features of the \texttt{params\_in} files for these simulations are as follows:
\begin{itemize}
\item \textbf{init\_lattice} = 1 for the bcc simulation and 2 for the hcp simulation, since in the \textbf{lattices\_in} file phase 1 corresponds to
  bcc and phase 2 corresponds to hcp.
\item \textbf{M\_grid\_min} and \textbf{M\_grid\_max} are set to extremely low and extremely high values respectively. This is necessary because
  the simulation automatically constrains the system such that its order parameter lies between \textbf{M\_grid\_min} and \textbf{M\_grid\_max};
  setting them to very low and high values respectively allows the system to have total freedom in order-parameter space --
  which is what we desire for a single phase conventional Monte Carlo simulation. This should always be done if one wishes
  to perform a conventional Monte Carlo simulation using monteswitch.
\item \textbf{enable\_multicanonical} and \textbf{enable\_lattice\_moves} are set to \texttt{F} for a conventional Monte Carlo simulation. Note that by
  disabling lattice switch moves the system is `locked in' to the phase in which it is initialised.
\item \textbf{enable\_vol\_moves} is set to \texttt{T}, in which case the simulation corresponds to the NPT ensemble. 
\item \textbf{part\_step} and \textbf{vol\_step} are the maximum particle and volume move sizes. One of the aims of the preliminary simulations is
  to determine a reasonable value for these variables. The values in the \texttt{params\_in} files are 0.3 and 0.03 respectively. These
  were obtained by trial and error. To elaborate, we started the simulation with a guess for these values, and examined the 
  information output to stdout as the simulation was running, specifically the total and accepted number of particle and 
  volume moves. If \textbf{part\_step} or \textbf{vol\_step} are too high then the number of accepted particle or volume moves will be very low 
  relative to the total number of moves; if they are too low then the number of accepted particle or volume moves will be close
  to the total number of moves. If either is the case we simply stopped the simulation, and restarted with a new informed guess for
  \textbf{part\_step} or \textbf{vol\_step}. The whole process does not take very long since it becomes obvious very quickly whether the acceptance
  rates are reasonable. In principle of course one could automate the process of determining the appropriate values of \textbf{part\_step}
  and \textbf{vol\_step}.
\item \textbf{stop\_sweeps} is set to 1000; the simulation will consist of 1000 sweeps, which is very short, though sufficient (in this system, though
  not in general) to obtain an estimate of 1), 2) and 3) described above. 
\item \textbf{output\_file\_period} is set to 1, which means information is output to the \texttt{data} file every sweep. Normally outputing information
  so frequently might be considered excessive, but we need such high resolution information regarding the time evolution of the simulation to 
  determine the equilibration time.
\item \textbf{output\_file\_V}, \textbf{output\_file\_E} and \textbf{output\_file\_V} are set to \texttt{T}: the system's volume, energy and order parameter 
  are periodically output 
  to the \texttt{data} file. We will use the first three quantities to determine the equilibration time; we will examine how the order parameter
  varies with time to obtain an idea of the range of order parameters exhibited by each phase at equilibrium, which in turn will inform the
  values of \textbf{M\_grid\_min} and \textbf{M\_grid\_max} to be used in subsequent simulations.
\item \textbf{output\_stdout\_period} is set to 10; information is output to stdout every 10 sweeps. The information we are interested in while the simulation
  is running, for reasons mentioned above, is the acceptance rates of the particle and volume moves for the chosen values of \textbf{part\_step} and 
  \textbf{vol\_step}.
  Accordingly we set \textbf{output\_stdout\_moves\_part}, \textbf{output\_stdout\_accepted\_moves\_part}, \textbf{output\_stdout\_moves\_vol} and 
  \textbf{output\_moves\_accepted\_moves\_vol} to \texttt{T}; with the corresponding variables one can calculate the acceptance rate for the chosen
  \textbf{part\_step} and \textbf{vol\_step} (acceptance rate = number of
  accepted moves / total moves)
\item Finally, \textbf{enable\_barriers} is set to \texttt{F}; otherwise artificial dynamics will be used - which we don't want.
\end{itemize}


\subsection{Running the simulations}
The simulation is run using the \texttt{-new} argument. Given that the simulation is short, it is unnecessary to use MPI: the \texttt{monteswitch} executable
should be used. The following command invokes the executable (from within the \texttt{Examples/EAM\_Zr\_bcc\_hcp/bcc\_preliminary} or 
\texttt{Examples/EAM\_Zr\_hcp\_preliminary} directories within the \texttt{monteswitch} package itself):
\begin{verbatim}
$ ../../../monteswitch -new
\end{verbatim}

\subsection{Estimating the (one-phase canonical) equilibration time}
One can post-process the file \texttt{data} to create a plot of the system's energy and volume vs. number of sweeps (i.e., simulation `time'):
\begin{verbatim}
$ grep 'E:' data | awk '{print $2,$3}' > E_vs_t.dat
$ grep 'V:' data | awk '{print $2,$3}' > V_vs_t.dat
\end{verbatim}
Plotting the files \texttt{E\_vs\_t.dat} and \texttt{V\_vs\_t.dat} reveals that the system equilibrates quickly: within 200 sweeps.

\subsection{Extracting the appropriate order parameter range}
One can create a plot of the order parameter $M$ vs. number of sweeps similarly to above:
\begin{verbatim}
$ grep 'M:' data | awk '{print $2,$3}' > M_vs_t.dat
\end{verbatim}
Plotting this file immediately gives an idea of the range of order parameters exhibitted at equilibrium for each phase. We see that for
bcc the exhibitted range is -62 to 20, and for hcp the range is 14 to 32. Hence the appropriate range of order parameters which encompasses
both phases is -62 to 32. We will use this in subsequent simulations.

Note that the system is constrained to be within the chosen order parameter range. It is therefore possible that imposing this artificial
constraint on the system could invalidate the results of the simulation. To avoid this, one should choose the maximum and minimum of the order
parameter range to be values which are `sufficiently unlikely to be realised at equilibrium so not to affect the results'. At this point it is
not clear whether this is the case for our chosen range. Fortunately we can check this \emph{a postiori} using the results of later simulations 
(see Section \ref{section:double_check} below). On the other hand the maximum and minimum should not be too far from what is likely to be 
encountered at equilibrium. 
Choosing too large an order parameter range lowers the efficiency of the forthcoming multicanonical simulation, or worse, it forces the system to 
visit `unnatural' states in the multicanonical system, causing the system to melt.

\section{Weight function generation simulations}\label{sec:example_generation}
The preliminary simulations have provided us with appropriate values for the maximum particle and volume move sizes, an estimate for
the equilibration time, and the range of order parameters which encompass both phases at equilibrium. With this information we can
now proceed to lattice-switch Monte Carlo simulations. The first such simulation is to generate the weight function. The directory
\texttt{weight\_function\_generation} corresponds to this simulation. We use the mobile barrier method. Furthermore, we use \texttt{monteswitch\_mpi}
to perform a parallelised calculation. Specifically we used 4 threads on a 4-core desktop machine. The following command was used
to invoke the simulation (from within the \texttt{Examples/weight\_function\_generation} within the \emph{monteswitch} package itself):
\begin{verbatim}
$ nohup mpiexec -n 4 ../../../monteswitch_mpi -new -explicit < 
/dev/null &
\end{verbatim}
This command is, of course, specific to our computing platform; one would have to ascertain the analogous command for other platforms. Note, however,
that we have used the \texttt{-explicit} argument to \texttt{monteswitch\_mpi}, which is necessary for storing the \texttt{data} and \texttt{state} 
files pertaining to each MPI thread.

\subsection{The \texttt{params\_in} file}
The salient features of the \texttt{params\_in} files for this simulation is as follows:
\begin{itemize}
\item \textbf{init\_lattice} is set to 1, which means the simulation is initialised in the bcc phase. However, the choice of initial phase is 
  unimportant since both phases will be explored during the simulation.
\item \textbf{M\_grid\_size}, \textbf{M\_grid\_min} and \textbf{M\_grid\_max} define the macrostates. We set \textbf{M\_grid\_min} and \textbf{M\_grid\_max}
  to -62 and 32, which corresponds to the
  range determined in our preliminary simulations. Furthermore, we set \textbf{M\_grid\_size} to 100: the order parameter range will be divided into
  100 macrostates. The choice of 100 is based upon our previous experience of LSMC simulations (and may not be appropriate for all systems). 
  If the number of macrostates is too high, then the weight function will take longer to generate. On the other hand if the number of macrostates
  is too low, then the system is unable to explore the whole range of order-parameter space in a reasonable simulation time -- regardless
  of the weight function. This occurs because the order-parameter grid is too coarse to be able to guide the system over any free energy barriers.
  Often it will be more efficient to use more macrostates (see below).
\item \textbf{enable\_multicanonical} is set to \texttt{T}, which means that the continually updated weight function is used to bias the dynamics of the system.
  This is actually unnecessary here since we elect to use mobile barriers to guide the system through order-parameter space. The method would
  work well with canonical sampling. However, using multicanonical sampling in theory should slightly help the system transition between 
  macrostates with a high free energy difference between them.
\item \textbf{enable\_lattice\_moves} is set to \texttt{T}: the system can explore both phases using lattice moves.
\item \textbf{part\_step} and \textbf{vol\_step} are informed by our preliminary simulations
\item \textbf{stop\_sweeps} is set to 160000. Note that since we are using 4 MPI threads, each thread will perform 40000 sweeps.
\item \textbf{output\_file\_period} is set to 250. We do this mainly to avoid creating massive output files. At this point we do not need to know 
  information regarding the time-evolution of the system during the simulation on the scale of less than 250 sweeps -- given that the equilibration time is
  $\lesssim 100$ sweeps. Note that since we are using \texttt{monteswitch\_mpi} there is one output file for each thread; within each thread $n$, every 
  250 sweeps information is output to the file \texttt{data\_n}.
\item \textbf{output\_stdout\_period} is set to -1, which suppresses all output to stdout. This is normally desirable for MPI simulations, since each thread 
  will itself output to stdout every \textbf{output\_stdout\_period} sweeps, which can result in an overwhelming amount of (and confusing) information to 
  stdout. 
  Furthermore, for long simulations we have no interest in watching the simulation variables during the running of the simulation -- which is the primary
  purpose of the simulation outputting information to stdout. Instead we let the simulation run, say, overnight, and extract the information we require
  from the \texttt{data} and \texttt{state} files once it is completed -- no information is output to stdout which cannot be obtained from these files.
\item \textbf{checkpoint\_period} is set to 2000; every 2000 sweeps the state of each MPI thread $n$ is output to the file \texttt{state\_n}.
\item \textbf{update\_eta} is set to \texttt{T}, which means that the simulation periodically updates/generates the weight function
\item \textbf{update\_eta\_sweeps} is set to 2000; we update the weight function (in this case using the transition matrix method, see below) every 2000 
  sweeps.
\item \textbf{update\_eta\_method} is set to \verb|"shooting"|, which means that the weight function is determined from the transition matrix via the 
  shooting method. This obviously requires the transition collection matrix to be updated during the simulation. 
  Accordingly we set \textbf{update\_trans} to \texttt{T}, otherwise
  the transition matrix is not updated during the simulation and updating the weight function using the shooting method will not work.
\item \textbf{enable\_barriers} is set to \texttt{T} since we wish to use artificial dynamics to force the system to quickly explore the whole of
  order-parameter space.
  Specifically, we elect to have the system sweep through the macrostates sequentially, proceeding first towards macrostate 1, then from there to
  macrostate 100, thenback to macrostate 1, etc. Accordingly we set \textbf{barrier\_dynamics} to \verb|"pong\_down"|.
\item \textbf{lock\_moves} controls how long the system is locked into each macrostate by the macrostate barriers, before the `next' macrostate is 
  opened to the
  system. This should be long enough that the system has enough time to equilibrate within the macrostate, but not so long that the system never proceeds
  to explore all macrostates during the simulation. Our choice of 38400 (=100 sweeps) seems to do the job. Note that while the equilibration time in our 
  preliminary simulations was ~100 sweeps, the time to equilibrate \emph{within one macrostate} is expected to be far shorter. Furthermore, the time spent in
  each macrostate if macrostate barriers are enabled will be longer than \textbf{lock\_moves}: \textbf{lock\_moves} is the number of moves before a 
  new macrostate becomes
  available to the system -- the system still must move into that new macrostate from the `old' macrostate by its own accord. As expected, it takes
  longer for the system to move from old macrostates into new macrostates if the free energy difference difference between the macrostates is high.
\end{itemize}

\subsection{Results}
At the completion of the simulation the file \texttt{state} (not \texttt{state\_0}, \texttt{state\_1}, \texttt{state\_2} or \texttt{state\_3}) 
contains the final results of the simulation --
pooled from all 4 MPI threads. We are obviously interested in the weight function. This can be obtained from the \texttt{state} file using 
\texttt{monteswitch\_post}.
After the following command, \texttt{wf.dat} contains the weight function vs. order parameter:
\begin{verbatim}
$ ../../../monteswitch_post -extract_wf > wf.dat
\end{verbatim}
Plotting the file \texttt{wf.dat} reveals a smooth curve with two minima separated by a high peak near 0. This is the perfect form for a weight function. If the
curve were not smooth, or was constant for large regions of order-parameter space, then it is probable that the weight function has not properly been
generated. This is perhaps an indication that more time is needed to generate a reasonable weight function. One possible solution is to continue
the simulation with \texttt{monteswitch\_mpi} using the \texttt{-resume} flag, e.g.
\begin{verbatim}
$ nohup mpiexec -n 4 ../../../monteswitch_mpi -resume -explicit <
/dev/null &
\end{verbatim}

Of course, just because the weight function has the aforementioned `perfect form' does not guarantee that it is very good. The ideal weight function
leads to the whole considered range of order-parameter space being sampled uniformly. A weight function with the `perfect form' could easily lead to
certain regions of order-parameter space being significantly over- or under-sampled. In principle this is not a problem because the final results -- given
a long enough production simulation -- do not depend on the weight function used. However the quality of the weight function affects how efficiently 
phase space is explored in the production simulation. Using a weight function of high quality samples order-parameter space almost uniformly, resulting
in many accepted lattice switches, and both phases being explored over short timescales. On the other hand if a lower quality weight function is used the
system will spend more time in certain regions of order-parameter space than others, and the time between lattice-switches will be less. Hence it is prudent
to perform a short simulation using the weight function to verify that it is of good quality.

\subsection{Double-checking the chosen order parameter range}\label{section:double_check}
The ideal weight function is related to the canonical macrostate probability distribution via Eqn. \eqref{ideal_wf}. Hence one can obtain a probability
distribution from the weight function. Of course, this will only be the `real' probability distribution if the weight function is ideal, which it
will not be exactly after our weight function simulation. Nevertheless we can obtain an \emph{approximate} probability distribution from the weight
function from our simulation. This is useful for double-checking that our chosen range of order parameters to consider is appropriate. We use the
following command to obtain the probability distribution from the weight function, and output it to the file \texttt{prob.dat}:
\begin{verbatim}
$ awk 'FNR==NR {sum=sum+exp(-$2); next} {print $1,exp(-$2)/sum}'
wf.dat > prob.dat
\end{verbatim}
Examining \texttt{prob.dat}, we see two peaks in the probability distribution in order-parameter space, each corresponding to one phase. The order parameter
range is suitable only if the probability distribution is effectively zero at the maximum and minimum order parameters considered. If this is not the
case, then our constraint on the order parameter range results in some states which are significantly likely at equilibrium being `cut out' of the
calculation. As can be seen from \texttt{prob.dat}, the probability distribution decays to zero within the chosen range as required. If this were not the
case then we would have to re-run the weight function generation simulation using a larger order parameter range.

\subsection{Estimating $\Delta G$ from the weight function}
With the macrostate probabilty distribution one can in fact obtain an estimate of the free energy difference between the phases. Recall that the
Helmholtz free energy difference $\Delta F$ is related to the time spent in each phase via Eqn. \eqref{DeltaF_stat_mech}. 
An analogous equation can be derived for $\Delta G$ in the NPT ensemble:
\begin{equation}\label{DeltaG_stat_mech}
\Delta F=\beta^{-1}\ln\biggl(\frac{t_2}{t_1}\biggr),
\end{equation}
where recall that $p_2/p_1$ is equal to $t_2/t_1$, and $t_1$ and $t_2$ are the total canonical time the system spends in phases 1 and 2.
The time spent in each phase can be deduced by
integrating the aforementioned peaks in the macrostate probability distribution. The peak for negative order parameters corresponds
to phase 1, and the peak in the positive region corresponds to phase 2: recall our earlier observations that phase 1 (bcc) at equilibrium corresponded to
a range of order parameters of -62 to 20, while phase 2 (hcp) corresponded to a range of 14 to 32. 
Hence the time spent in phase 1(2) is proportional to the area under the peak in the negative(positive) region. With this in mind the following command 
applies Eqn. \eqref{DeltaG_stat_mech} to obtain the free energy difference from the weight function:
\begin{verbatim}
$ awk '{if($1<0){sum1=sum1+$2}; if($1>0){sum2=sum2+$2}} END{print
-log(sum1/sum2)/9.403 }'
\end{verbatim}
Recall that 9.403 is the $\beta$ we are considering. The analogous intensive value is obtained by dividing by the number of atoms in the system (384):
\begin{verbatim}
$ awk '{if($1<0){sum1=sum1+$2}; if($1>0){sum2=sum2+$2}} END{print
-log(sum1/sum2)/(9.403*384) }'
\end{verbatim}
In the above commands we have assumed that macrostates with order parameters less than 0 `belong' to phase 1, and those with order parameters greater
than zero belong to phase 2. 0 seems a sensible choice of `cut-off' between the two peaks; note that the exact choice of cut-off doesn't really matter
since the probability distribution is essentially 0 near 0 order parameter.

We emphasise that the method just described provides only a crude estimate of $\Delta G$. One should not rely upon this approach for accurate results; however
it could be used to examine a wide range of, say, temperatures to quickly deduce the approximate position of the transition temperature if it is not known
from the outset. Note that, unlike our forthcoming production simulation, this method does not provide an uncertainty for $\Delta G$. 


\subsection{Using other weight function generation methods}
In the above example we used the transition-matrix method in conjunction with artificial dynamics to generate the weight function. This method gives a 
reasonable weight function very quickly; however, \emph{monteswitch} supports other methods for generating weight functions. These were described in 
Section \ref{sec:weight_generation}, namely the visited states method, and the transition-matrix method in conjunction with \emph{natural} dynamics.
The values for the control variables required to implement each of the aforementioned methods within \emph{monteswitch} are shown in Table 
\ref{table:wf_gen_variables}. Recall that for the transition-matrix method with artificial dynamics there are two possibilities: evolving the
macrostate barriers randomly or systematically.
Guidelines are also provided in the table regarding values for \textbf{update\_eta\_sweeps} and
\textbf{lock\_moves} for each method. The reasoning behind these values is as follows. 
For the visited states method, \textbf{update\_eta\_sweeps} corresponds to the block size mentioned in
Section \ref{sec:visited_states}. This should be long enough such that a block is representative of a `long' multicanonical simulation with the 
current weight function. Furthermore, the closer to the ideal weight function one wishes to get, the longer the blocks should be.
For the transition matrix method, if multicanonical sampling is used, then one may as well update the weight function `continuously'. In this case
the weight function used always reflects all the information gathered so far during the weight function generation simulation, thus enabling the
system to explore order parameter space as widely as possible in as short a simulation time as possible. Regarding the choice of
\textbf{lock\_moves}, see the discussion in Section \ref{sec:example_generation}.

\begin{landscape}
\begin{table}\label{table:wf_gen_variables}
\begin{center}
\begin{tabular}{l p{4cm} p{2cm} p{6cm}}
Control variable                   & VS                & TM-ND                & TM-AD \\
\hline 
\textbf{enable\_multicanonical}    & \texttt{T}        &   \texttt{T}         &  \texttt{F} or \texttt{T}   \\
\textbf{update\_eta}               & \texttt{T}        &   \texttt{T}         &  \texttt{T}                 \\
\textbf{update\_eta\_sweeps}       & $\gg$ multicanonical equilibration time (in sweeps)  & $\sim 1$ &   $\sim 1$ if \textbf{enable\_multicanonical}=\texttt{T}; 
   $\leq$ \texttt{stop\_sweeps} if \textbf{enable\_multicanonical}=\texttt{F} \\
\textbf{update\_trans}             & N/A               &   \texttt{T}         &  \texttt{T}                 \\
\textbf{update\_eta\_method}       & \texttt{VS}       &   \texttt{shooting}  &  \texttt{shooting}     \\
\textbf{enable\_barriers}          & \texttt{F}        &   \texttt{F}         &  \texttt{T}                 \\
\textbf{barrier\_dynamics}         & N/A               &   N/A                &  \texttt{random} for random macrostate barrier evolution;
    \texttt{pong\_up} or \texttt{pong\_down} for systematic evolution  \\
\textbf{lock\_moves}               & N/A               &   N/A                &  $\gtrsim$ time to equilibrate \emph{within a macrostate} (in moves) \\
\end{tabular}
\end{center}
\caption{Values of control variables in \texttt{params\_in} or \texttt{state} required to implement various weight function generation methods.
`VS' refers to the visited states method; `TM-D' refers to the transition state method with natural dynamics; `TM-AD' refers to the
transition state method with artificial dynamics. (See Section 
\ref{sec:weight_generation} for descriptions of these methods). Furthermore, `N/A' signifies that the control variable is not used in the
method, and hence its value does not matter.}
\end{table}
\end{landscape}


\section{Weight function verification simulation}
Assuming that we have a good weight function, one thing remains which is useful to know before we perform our production simulation: the correlation time 
for the multicanonical simulation using this weight function (and the chosen maximum particle and volume move step sizes)
\footnote{Presumably one could make the multicanonical simulation more efficient by optimising the maximum particle and volume move step sizes used in the 
multicanonical simulation, and not simply using the same values as for the canonical simulation. We have never done this, though it is worth investigating.}
Recall that we obtained an estimate for the equilibration time earlier; however, this pertained only to a one-phase simulation,
in a canonical ensemble. As we will see in a moment, the equilibration times in a two-phase lattice switch multicanonical simulation are far longer. 
We need to know this equilibration time because it determines how large the blocks should be in block analysis for determining equilibrium quantities -- 
in particular for the free energy difference. To determine this we perform a short simulation, using the weight function. This simulation also acts to
verify that the weight function is indeed sensible, i.e., that it leads to the entire range of order-parameter space being explored approximately 
uniformly as expected.

The directory \texttt{weight\_function\_verification} corresponds to the weight function verification simulation.
Recall that we can `resume' a simulation whose variables are stored in the \texttt{state} file by invoking \texttt{monteswitch} with the 
\texttt{-resume} argument. Furthermore
we can resume a simulation from \texttt{state} but with all counter variables reset to zero by invoking the \texttt{-reset} argument. With this in mind, we
use the \texttt{state} file from our previous simulation as a starting point. This file contains the weight function we wish to verify. We will modify this
file to suit our needs, and then run the simulation using the command
\begin{verbatim}
$ ../../../monteswitch -reset
\end{verbatim}
Note that the file \texttt{state\_start} in the directory \texttt{weight\_function\_verification} contains the \texttt{state} file from the directory 
\texttt{weight\_function\_generation}
after it has been modified for the weight function verification simulation; and the file \texttt{state} in the directory \texttt{weight\_function\_verification}
corresponds to the output of the weight function verification simulation.

\subsection{Creating the input \texttt{state} file}
The modifications to the state file can be seen before the weight function verification simulation is run can be seen by invoking the following command
in the weight\_function\_verification directory:
\begin{verbatim}
$ diff state_in ../weight_function_generation/state
\end{verbatim}
The key changes are as follows:
\begin{itemize}
\item We have changed \textbf{stop\_sweeps} to be 10000, which corresponds to a short simulation.
\item We have set \textbf{update\_eta} to \texttt{false}, so that the weight function is fixed throughout the simulation.
\item We have set \textbf{enable\_barriers} to \texttt{F}, since we want `natural' dynamics for the weight function verification simulation.
\item We have set \textbf{output\_file\_period} to 10 so we have high-resolution information about how order-parameter space is explored.
\item We have set \textbf{output\_stdout\_period} to 10 so we can keep track of the progress of the simulation.
\end{itemize}

\subsection{Results}
After the simulation is complete, as before, we can use \texttt{data} to generate a plot of the order parameter vs. time in the simulation using the
following command:
\begin{verbatim}
$ grep 'M:' data | awk '{print $2,$3}' > M_vs_t.dat
\end{verbatim}
From this we see that the entire range of order-parameter space (-62 to 32) was explored within the simulation. Note that, having realised that the
10000 sweep simulation was too perhaps short, we ran the simulation for another 10000 sweeps by using the command
\begin{verbatim}
$ ../../../monteswitch -resume
\end{verbatim}
Hence the output files \texttt{state} and \texttt{data}, and \texttt{M\_vs\_t.dat} created by the above command correspond to after 20000 sweeps, not 10000 
sweeps; a copy of the 
output \texttt{state} file after the first 10000 sweep simulation can be found in the file \texttt{state\_after\_10000\_sweeps}.

Plotting \texttt{M\_vs\_t.dat} reveals that the simulation explores the entire range of order-parameter space (-62 to 32) within 20000 sweeps. Note that this
in practice means that both phases are explored within 20000 sweeps, since high order parameters correspond to phase 2 and low order parameters correspond
to phase 1 (see above). Hence the correlation time -- which in this case involves both phases being explored -- is ~10000 sweeps. The 
block size we use in the
forthcoming production simulation must therefore be greater than this. Note that after the production run one can retrospectively check that the
block size was appropriate. We will do this later. Furthermore, one can use the `observations' in the \texttt{data} files output by the production simulation to
analyse the data -- once the production simulation is complete -- for a variety of block sizes, though software to do this is not currently included in
\emph{monteswitch}.

It is instructive to plot of how often each macrostate was visited during the weight function verification simulation. \texttt{monteswitch\_post}
provides an easy way of extracting this information; the following command creates a file \texttt{counts.dat} which is a plot of macrostate index vs. the
number of times the  macrostate was visited during the entire simulation:
\begin{verbatim}
$ ../../../monteswitch_post -extract_M_counts | awk '{print 
NR,$2+$3}' > macro_vs_counts.dat
\end{verbatim}
From this file we see that all macrostates are visited a reasonable number of times during the simulation. While it is far from the case that the
histogram is flat -- which an ideal weight function would yield -- it is sufficiently flat for our purposes: for our purposes it is acceptable that
all macrostates are visited uniformly to within, say, half an order of magnitude. In fact, we would in fact be very lucky to get a flat histogram
even with the ideal weight function, given that the simulation is so short: it is of the order of the correlation time, which is nowhere near long
enough to gather sufficient statistics.


\section{Production simulation}
We are now ready to perform the production simulation. The corresponding directory is \texttt{production\_simulation}.
As with the weight function simulation, we use the \texttt{state} file output from the weight function generation simulation as the starting point
for the production simulation. We will modify this file to suit our needs, and then run the simulation, using four MPI threads with \texttt{monteswitch\_mpi},
using the command
\begin{verbatim}
$ nohup mpiexec -n 4 ../../../monteswitch_mpi -reset -explicit <
/dev/null &
\end{verbatim}
Note that again we have used the \texttt{-reset} flag to reset the counter variables at initialisation, and that we have also used the \texttt{-explicit}
flag to keep the data from all threads.

\subsection{Creating the input \texttt{state} file}
The modifications to the state file can be seen before the weight function verification simulation is run can be seen by invoking the following command
in the \texttt{weight\_function\_verification} directory:
\begin{verbatim}
$ diff state_start ../weight_function_generation/state
\end{verbatim}
The key changes are as follows:
\begin{itemize}
\item We have changed \textbf{stop\_sweeps} to be 700000, which corresponds to 175000 sweeps to be performed for each MPI thread.
\item We have set \textbf{equil\_sweeps} to 20000, which is larger than the correlation time we determined for the multicanonical simulation using our 
weight function.
\item We have set \textbf{update\_eta} to \texttt{F}, so that the weight function is fixed throughout the simulation.
\item We have set \textbf{enable\_barriers} to \texttt{F}, since we want 'natural' dynamics for the production simulation.
\item \textbf{calc\_equil\_properties} is set to \texttt{T}. This is required for the simulation to calculate equilibrium quantities (the enthalpy, volume and 
mean-squared displacements of each particle) and their uncertainties using block analysis.
\item \textbf{block\_sweeps}, the number of sweeps which constitute a block in the block analysis is set to 155000, which is far larger than the 
correlation time of
  ~10000 sweeps determined earlier. Note that, since each MPI thread performs 175000 sweeps, and since each thread will be given 20000 sweeps to 
  equilibrate - during which time the microstates visited by the system are not used in evaluating equilibrium quantities - setting the block size to 
  155000 sweeps corresponds to each MPI thread performing exactly 1 block. Hence the simulation in total considers 4 blocks.
\end{itemize}

\subsection{Results}
At the completion of the simulation the \texttt{state} file contains the equilibrium quantities, evaluated using block analysis. It is these quantities we
are interested in, primarily the Gibbs free energy difference $\Delta G$ between the phases. The variables \textbf{equil\_DeltaF} and 
\textbf{sigma\_equil\_DeltaF} in \texttt{state} contain the free energy difference and its uncertainty evaluated using block analysis.
Hence the following command extracts the free energy difference and its uncertainty from the \texttt{state} file:
\begin{verbatim}
$ grep -E '( equil_DeltaF| sigma_equil_DeltaF)' state
\end{verbatim}
Recall that all quantities in the \texttt{state} file are extensive; to get the intensive values we must divide them by the number of atoms in the system, which
in this case is 384. Hence the following command gives the intensive free energy difference between the phases:
\begin{verbatim}
$ grep -E '( equil_DeltaF| sigma_equil_DeltaF)' state | awk
'{print $1,$2/384}'
\end{verbatim}
The final value is therefore 0.00004(4)eV, where the units are derived from the convention used in the `setfl' format used in the \texttt{interactions\_in}
file -- the units used in \emph{monteswitch} are derived entirely from the \texttt{interactions.f95} it is used in conjunction with, in this case 
\texttt{interactions\_EAM.f95}.
The convention used in \emph{monteswitch} is that the free energy difference is the free energy of phase 1 minus that of phase 2. Hence a positive free energy
difference, which is the case here, suggests that phase 2 (hcp here as opposed to bcc) is stable at the considered temperature and pressure. 
However, the uncertainty in our value is of the same magnitude as the value; hence the prefered phase cannot be discerned. This is a moot point though:
our free energy difference of 0.04(4)meV can be considered zero for all intents and purposes; this temperature and pressure can be considered to be
a coexistence point to within an error of $\sim 0.04$meV/atom. Thus our results agree with Ref. \cite{Mendelev_2007}.

Using similar commands to the above, one can extract the volume and enthalpy per atom for each phase.
\begin{verbatim}
$ grep -E '( equil_V_1| sigma_equil_V_1)' state | awk '{print $1,
 $2/384}'
\end{verbatim}
gives the volume per atom for phase 1;
\begin{verbatim}
$ grep -E '( equil_V_2| sigma_equil_V_2)' state | awk '{print $1,
  $2/384}'
\end{verbatim}
gives the volume per atom for phase 2;
\begin{verbatim}
$ grep -E '( equil_H_1| sigma_equil_H_1)' state | awk '{print $1,
 $2/384}'
\end{verbatim}
gives the enthalpy per atom for phase 1;
\begin{verbatim}
$ grep -E '( equil_H_2| sigma_equil_H_2)' state | awk '{print $1,
 $2/384}'
\end{verbatim}
gives the enthalpy per atom for phase 2. One can also obtain the mean-squared displacements for all atoms in phase 1: the following command extracts
these quantities from \texttt{state} and outputs the mean-squared displacement vs. atom number:
\begin{verbatim}
$ grep -E ' equil_umsd_1' state | awk '{for(i=2; i<=NF; i++){
print i-1,$i}}'
\end{verbatim}
Their uncertainties are similarly given by 
\begin{verbatim}
$ grep -E ' sigma_equil_umsd_1' state | awk '{for(i=2; i<=NF; 
i++){print i-1,$i}}'.
\end{verbatim}
Similar commands can be used to obtain the mean-squared displacements and associated uncertainties for phase 2. Of course, it is unnecessary to use
a lattice-switch simulation to extract such one-phase' quantities; a conventional Monte Carlo simulation will do the job more efficiently.
Here the quantities are somewhat of a by-product of the lattice-switch simulation to calculate the free energy difference.

\subsection{Consistency checks}
Once the simulation is complete, it is prudent to perform some checks to ensure that it has gone as expected, and hence that the values for equilibrium
quantities obtained from the simulation are meaningful. Of course, comparing the final values obtained from the simulation to `known' values is useful.
Below we describe some less obvious checks to perform.

The free energy difference for a block is given by Eqn. \eqref{DeltaG_stat_mech}, where in this case $t_1$ and $t_2$ are the number of moves which the 
system spent in phase 1 and phase 2 respectively during the block. Of course, this equation presupposes that both phases are explored during the block. 
In evaluating $\Delta G$, \emph{monteswitch} only considers blocks during which both phases are explored. This notwithstanding, it is good to check that
the block size is significantly larger than the time it typically takes the system to explore the whole of order-parameter space -- which in practice
is an equivalent condition to both phases being thoroughly explored during each block. Of course, this was the point of the weight function verifictaion
simulation to determine the appropriate block size. However, to check this more explicitly we plot the order parameter vs. simulation time for MPI thread 0:
\begin{verbatim}
$ grep 'M:' data_0 | awk '{print $2,$3}' > M_vs_t_0.dat
\end{verbatim}
Plotting \texttt{M\_vs\_t\_0.dat} it can be seen that the system traverses the entire range of order-parameter space (-62--32) often within the block size 
(175000 sweeps), as required.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Test Cases}\label{chapter:tests}
The directory \texttt{Tests} contains a suite of test cases for the main programs in \emph{monteswitch}. Of course, these tests can also be used as
examples.

Each test can be executed by executing the \texttt{run.sh} shell script in the corresponding directory after copying the
appropriate `\texttt{interactions\_} file' from \texttt{Interactions} to \texttt{interactions.f95}, and then (re-)compiling the
package (see Chapter \ref{chapter:preliminaries}). Note that the \texttt{run.sh} scripts assume that the main programs \texttt{monteswitch}
and \texttt{monteswitch\_mpi} are located next to the source code in the above directory -- which should be the case by default. Furthermore
the \texttt{run.sh} files may require some modification to suit your platform; see Chapter \ref{chapter:preliminaries}.


\section{Einstein crystal (\texttt{EC})}
The Einstein crystal is an excellent testing ground because analytical results can be obtained for this system:
in what follows we use those for the free energy and mean-squared displacement given in Section 10.2.1 in Ref.
\cite{book:Frenkel}. Here we use the Einstein crystal to test \texttt{monteswitch} and \texttt{monteswitch\_mpi}
in the NVT ensemble. This includes testing multicanonical sampling and weight function generation (including
mobile barrier methods), calculation of free energy differences, and calculation of equilibrium properties.
The relevant \texttt{interactions\_} file for thse tests is \texttt{interactions\_EC.f95}. Before running these 
tests one should copy \texttt{Interactions/interactions\_EC.f95} to \texttt{interactions.f95}, and then (re-)complile 
\emph{monteswitch}. 

The Hamiltonian realised in \emph{monteswitch} in conjunction with \texttt{interactions\_EC.f95} is 
as follows. In phase 1 the energy of each particle corresponds to a harmonic oscilator \emph{about the origin} with spring constant 
\textbf{alpha\_1}. Similar applies to phase 2 with spring constant \textbf{alpha\_2}. \textbf{alpha\_1} and \textbf{alpha\_2} 
are specified via the input file \texttt{interactions\_in}. The format of this file is as follows. On the first line there are two tokens. 
The first token is a \texttt{CHARACTER(LEN=20)} variable (I recommend: \texttt{alpha\_1=}); the second token is the 
value of \textbf{alpha\_1} (type \texttt{REAL}). The second line is similar, but for \textbf{alpha\_2}.


\subsection{\texttt{test\_EC\_1}}
This test calculates the free energy difference between two Einstein crystals with different spring constants,
as well as the mean-squared displacements and mean energies of both crystals. The spring constant for lattice 
1 in is 1.0, and the spring constant for lattice 2 is 2.0. The calculation in this test is 
performed at $\beta=100$ using Boltzmann (i.e., not multicanonical) sampling, for a one particle supercell, and 
consists of 10,000,000 sweeps using \textbf{part\_step}=0.12.

Checks to perform:
\begin{enumerate}
\item
The free energy difference between the two systems should be $(3/200)\ln(1/2)=-0.0103972$. 
Check that this is the case for the simulation: the free energy difference is stored in the \textbf{equil\_DeltaF}
variable output to the terminal, with its uncertainty stored in the \textbf{sigma\_equil\_DeltaF} variable. 
\item
The mean-squared displacements should be $3/200=0.015$ for phase 1 and $3/400=0.0075$ for phase 2: see the 
variables \textbf{equil\_umsd\_1}, \textbf{sigma\_equil\_umsd\_1}, \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2} 
output to the terminal.
\item
The mean energy of both crystals should be 0.015, which follows from the equipartition theorem:
there are 3 degrees of freedom, each with $0.5/\beta$, which in our case gives $1.5/100$. Check that this
is the case by examining the variables \textbf{equil\_H\_1}, \textbf{sigma\_equil\_H\_1}, \textbf{equil\_H\_2} and 
\textbf{sigma\_equil\_H\_2} in the output to the terminal. Recall that 'H' in monteswitch refers to the energy in 
an NVT simulation, and the enthalpy in an NPT simulation.   
\end{enumerate}


\subsection{\texttt{test\_EC\_1\_MPI}}
This test is the same as \texttt{test\_EC\_1}, except that an MPI simulation is run using 4 threads. One should check that
1, 2 and 3 described in \texttt{test\_EC\_1} applies to the variables listed in the \texttt{state} file as opposed to the
terminal. This test essentially verifies that \texttt{monteswitch\_mpi} works correctly, especially that it correctly pools 
the results from many threads and outputs them to the \texttt{state} file.


\subsection{\texttt{test\_EC\_2}}
This test is the same as \texttt{test\_EC\_1}, except that 10 simulations consisting of 1,000,000 sweeps each are performed
instead of one simulation of 10,000,000 sweeps, using both the \texttt{-resume} and \texttt{-new} arguments to the executable 
\texttt{monteswitch} instead of simply the \texttt{-new} argument. This test essentially verifies that checkpointing works
correctly within \texttt{monteswitch}. Checks 1, 2 and 3 described in \texttt{test\_EC\_1} should be performed on the 
\texttt{state} file.


\subsection{\texttt{test\_EC\_2\_MPI}}
This test is the same as \texttt{test\_EC\_2}, except that 10 4-thread MPI simulations are performed. This test essentially verifies 
that checkpointing works correctly for \texttt{monteswitch\_mpi}. Checks 1, 2 and 3 described in \texttt{test\_EC\_1} should be 
performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_3}}
This test calculates the equilibrium quantities as described in \texttt{test\_EC\_1}, but uses multicanonical sampling,
with a weight function generated using the visited states method. Specifically, a weight function generation 
simulation is performed which consists of 10,000,000 sweeps. Then the \texttt{state} file is altered in preparation 
for the production simulation. Then the production simulation is performed, which consists of 10,000,000 sweeps.
Checks 1, 2 and 3 described in \texttt{test\_EC\_1} should be performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_4}}
This test calculates the equilibrium quantities as described in \texttt{test\_EC\_1}, but uses multicanonical sampling,
with a weight function generated using the shooting method. Specifically, a weight function generation simulation
is performed which consists of 1,000,000 sweeps. Then the \texttt{state} file is altered in preparation 
for the production simulation. Then the production simulation is performed, which consists of 10,000,000 sweeps.
The checks to perform for this test are the same as for \texttt{test\_EC\_3}.


\subsection{\texttt{test\_EC\_4\_MPI}}
This test is the same as \texttt{test\_EC\_4}, but uses MPI (2 threads).


\subsection{\texttt{test\_EC\_5}}
This test generates the weight function using the shooting method in conjunction with \texttt{pong\_down} barrier
dynamics and Boltzmann sampling. The simulation consists of 1,000,000 sweeps. Two further files are created 
during this test: \texttt{M\_vs\_t.dat} gives the value of the order parameter vs. sweep number (data points 
every 100 sweeps), and \texttt{macro\_vs\_t.dat} similarly gives the macrostate number, i.e., the bin in the 
order parameter histogram for the system, vs. sweep number. Both plots should resemble a sawtooth.


\subsection{\texttt{test\_EC\_5\_MPI}}
This test is similar to \texttt{test\_EC\_5}, except that a 2-thread MPI simulation is performed, and \texttt{pong\_up}
barrier dynamics are used. The files \texttt{M\_vs\_t\_0.dat} and \texttt{macro\_vs\_t\_0.dat} pertain to thread '0'; and
the files \texttt{M\_vs\_t\_1.dat} and \texttt{macro\_vs\_t\_1.dat} pertain to thread 1. All files should have a sawtooth
pattern.


\subsection{\texttt{test\_EC\_6}}
This test is similar to \texttt{test\_EC\_5}, except that \texttt{random} barrier dynamics are used. The files 
\texttt{M\_vs\_t.dat} and \texttt{macro\_vs\_t.dat} should be random walks.


\subsection{\texttt{test\_EC\_7}}
This test is the same as \texttt{test\_EC\_5}, except that 10 simulations are performed (each consisting of 100,000
sweeps) instead of 1. This tests continuity of simulations using barriers over checkpoints.


\subsection{\texttt{test\_EC\_7\_MPI}}
This test is similar to \texttt{test\_EC\_7}, except that 2 2-thread MPI simulations are performed such that the total
number of sweeps is 1,000,000.


\subsection{\texttt{test\_EC\_8}}
This test is similar to \texttt{test\_EC\_1}, except that the crystal consists of 4 particles.

Checks to perform:
\begin{enumerate}
\item
The free energy difference between the two systems should be -0.0415888
Check that this is the case for the simulation: the free energy difference is stored in the \textbf{equil\_DeltaF}
variable output to the terminal, with its uncertainty stored in the \textbf{sigma\_equil\_DeltaF} variable. 
\item
The mean-squared displacements should be $3/200=0.015$ for phase 1 and $3/400=0.0075$ for phase 2: see the 
variables \textbf{equil\_umsd\_1}, \textbf{sigma\_equil\_umsd\_1}, \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2} output to the 
terminal.
\item
The mean energy of both crystals should be 0.06, which follows from the equipartition theorem:
there are $4\times 3$ degrees of freedom , each with $0.5/\beta$, which in our case gives $6/100$. Check that this
is the case by examining the variables \textbf{equil\_H\_1}, \textbf{sigma\_equil\_H\_1}, \textbf{equil\_H\_2} and \textbf{sigma\_equil\_H\_2}
in the output to the terminal. Recall that 'H' in monteswitch refers to the energy in an NVT simulation, and 
the enthalpy in an NPT simulation.
\end{enumerate}


\subsection{\texttt{test\_EC\_8\_MPI}}
This test is the same as \texttt{test\_EC\_8}, except that an MPI simulation is run using 4 threads.  One should check that
1, 2 and 3 described in \texttt{test\_EC\_8} apply to the variables listed in the \texttt{state} file as opposed to the
terminal. This test essentially verifies that \texttt{monteswitch\_mpi} works correctly for multiple particles, especially that it 
correctly pools the results from many threads and outputs them to the \texttt{state} file.


\subsection{\texttt{test\_EC\_9}}
This test is the same as \texttt{test\_EC\_8}, except that 10 simulations consisting of 1,000,000 sweeps each are performed
instead of one simulation of 10,000,000 sweeps, using both the \texttt{-resume} and \texttt{-new} arguments to the executable 
\texttt{monteswitch} instead of simply the \texttt{-new} argument. This test essentially verifies that checkpointing works
correctly for multiple particles. Checks 1, 2 and 3 described in \texttt{test\_EC\_8} should be performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_9\_MPI}}
This test is the same as \texttt{test\_EC\_9}, except that 10 4-thread MPI simulations are performed. This test essentially verifies 
that checkpointing works correctly for \texttt{monteswitch\_mpi} for multiple particles. Checks 1, 2 and 3 described in \texttt{test\_EC\_8} should be 
performed on the \texttt{state} file.




\section{`NPT Einstein crystal' (\texttt{EC\_NPT})}
The Einstein crystal cannot be used for NPT simulations. Here we consider a modification of the Einstein
crystal model in which the spring constants have a volume dependence. The relevant \texttt{interactions\_} file for these tests is 
\texttt{interactions\_EC\_NPT.f95}. Before running these tests one should copy 
\texttt{Interactions/interactions\_EC\_NPT.f95} to \texttt{interactions.f95}, and then (re-)complile 
\emph{monteswitch}.

The Hamiltonian realised in \emph{monteswitch} in conjunction with \texttt{interactions\_EC\_NPT.f95} is 
as follows. In phase 1 the energy of each particle corresponds to a harmonic oscillator about its
lattice site in which the spring constant is $2\alpha_1V^{-\gamma_1}$, where $V$ denotes the volume of 
the system; the energy of a particle in phase 1 is $\alpha_1V^{-\gamma_1}u^2$, where $u$ is the magnitude of the displacement
of the particle from its lattice site. Similarly the spring constant for phase 2 is $2\alpha_2V^{-\gamma_2}$.
The free parameters are $\alpha_1$, $\gamma_1$, $\alpha_2$ and $\gamma_2$.
The format of the file, named \texttt{interactions\_in} to import these free parameters for a simulation at initialisation
is as follows. On the first line there are two tokens. The first is a \texttt{CHARACTER(LEN=20)} variable (I recommend: \texttt{alpha\_1=});
the second is the value of $\alpha_1$. The second line is similar, but for $\alpha_2$. The third is similar for $\gamma_1$, 
and the fourth is similar for $\gamma_2$.

The following analytical results can be derived for this model in the NPT ensemble.
The partition function for one particle in phase 1 is (where $\Gamma$ denotes the gamma function, and $\beta=1/(k_BT)$)
\begin{equation}
Z_1=\frac{2^{5/2}\pi\Gamma(1.5)}{(\alpha_1\beta)^{3/2}}\frac{\Gamma(1.5\gamma_1+1)}{(\beta P)^{1.5\gamma_1+1}},
\end{equation}
the mean-squared displacements are,
\begin{equation}
\langle u^2\rangle_1=\frac{1}{\beta\alpha_1(\beta P)^{\gamma_1}}\frac{\Gamma(2.5)\Gamma(2.5\gamma_1+1)}{\Gamma(1.5)\Gamma(1.5\gamma_1+1},
\end{equation}
and the mean volume is
\begin{equation}
\langle V\rangle_1=\frac{\Gamma(1.5\gamma_1+2)}{\Gamma(1.5\gamma_1+1)}\frac{1}{\beta P}.
\end{equation}
Similar applies for lattice 2.
For $N>1$ particles the partition function for phase 1 becomes (IS THIS CORRECT?):
\begin{equation}
Z(N)=(2\pi\Gamma(1.5)(\beta\alpha_1)^{-3/2})^N\frac{\Gamma(1.5N\gamma_1+1)}{(\beta P)^{1.5N\gamma_1+1}}.
\end{equation}
Using the expression for the partition function, one can derive the following expression for the free energy difference
between the two phases for $N=1$:
\begin{equation}
F_1-F_2=-\frac{1}{\beta}\ln\Biggl\lbrace 
\frac{\Gamma(1.5\gamma_1+1)}{\Gamma(1.5\gamma_2+1)}\frac{\alpha_2}{\alpha_1}^{3/2}(\beta P)^{1.5(\gamma_2-\gamma_1)}
\Biggr\rbrace
\end{equation}

Here we test \texttt{monteswitch} and \texttt{monteswitch\_mpi} against the above model in the
NPT ensemble. This includes testing multicanonical sampling and weight function generation (including
mobile barrier methods), calculation of free energy differences, and calculation of equilibrium properties.


\subsection{\texttt{test\_EC\_1\_NPT}}
This test calculates the free energy difference between two phases with different $\alpha$ and $\gamma$,
as well as the mean-squared displacements and mean energies of both crystals. Here $\alpha_1=1000$, $\gamma_1=2$,
$\alpha_2=2000$, $\gamma_2=1.8$, $\beta=10$ and $P=0.25$. The calculation in this test is performed using Boltzmann 
sampling (i.e., not multicanonical sampling), for a one particle supercell, and consists of 10,000,000 sweeps 
using \textbf{part\_step} set to 0.03 and \textbf{vol\_step} set to 3.0.

Checks to perform:
\begin{enumerate}
\item
The mean-squared displacements should be 0.00048 for phase 1 and 0.00018089 for phase 2: see the 
variables \textbf{equil\_umsd\_1}, \textbf{sigma\_equil\_umsd\_1}, \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2} output to the 
terminal.
\item
The mean volume should be 1.6 for phase 1 and 1.48 for phase 2: see the variables \textbf{equil\_V\_1}, 
\textbf{sigma\_equil\_V\_1}, \textbf{equil\_V\_2} and \textbf{sigma\_equil\_V\_2} output to the terminal.
\item
The mean enthalphy should be 0.55 for phase 1 and 0.52 for phase 2. This follows from the fact that
the mean enthalpy is the mean energy + $PV$, where the mean energy of both crystals should be 0.15, which 
follows from the equipartition theorem: there are 3 degrees of freedom, each with $0.5/\beta$.
See the variables \textbf{equil\_H\_1}, \textbf{sigma\_equil\_H\_1}, \textbf{equil\_H\_2} and \textbf{sigma\_equil\_H\_2} output to the terminal.
Recall that 'H' in monteswitch refers to the energy in an NVT simulation, and the enthalpy in an NPT simulation.
\item
The free energy difference per particle between the two systems should be -0.11285. See the variables
\textbf{equil\_DeltaF} and \textbf{sigma\_equil\_DeltaF} output to the terminal.
\end{enumerate}


\subsection{\texttt{test\_EC\_NPT\_2}}
This test is the same as \texttt{test\_EC\_NPT\_1}, except that 10 simulations consisting of 1,000,000 sweeps each are performed
instead of one simulation of 10,000,000 sweeps, using both the \texttt{-resume} and \texttt{-new} arguments to the executable 
\texttt{monteswitch} instead of simply the \texttt{-new} argument. This test essentially verifies that checkpointing works
correctly. Checks 1--4 described in \texttt{test\_EC\_NPT\_1} should be performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_NPT\_2\_MPI}}
This test is the same as \texttt{test\_EC\_NPT\_2}, except that 10 4-thread MPI simulations are performed. This test essentially verifies 
that checkpointing works correctly for \texttt{monteswitch\_mpi}. Checks 1--4 described in \texttt{test\_EC\_NPT\_2} should be 
performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_NPT\_3}}
This test calculates the equilibrium quantities as described in \texttt{test\_EC\_NPT\_1}, but uses multicanonical sampling,
with a weight function generated using the visited states method. Specifically, a weight function generation 
simulation is performed which consists of 10,000,000 sweeps. Then the \texttt{state} file is altered in preparation 
for the production simulation. Then the production simulation is performed, which consists of 10,000,000 sweeps.

This test also outputs the weight function generated using the visited states method, as well as a histogram of 
the macrostates visited during the production simulation. These can be found in the files \texttt{wf.dat} and \texttt{M\_hist.dat}
respectively. 

Checks to perform beyond  1--4 described in \texttt{test\_EC\_NPT\_1}:
\begin{enumerate}
\setcounter{enumi}{4}
\item
The macrostate histogram should be fairly flat, which reflects the fact that all macrostates are
visted with equal probability in multicanonical sampling using an ideal weight function.
\end{enumerate}


\subsection{\texttt{test\_EC\_NPT\_4}}
This test is similar to \texttt{test\_EC\_NPT\_2}, but uses 5 particles, and a lattice switch which changes the system volume.
This checks that lattice switches which do not preserve the system volume sample the NPT ensemble correctly.

Checks to perform:
\begin{enumerate}
\item
The free energy difference between the two phases should be -0.7860673299.
\end{enumerate}


\section{Lennard--Jones solid: hcp vs. fcc (\texttt{LJ\_hcp\_fcc})}
A solid in which particles interact via a Lennard-Jones potential is a more realistic test for \emph{monteswitch}.
Here we try to reproduce the results of Refs. \cite{thesis:Jackson,Jackson_2002}. Specifically, we calculate the free energy
difference between hcp and fcc phases of the Lennard-Jones solid. The relevant \texttt{interactions\_} file for these tests is 
\texttt{interactions\_LJ\_hcp\_fcc.f95}. Before running these tests one should copy \texttt{Interactions/interactions\_LJ\_hcp\_fcc.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}.

The Hamiltonian realised in \emph{monteswitch} in conjunction with \texttt{interactions\_LJ\_hcp\_fcc.f95} is applicable only to
to the hcp--fcc problem. Phase 1 is assumed to be hcp and phase 2 is assumed to be fcc. The Lennard-Jones interactions
used here are not your typical Lennard-Jones interactions. Usually one truncates the interactions at
a predetermined distance, or uses a predetermined 'list' of interacting pairs of particles. However, this
approach yields errors which cannot be ignored for this problem: see Refs. \cite{thesis:Jackson,Jackson_2002} for details. A
better approach is to evaluate the \emph{difference} of the energy of the phase under consideration relative to the 
ground state for the density under consideration, and apply the usual truncations to this difference. This is what is done here:
The energy here for particle positions $\lbrace\mathbf{r}\rbrace$ in the hcp phase, given that the system currently has density $\rho$, is:
\begin{equation}
E = \Phi_{\text{LJ,trunc}}(\lbrace\mathbf{r}\rbrace)-\Phi_{\text{LJ,trunc}}(\lbrace\mathbf{R}_{\text{hcp}}\rbrace)
+ E_{\text{GS,hcp}}(\rho),
\end{equation}
where $\lbrace\mathbf{R}_{\text{hcp}}\rbrace$ are the lattice vectors corresponding to the hcp lattice at the current density $\rho$, 
$\Phi_{\text{LJ,trunc}}(\lbrace\mathbf{r}\rbrace)$ is the Lennard-Jones energy for the set of particle positions $\lbrace\mathbf{r}\rbrace$
using truncated interactions (in the conventional sense, e.g., ignore interactions between particles $i$ and $j$ if their separation is
greater than some cut-off), and $E_{\text{GS,hcp}}(\rho)$ is the \emph{exact} energy of the hcp lattice at density $\rho$, i.e., what 
$\Phi_{\text{LJ,trunc}}(\lbrace\mathbf{R}_{\text{hcp}}\rbrace)$ would be if the cut-off distance were taken to infinity. Similar applies
for the fcc phase.
Of course, this approach necessitates a tailor-made \texttt{interactions\_} file for the hcp--fcc. By contrast the \texttt{interactions\_}
file corresponding to the `conventional' Lennard-Jones Hamiltonian can be applied to any pair of phases.
Note that the usage of \texttt{interactions\_LJ\_hcp\_fcc.f95} is identical to \texttt{interactions\_LJ.f95} -- which is described in
Chapter \ref{chapter:interactions}.


\subsection{\texttt{test\_LJ\_hcp\_fcc\_1\_MPI}}
This test calculates the free energy difference between hcp and fcc for a 216-particle supercell at $P=0$ and
$\beta=10$ in the NPT ensemble, given Lennard-Jones parametrisation $\epsilon=\sigma=1$. 2 4-thread MPI simulations are used. 
The first generates the weight function using \texttt{pong\_down} barrier dynamics over 500000 sweeps. The second simulation calculates 
the free energy difference. Note that this simulation may take a while to run. The final result for the free energy difference
should match that in Ref. \cite{thesis:Jackson}, Fig. 6.21, the data-point corresponding to $k_BT=0.1$, i.e.,
the free energy difference per particle should be -0.00055 (Note that Jackson defines the free energy difference as
that of fcc minus that of hcp, while in \emph{monteswitch}, with hcp corresponding to lattice 1 and fcc corresponding to
lattice 2, the free energy difference is defined as that of hcp minus that of fcc -- hence the change of sign here
relative to Jackson's result). Hence in the test simulation the final extensive free energy difference should be -0.12.

Checks to perform:
\begin{enumerate}
\item
The final free energy difference between the two systems should be -0.12. Check that this is the case for the
simulation: the free energy difference is stored in the \textbf{equil\_DeltaF} in the \texttt{state} file, with its uncertainty
stored in the \textbf{sigma\_equil\_DeltaF} variable.
\end{enumerate}


\section{The hard-sphere solid (\texttt{HS})}
The hard-sphere solid has been well studied, and makes an excellent testing ground for \emph{monteswitch}.
The relevant \texttt{interactions\_} file for these tests is \texttt{interactions\_HS.f95}, whose usage is described in Chapter
\ref{chapter:interactions}. Before running these tests one should copy \texttt{Interactions/interactions\_HS.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}. Note that here we set the energy cost of two spheres overlapping,
$\epsilon$, to 100,000, as well as setting $\beta=1$ to realise hard spheres as described in Chapter \ref{chapter:interactions}.


\subsection{\texttt{test\_HS\_1}}
This test calculates the free energy difference between the hcp and fcc phases for a 216-particle supercell in the NPT ensemble at
$P\beta\sigma^3=14.58$ (where $\sigma$ denotes the hard-sphere diameter), using \texttt{UVM} volume moves. An analogous calculation
has been performed in Refs. \cite{thesis:Jackson,Bruce_2000}, the results of which will act as a benchmark.
2 4-thread MPI simulations are used. The first generates the weight function using \texttt{pong\_down}
barrier dynamics over 2,000,000 sweeps. The second simulation calculates the free energy difference, using
a total of 125,000,000 sweeps. Note that this simulation may take a while to run. The final result for the free energy difference
should match that Refs. \cite{thesis:Jackson,Bruce_2000}: the free energy difference per particle should be
$0.00113(4)/\beta$. (Note that Jackson defines the free energy difference as that of fcc minus that of hcp,
while in \emph{monteswitch}, with hcp corresponding to phase 1 and fcc corresponding to phase 2, the free energy
difference is defined as that of hcp minus that of fcc -- hence the change of sign here
relative to Jackson's result).

Checks to perform:
\begin{enumerate}
\item
The final free energy difference between the two systems, when divided by 216, should agree with 0.00113(4).
Check that this is the case for the simulation: the free energy difference is stored in the \textbf{equil\_DeltaF}
in the 'state' file, with its uncertainty stored in the \textbf{sigma\_equil\_DeltaF} variable.
\end{enumerate}


\subsection{\texttt{test\_HS\_2}}
This test calculates the properties of the hcp phase for a 216-particle supercell at $P\beta\sigma^3=14.58$ in
the NPT ensemble. A 4-thread MPI simulation is used: a conventional (one-phase, not LSMC) Monte Carlo simulation is
performed with \texttt{UVM} volume moves, which allow each dimension of the supercell to move independently. The
results should correspond to Table 4.1 in Ref. \cite{thesis:Jackson}; specifically, the row $6^3$, hcp, etc. Note
that there is a typo in this refence: the results in Table 4.1 correspond to a reduced pressure of 14.58, \emph{not}
18.74. The densities quoted for the latter are not in agreement with those quoted in the table; however they
do correspond to other hard-sphere simulations the author performed at a reduced pressure of 14.58, which also agree with
Speedy's equation of state (Ref. 70 in Ref. \cite{thesis:Jackson}) at that pressure.

Checks to perform:
\begin{enumerate}
\item
The density obtained from the simulation, when divided by $\sqrt{2}$, should agree with the value in the table,
i.e., 0.7776(1). To calculate the density note that the supercell contains 216 particles, and the equilibrium
volume of the hcp supercell and its uncertainty obtained via block analysis are stored in the variables
\textbf{equil\_V\_1} and \textbf{sigma\_equil\_V\_1}.
\item
The hcp $c/a$ ratio should agree with the value in the table, i.e., 1.6323(7). The $c/a$ ratio can be obtained from
the following \texttt{awk} command, which extracts a measure of the instantaneous $c/a$ ratio from \textbf{Lx} and \textbf{Lz} in the
\texttt{data\_0} file:
\begin{verbatim}
awk 'NR%14==1 {Lx=$3}; NR%14==3 {Lz=$3; print $2,(Lz/6)/(Lx/3)}' data_0 | awk '$1>0 {sum=sum+$2;count=count+1}; END{print sum/count}'
\end{verbatim}
Doing similar for \texttt{data\_1}, \texttt{data\_2} and \texttt{data\_3} will give 4 independent results which can be combined
to give a final mean and standard error.
\end{enumerate}


\section{Embedded atom model (\texttt{EAM})}
The relevant \texttt{interactions\_} file for these tests is \texttt{interactions\_EAM.f95}, whose usage is described in Chapter
\ref{chapter:interactions}. Before running these tests one should copy \texttt{Interactions/interactions\_EAM.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}.


\subsection{\texttt{test\_EAM\_1}}
The test here is exactly the same calculation as the worked example; see Chapter \ref{chapter:example} for details.

Checks to perform:
\begin{enumerate}
\item
The final free energy difference between the two systems should be 0. Check that this is the case for the
simulation: the free energy difference is stored in the \textbf{equil\_DeltaF} in the \texttt{state} file, with its uncertainty
stored in the \texttt{sigma\_equil\_DeltaF} variable.
\end{enumerate}



\section{`Conventional' Lennard-Jones (\texttt{LJ})}
The relevant \texttt{interactions\_} file for these tests is \texttt{interactions\_LJ.f95}, whose usage is described in Chapter
\ref{chapter:interactions}. Before running these tests one should copy \texttt{Interactions/interactions\_LJ.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}.


\subsection{\texttt{test\_LJ\_1}}
This test calculates the potential energy per particle of the Lennard-Jones fluid in the NVT ensemble, with a cut-off (not shifted) of
$3\sigma$, $\epsilon=\sigma=1$, at a temperature of 0.85 and density of 0.003.

Checks to perform:
\begin{enumerate}
\item
The aforementioned energy, with tail corrections, should match those of \url{http://mmlapps.nist.gov/srs/LJ_PURE/mc.htm},
specifically, -0.03102(6).
\end{enumerate}



%% And finally the references
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{ieeetr} %\bibliographystyle{plain}%\bibliographystyle{these}

\bibliography{bibliography}

\end{document}
\endinput
