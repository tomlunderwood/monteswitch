 \documentclass{report}

\usepackage[english]{babel}

\usepackage{graphicx}% Needed for figure files
\usepackage{hyperref}% Gives hyperlinks
\usepackage{amsmath,amsthm,amssymb}% Extra maths stuff
\usepackage{enumitem} % For a,b,c,... bullet points 
\usepackage{longtable} % Split long tables over many pages
\usepackage{lscape} % For rotating certain pages to landscape

\usepackage{nomencl} % Needed for abbreviations
\makenomenclature

\begin{document}
\sloppy

\title{\emph{monteswitch} user manual\\ (v 1.0.0)}
\author{Tom L. Underwood}
\date{\today}
\maketitle


\addcontentsline{toc}{chapter}{Contents}
\tableofcontents


\addcontentsline{toc}{chapter}{Acknowledgements}
\chapter*{Acknowledgements}
The development of \emph{monteswitch} was supported by funding from the Engineering and Physical Sciences Research Council (EPSRC),
under the supervision of Graeme Ackland. Valuable discussions with Mikhail Mendelev, Nigel Wilding, Andrey Brukhno and Kevin Stratford 
are gratefully acknowledged.

\addcontentsline{toc}{chapter}{Disclaimer}
\chapter*{Disclaimer}
While we have endeavoured to ensure \emph{monteswitch} is free from error, we cannot guarantee this. Hence you use \emph{monteswitch}
at your own risk.

\addcontentsline{toc}{chapter}{List of Abbreviations}
\renewcommand{\nomname}{List of Abbreviations}
\printnomenclature

\addcontentsline{toc}{chapter}{Conventions used in this manual}
\chapter*{Conventions used in this manual}
Throughout this manual we use:
\begin{itemize}
\item \texttt{typewriter font} to signify file and program names, command-line arguments to programs, and shell
commands and shell output. Shell commands are always provided on stand-alone lines starting with a `\verb|$|', e.g.,
\begin{verbatim}
$ echo "I am a shell command"
$ echo "So am I"
\end{verbatim}
Furthermore, long shell commands which do not fit on a single line are wrapped on to the following line without the presence of
a `\verb|$|', e.g.,
\begin{verbatim}
$ echo "I am a loooooooooooooooooooooooooooooooooooooooooooo
ooong shell command"
$ echo "I am not"
\end{verbatim}
Note however that `\verb|$|' is often used in the shell command itself. It should be clear from the context whether this is the
significance of any given `\verb|$|' or not.
\item \textbf{Bold font} to signify the names of variables in input and output files for the \emph{monteswitch} programs.
\item \texttt{UPPER CASE TYPEWRITER FONT} to signify Fortran statements and variables. Note however that the \emph{monteswitch} 
source code is predominantly lower case (Fortran is case-insensitive). Furthermore, for clarity we sometimes use lower case, e.g.,
the type of a \texttt{REAL} array of size \textbf{M\_grid\_size} is signified as \texttt{REAL(M\_grid\_size)}.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
Lattice-switch Monte Carlo (LSMC) \cite{Bruce_1997,Bruce_2000} is a method which enables the free energy difference between pairs of solid
phases to be efficiently evaluated to a high precision. [It has been widely applied: CHECK ALL PSMC REFERENCES ARE INCLUDED]
\cite{Bruce_1997,Pronk_1999,Bruce_2000,Wilding_2000,Jackson_2002,Errington_2004,McNeil-Watson_2006,Jackson_2007,Marechal_2008,Yang_2008,
Raiteri_2010,Quigley_2014,Bridgwater_2014}
\nomenclature{LSMC}{Lattice-switch Monte Carlo}%
\emph{monteswitch} is a package whose primary purpose is to enable LSMC simulations to be performed, and can treat 
`atomic' systems (i.e., those in which the constituent particles do not have rotational degrees of 
freedom), and pairs of phases which can be represented by an orthorhombic unit cell, in the NVT and NPT ensembles.
Note that the two `phases' need not be homogeneous crystals, though we expect that this will be the main use for \emph{monteswitch}.
[DIFFERENT SPECIES?]
Possible applications for \emph{monteswitch} include evaluating the free energy cost of creating
point defects and interfaces.

%While steps have been taken to implement LSMC in existing general-purpose Monte Carlo codes, we believe that \emph{monteswitch} will fulfill
%an important `gap in the market' for the foreseeable futue for several reasons. Firstly, \emph{monteswitch} is a bespoke LSMC code, and as such
%one would expect it to require less computational resources than general-purpose codes for similar LSMC calculations. Secondly, \emph{monteswitch} 
%was designed from the outset to be highly customisable: users can readily implement their own inter-particle interactions, which may include
%interfacing \emph{monteswitch} with an external program.

This document describes how to use \emph{monteswitch}. Note that this document does not provide details regarding the structure of the source code. 
Similarly, this document does not provide thorough details of how the LSMC method is implemented in \emph{monteswitch}. We direct readers
interested in such things to the HTML source code documentation -- which can be generated from the source code (see Chapter
\ref{chapter:preliminaries}) -- or failing that the source code itself. We assume that the reader is already competent with the unix shell, 
including utilities such as \texttt{grep}, \texttt{sed} and \texttt{awk}. Often we provide examples of commands which utilise the shell and the 
aforementioned utilities to perform certain tasks. However we never describe exactly how these commands work for the sake of brevity; interested users are 
referred to the relevant documentation online or elsewhere. In a similar vein, when we describe Fortran-related issues we assume the reader has 
an expertise in Fortran 95 . We also assume that the user is familiar with the Monte Carlo method (in the sense of computational
chemistry), but not necessarily with LSMC. For further information regarding Monte Carlo simulations in condensed 
matter physics, see, e.g., Ref. \cite{book:Frenkel}. 

The layout of this document is as follows. In Chapter \ref{chapter:background} we describe the theory behind LSMC to a depth which enables the user to 
competently perform LSMC simulations using \emph{monteswitch}. The rest of this document pertains to \emph{monteswitch} itself.
In Chapter \ref{chapter:preliminaries} we describe how to install \emph{monteswitch}, and provide
an overview of the package. Then in Chapter \ref{chapter:simulation_programs} we describe how to use the main Monte Carlo programs within
\emph{monteswitch}. Chapter \ref{chapter:interactions} describes the various interatomic potentials included with \emph{monteswitch}, and
describes how users can implement their own potentials. Chapter \ref{chapter:utility_programs} describes how to use the various utility
programs included with \emph{monteswitch} for the creation of input files and post-processing of output files. In Chapter \ref{chapter:example}
we provide a worked example which elucidates how \emph{monteswitch} can be used to solve a `real' problem. Finally in Chapter \ref{chapter:tests}
we describe the test cases included with \emph{monteswitch} which, as well as validating \emph{monteswitch}, serve as an archive of examples.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background Theory}\label{chapter:background}
In this chapter we describe the LSMC methodology as relevant to \emph{monteswitch}. Further information regarding LSMC,
and its generalisations to solid--fluid transitions and molecular systems, can be found in Refs.  
\cite{Bruce_1997,Bruce_2000,Wilding_2000,Jackson_2002,Errington_2004,McNeil-Watson_2006,Jackson_2007,Bridgwater_2014}.
\footnote{The incarnation of LSMC suitable for solid--fluid transitions is referred to as \emph{phase-switch Monte Carlo}. Furthermore
the reader should be aware that the term lattice-\emph{switching} Monte Carlo has also been applied to LSMC.}


\section{What do we mean by `phase'?}\label{sec:phase}
LSMC is a method to calculate the free energy difference between two phases. The term `phase' could mean a number of things. However, here
we use the following definition which is convenient for our purposes. We define a phase using some state of the system
which is \emph{representative} of the phase in question. We refer to such a state as a \emph{representative state}: phase $\alpha$ is the 
set of all states of the system which are `reachable' from the chosen representative state for $\alpha$ on the timescale of the simulation. 
For example, if one is interested in the `fcc phase', i.e., the set of states 
corresponding to thermodynamic fluctuations in the particle positions about their average positions (which form an fcc crystal
lattice), then a suitable choice of representative state would be that in which the particle positions form an ideal fcc crystal lattice. A
simulation initialised in this state would, on the timescales of the simulation, explore the configurations which
constitute the fcc phase.


\section{Calculating free energy differences}
Now that we have defined what we mean by a `phase', consider now a system which is free to visit two phases 1 and 2 (and only phases 1 and 2).
Of phases 1 and 2, the equilibrium phase is that with the lower free energy $\mathcal{F}$, where $\mathcal{F}$ is the Helmholtz free energy $F$ in the 
NVT ensemble and the Gibbs free energy $G$ in the NPT ensemble. It is the free energy difference between the phases 
$\Delta\mathcal{F}\equiv \mathcal{F}_1-\mathcal{F}_2$ which we wish to evaluate, where $\mathcal{F}_1$ and $\mathcal{F}_2$ denote the free energies of 
phases 1 and 2.
We now derive an expression for $\Delta \mathcal{F}$ which allows $\Delta \mathcal{F}$ to be determined from the relative time $t_1$ and $t_2$ which 
the system spends in each phase 1 and 2 during a sufficiently long simulation. It is this expression which is ultimately used in LSMC to calculate 
$\Delta \mathcal{F}$. Consider the free energy of phase $\alpha$:
\begin{equation}\label{Falpha_def}
\mathcal{F}_{\alpha}=-\beta^{-1}\ln Z_{\alpha},
\end{equation}
where
\begin{equation}\label{Zalpha_def}
Z_{\alpha}=\sum_{\sigma\in\alpha}\exp(-\beta \mathcal{E}_{\sigma})
\end{equation}
is the partition function for phase $\alpha$; $\beta\equiv 1/(k_BT)$; $k_B$ is Boltzmann's constant; $\sigma$ denotes a state of the system;
$\mathcal{E}_{\sigma}$ denotes the energy $E_{\sigma}$ of state $\sigma$ in the NVT ensemble, and the enthalpy $H_{\sigma}=E_{\sigma}+PV_{\sigma}$ of
state $\sigma$ in the NPT ensemble, where $V_{\sigma}$ denotes the volume of state $\sigma$; 
and the summation in the above equation is over all microstates which `belong' to phase $\alpha$. 
From Eqn. \eqref{Falpha_def} it follows that
\begin{equation}\label{DeltaF_Z}
\Delta \mathcal{F}=\beta^{-1}\ln\biggl(\frac{Z_2}{Z_1}\biggr).
\end{equation}
Now,
\begin{equation}\label{MC_prob}
p_{\sigma}=\frac{1}{Z}e^{-\beta \mathcal{E}_{\sigma}}, \quad Z\equiv Z_1+Z_2
\end{equation}
is the probability that the system, free to explore both phases 1 and 2, is in state $\sigma$. Hence the probability of the system being in
phase $\alpha$ is
\begin{equation}
p_{\alpha} = \sum_{\sigma\in \alpha}p_{\sigma} = Z_{\alpha}/Z,
\end{equation}
where we have used Eqn. \eqref{Zalpha_def}. Finally, substituting this into Eqn. \eqref{DeltaF_Z} gives
\begin{equation}\label{DeltaF_stat_mech}
\Delta \mathcal{F}=\beta^{-1}\ln\biggl(\frac{p_2}{p_1}\biggr),
\end{equation}
where $p_1$ and $p_2$ denote the probability of the system being in phase 1 and 2 respectively. 

The above equation suggests the following method for calculating $\Delta \mathcal{F}$ from, e.g. a molecular dynamics simulation: measure the 
relative time $t_1$ 
and $t_2$ which the system spends in each phase 1 and 2 during the simulation, and substitute these quantities into the above equation -- bearing in mind 
that $t_2/t_1=p_2/p_1$. However, this method is often intractable in practice for two solid phases, 
because the time taken for the system to transition between the two phases is too long to allow a reasonable estimate of $t_2/t_1$ to be deduced 
in a reasonable simulation time; it may be the case that, regardless of the phase in which the simulation is initialised, the system \emph{never} 
transitions to the `other' phase during the course of the simulation.
The problem is that, while the regions of phase space corresponding to phase 1 and phase 2 both correspond to probable states of the system
at thermodynamic equilibrium, these regions are separated by a \emph{free energy barrier} -- a region of phase space associated
with states which are very improbable at thermodynamic equilibrium. This barrier inhibits transitions between the `islands of
stability' in phase space associated with phase 1 and phase 2.

This problem can in principle be circumvented within the Monte Carlo method.
In the original incarnation of Monte Carlo, which we refer to as \emph{canonical Monte Carlo}\cite{Metropolis_1953} (which we contrast later to 
\emph{multicanonical Monte Carlo}), the system is evolved throughout the simulation as follows. Each timestep we generate a trial state of the system 
$\sigma'$, and attempt to change the system from its current state $\sigma$, to the trial state. 
The traditional approach for NVT ensembles is to perform a `particle move' to generate a trial state. Here, one particle in $\sigma$ is moved
to yield $\sigma'$. In NPT ensembles particle moves are supplemented by `volume moves', in which the volume, and potentially shape, of the 
entire system is altered, along with a commensurate rescaling of the particle positions. We accept the change of state from $\sigma$ to $\sigma'$ with 
a probability $p_{\sigma\to\sigma'}$, which is a function of the energies of the states $\sigma$ and $\sigma'$ in the NVT ensemble, and
the enthalpies and volumes of the states $\sigma$ and $\sigma'$ in the NPT ensemble. The function also depends on the specific scheme used to generate 
state $\sigma'$ from $\sigma$. For the schemes used in \emph{monteswitch}, $p_{\sigma\to\sigma'}$ is given by
\begin{equation}\label{p_Metropolis}
p_{\sigma\to\sigma'}=\text{max}\Bigl[1,e^{\beta(E_{\sigma'}-E_{\sigma})}\Bigr]
\end{equation}
for particle moves and
\begin{equation}\label{p_Metropolis_NPT}
p_{\sigma\to\sigma'}=\text{max}\Bigl[1,e^{\beta(H_{\sigma'}-H_{\sigma})+(N+1)\ln(V_{\sigma'}/V_{\sigma})}\Bigr],
\end{equation}
for volume moves.
\footnote{See, e.g, Ref. \cite{book:Frenkel} for expressions for $p_{\sigma\to\sigma'}$ for other schemes}. 
The end result is that each state $\sigma$ is sampled with a probability which reflects the underlying ensemble, i.e., Eqn. \eqref{MC_prob}.
Hence the equilibrium value of any physical quantity $X$ can be obtained by evaluating the average of $X$ over all timesteps in a sufficiently long 
simulation. In this manner $t_1$ and $t_2$, and hence $\Delta \mathcal{F}$ (via Eqn. \eqref{DeltaF_stat_mech}) can be calculated; 
$t_{\alpha}$ is the time average of the quantity $\theta_{\alpha}$, where $\theta_{\alpha}=1$ if the system is in phase $\alpha$ and 0 otherwise.
However, in canonical Monte Carlo one has considerable freedom as to how trial states are generated; one is by no means limited to the aforementioned 
`traditional' move set. The prospect therefore exists of generating trial states in a manner which results in the system traversing a path in phase 
space which allows $\Delta \mathcal{F}$ to be calculated relatively quickly. Such a path would involve frequent transitions between both phases 1 and 
2 by `tunnelling' through the free energy barrier separating them.


\section{Lattice switch Monte Carlo moves}\label{sec:lattice_switch}
In LSMC a new type of move, a \emph{lattice switch}, is introduced to supplement the traditional move set mentioned above. A lattice switch move takes
the system \emph{directly} from one phase to the other, bypassing any free energy barriers separating the phases. Every time a lattice switch is accepted, 
the system transitions to the `other' phase. The salient feature of the move is that the underlying `lattice' which characterises the current phase is 
`switched' for a lattice which characterises the other phase. For example if the two phases in question are fcc and hcp, then a lattice switch from an
fcc state involves switching the underlying fcc lattice for an hcp lattice, while preserving the \emph{displacements} of each particle from its associated
lattice site. 

Of course this is just a basic description of the lattice switch. We now explain exactly how lattice switches are implemented in \emph{monteswitch}. 
In \emph{monteswitch} two states are provided at initialisation, one for each phase. The functions of these states are twofold. Firstly, they act as 
prospective initial states for the simulation: if the system is to be initialised in phase 1, then the phase-1 state will be used as the initial state.
Secondly, they are used to determine the nature of the lattice switch move. We refer to these states as \emph{reference states}.
Now, in \emph{monteswitch} only orthorhombic systems can be treated. Hence we only consider orthorhombic systems here. For such systems a state 
amounts to a specification of the following: the dimensions of the supercell $L_x$, $L_y$ and $L_z$ in each Cartesian direction; either the \emph{fractional} 
positions $\lbrace\tilde{\mathbf{r}}_i\rbrace$ or the \emph{absolute} positions $\lbrace\mathbf{r}_i\rbrace$ of the particles within the supercell
(we denote fractional positions by a `$\sim$'); and the species of the particles $\lbrace S_i\rbrace$. For convenience we gather these quantites into
a tuple: $(L_x,L_y,L_z,\lbrace\tilde{\mathbf{r}}_i\rbrace,\lbrace S_i\rbrace)$ or $(L_x,L_y,L_z,\lbrace\mathbf{r}_i\rbrace,\lbrace S_i\rbrace)$ amounts to
a specification of the state of the system. With this in mind, let 
$(\mathcal{L}^{(1)}_x,\mathcal{L}^{(1)}_y,\mathcal{L}^{(1)}_z,\lbrace\tilde{\mathcal{R}}^{(1)}_i\rbrace,\lbrace\mathcal{S}^{(1)}_i\rbrace)$ and
$(\mathcal{L}^{(2)}_x,\mathcal{L}^{(2)}_y,\mathcal{L}^{(2)}_z,\lbrace\tilde{\mathcal{R}}^{(2)}_i\rbrace,\lbrace\mathcal{S}^{(2)}_i\rbrace)$ describe
the reference states for phases 1 and 2 respectively.
Without loss of generality consider now a state $\sigma=(L_x,L_y,L_z,\lbrace\mathbf{r}_i\rbrace,\lbrace s_i\rbrace)$ belonging to phase 1.
We now describe how the state $\sigma'=(L_x',L_y',L_z',\lbrace\mathbf{r}'_i\rbrace,\lbrace s'_i\rbrace)$ which results from a lattice switch from
state $\sigma$is generated from $\sigma$ in \emph{monteswitch}. We first construct the underlying phase-1 `lattice' for $\sigma$.
The positions of the lattice sites, which we denote as $\lbrace\mathbf{R}^{(1)}_i\rbrace$, are constructed from the phase-1 reference state. Specifically, 
$\lbrace\mathbf{R}^{(1)}_i\rbrace$, transformed into fractional coordinates, is identical to the fractional positions of the particles in the phase-1 
reference state:
\begin{equation}
\mathbf{R}^{(1)}_i = \text{diag}(L_x,L_y,L_z)\tilde{\mathcal{R}}^{(1)}_i
\end{equation}
for all particles $i$, where $\text{diag}(L_x,L_y,L_z)$ denotes the $3\times 3$ matrix with $L_x$, $L_y$ and $L_z$ along the leading diagonal. We now turn
to constructing the trial state $\sigma'$. We begin by constructing the dimensions of the supercell for $\sigma'$. The reference states for both phases are 
used to determine how the supercell is transformed during the switch. Specifically, the dimensions of the supercell for $\sigma'$ are given by
\begin{equation}
L_x'=\frac{\mathcal{L}_x^{(2)}}{\mathcal{L}_x^{(1)}}L_x, \quad 
L_y'=\frac{\mathcal{L}_y^{(2)}}{\mathcal{L}_y^{(1)}}L_y, \quad 
L_z'=\frac{\mathcal{L}_z^{(2)}}{\mathcal{L}_x^{(1)}}L_z.
\end{equation}
Hence in the lattice switch the supercell is dilated/contracted in each Cartesian dimension by the same factor as would be the case in transforming the
supercell from the phase-1 reference state to the phase-2 reference state.
Thirdly, we construct the underlying lattice for phase 2. As was the case for the underlying lattice for phase 1, the underlying lattice for phase
2, transformed into fractional coordinates, is identical to the fractional positions of the particles in the phase-2 reference state:
\begin{equation}
\mathbf{R}^{(2)}_i = \text{diag}(L_x',L_y',L_z')\tilde{\mathcal{R}}^{(2)}_i
\end{equation}
for all $i$.
Fourthly we construct the particle positions in $\sigma'$ using the particle positions in $\sigma$ and the aforementioned underlying lattices for
phases 1 and 2 as follows:
\begin{equation}
\mathbf{r}_i'=\mathbf{r}_i-\mathbf{R}^{1}_i+\mathbf{R}^{2}_i
\end{equation}
for all $i$. Note that this amounts to a transformation of the particle positions in which the underlying phase-1 lattice $\lbrace\mathbf{R}^{1}_i\rbrace$ 
is substituted for a phase-2 lattice $\lbrace\mathbf{R}^{2}_i\rbrace$ while keeping the \emph{displacement} of each particle from its lattice site unchanged. 
This can perhaps be seen more clearly by reexpressing the transformation as follows:
\begin{equation}
\mathbf{r}_i=\mathbf{R}^{(1)}_i+\mathbf{u}_i \to \mathbf{r}'_i=\mathbf{R}^{(2)}_i+\mathbf{u}_i
\end{equation}
for all $i$, where
\begin{equation}
\mathbf{u}_i=\mathbf{r}_i-\mathbf{R}^{(1)}_i=\mathbf{r}'_i-\mathbf{R}^{(2)}_i
\end{equation}
is the displacement of particle $i$ from its lattice site.
Finally we transform the species of $\sigma$ (which initialy corresponding to phase 1) to correspond to phase 2:
\begin{equation}
s_i= S^{(1)}_i\to s_i'= S^{(2)}_i
\end{equation}
for all $i$.

Note that the lattice switch as just described is an involution: if a lattice switch from state $\sigma$ yields state $\sigma'$, then
performing a lattice switch from state $\sigma'$ yields $\sigma$.


\section{Multicanonical Monte Carlo}
One might expect that by regularly making lattice switches, the system will regularly transition between phases, allowing $\Delta \mathcal{F}$ to 
be efficiently evaluated as described above. Unfortunately using canonical Monte Carlo one finds that lattice switches are too rarely accepted for 
this approach to be useful.
The solution to this problem is to use \emph{multicanonical Monte Carlo}\cite{Berg_1991,Berg_1992,Smith_1995} instead of canonical Monte Carlo.
\footnote{Multicanonical Monte Carlo belongs to the class of extended/expanded ensemble techniques; see, e.g., Ref. \cite{Iba_2001}.}
The former is a straightforward generalisation of the latter in which, instead of sampling from the probability distribution $p_{\sigma}$ 
(Eqn. \eqref{MC_prob}), one samples from the distribution
\begin{equation}\label{MCMC_prob}
\tilde{p}_{\sigma}=\frac{1}{\tilde{Z}}e^{-\beta \mathcal{E}_{\sigma}}e^{\eta_{\sigma}}, \quad \tilde{Z}\equiv\sum_{\sigma}e^{-\beta \mathcal{E}_{\sigma}}e^{\eta_{\sigma}},
\end{equation}
where $\eta_{\sigma}$, known as the \emph{weight function}, is chosen according to the aims of the simulation. 
Using Eqn. \eqref{MC_prob}, it can be shown that
\begin{equation}\label{MCMC_prob_2}
\tilde{p}_{\sigma}=\frac{1}{\tilde{Z}'}p_{\sigma}e^{\eta_{\sigma}}, \quad \tilde{Z}'=\sum_{\sigma}p_{\sigma}e^{\eta_{\sigma}},
\end{equation}
where note that $p_{\sigma}$ is the `true' probability of the system being in state $\sigma$. From the above it can be seen that if 
$\eta_{\sigma}>0$ then state $\sigma$ is \emph{over-sampled} relative to the true distribution. On the other hand if $\eta_{\sigma}<0$ then 
$\sigma$ is \emph{under-sampled}. 
The strength of this approach is that, through judicious choice of the weight function, one can `choose' the path the system traverses 
through phase space. To elaborate, a multicanonical Monte Carlo simulation can be regarded as a canonical Monte Carlo 
simulation, but if the energy for each state $\sigma$ were 
\begin{equation}
\tilde{\mathcal{E}}_{\sigma}=\mathcal{E}_{\sigma}-\eta_{\sigma}/\beta
\end{equation}
instead of $\mathcal{E}_{\sigma}$. Hence a multicanonical Monte Carlo simulation samples states with probabilities corresponding to, say, an NVT ensemble,
but if energy were $\tilde{\mathcal{E}}_{\sigma}$ instead of $E_{\sigma}$. Noting that since the modification to the `true' energy function, 
$-\eta_{\sigma}/\beta$, is proportional to the weight function, it can be seen that the weight function defines an additional `force' on the system 
which affects its trajectory through phase space. Therefore by choosing $\eta_{\sigma}$, one can choose the system's path through phase space. 

Of course, in a multicanonical simulation the states are not longer sampled with probabilities corresponding to the true ensemble in question -- 
which \emph{is} the case for canonical Monte Carlo. Accordingly the time average of some physical quantity $X$ throughout a long multicanonical 
Monte Carlo simulation is not equivalent to the equilibrium value of $X$ for the true ensemble, like it is in a canonical Monte Carlo
simulation. Nevertheless one can obtain the equilibrium value of $X$ from a multicanonical simulation by exploiting the fact that, since the 
weight function is known, then so is the degree of over- or under-sampling of each state. To elaborate, to evaluate the equilibrium value of 
$X$ in a Metropolis Monte Carlo simulation, we use the following expression:
\begin{equation}
\langle X\rangle\approx\frac{1}{\tau}\sum_{t=1}^{\tau}X(t),
\end{equation}
where $X(t)$ denotes the value of the physical quantity $X$ at timestep $t$ of the simulation, and $\tau$ denotes the total number of timesteps.
For reasons which will become clear in a moment, $\langle X\rangle$ could equivalently be expressed as
\begin{equation}
\langle X\rangle\approx\frac{\displaystyle\sum_{t=1}^{\tau}w(t)X(t)}{\displaystyle\sum_{t=1}^{\tau}w(t)}
\end{equation}
with $w(t)$ taking the same constant value for all $t$, where $w(t)$ is the \emph{weight} (not to be confused with the weight function) associated 
with the state at timestep $t$.
Now, Eqn. \eqref{MCMC_prob_2} reveals that state $\sigma$ is sampled in a multicanonical Monte Carlo simulation a factor of
$e^{\eta_{\sigma}}/\tilde{Z}'$ more often than for the true ensemble. Associating a weight $(e^{\eta_{\sigma}}/\tilde{Z}')^{-1}$ to $\sigma$ corrects for
this; the effect is that states which are over-sampled are counted less, and under-sampled states are counted more, in the evaluation of $\langle X\rangle$.
Hence the expression for $\langle X\rangle$ pertaining to a multicanonical simulation is the same as above, but with $w(t)=(e^{\eta(t)}/\tilde{Z}')^{-1}$:
\begin{equation}\label{equilX_MCMC}
\langle X\rangle\approx\frac{\displaystyle\sum_{t=1}^{\tau}e^{-\eta(t)}X(t)}{\displaystyle\sum_{t=1}^{\tau}e^{-\eta(t)}},
\end{equation}
where we have canceled the factors of $\tilde{Z}'^{-1}$ from the numerator and denominator.


\section{Exploiting multicaonical Monte Carlo}
How does multicanonical Monte Carlo resolve the problem that lattice switch moves are too rarely accepted to be useful? To answer this question we must 
first understand why lattice switches are so rarely accepted. 
Consider the probability of a lattice switch from state $\sigma$ to $\sigma'$ being accepted. Using the lattice switch scheme implemented in
\emph{monteswitch}, and described in Sec. \ref{sec:lattice_switch}, this is
\begin{equation}\label{p_LSMC_NPT}
p_{\sigma\to\sigma'}=\text{max}\Bigl[1,e^{\beta(H_{\sigma'}-H_{\sigma})+\ln(V_{\sigma'}/V_{\sigma})}\Bigr],
\end{equation}
where recall that $H_{\sigma}=E_{\sigma}+PV_{\sigma}$ denotes the enthalpy of state $\sigma$, and $V_{\sigma}$ denotes its volume. Consider first the
case where the lattice switch preserves the volume of the system. This is necessary for the NVT ensemble, but in the NPT ensemble one has freedom to
define the switch such that it changes the volume of the system. In this case, since $V_{\sigma'}=V_{\sigma}$, the above equation reduces to
\begin{equation}\label{p_LSMC_NVT}
p_{\sigma\to\sigma'}=\text{max}\Bigl[1,e^{\beta(E_{\sigma'}-E_{\sigma})}\Bigr].
\end{equation}
This equation reveals the main cause for lattice switches being unsuccessful: the energy of the trial state $\sigma'$ generated by a 
lattice switch is almost always of much higher energy than the current state $\sigma$, leading to $p_{\sigma\to\sigma'}$ being very low. 
This is perhaps obvious in retrospect: one should expect that,
from a state which is probable at equilibrium, which accordingly will have a relatively low energy, a large change to the system, such as that 
brought about by a lattice switch, will typically lead to a huge increase in the system's energy. 
%
There are, however, (hopefully) a small number of states `close' to those found at equilibrium for each phase from which a lattice switch yields a 
trial state $\sigma'$ which is of comparable energy to $\sigma$. From such states a lattice switch has a good chance of being accepted.
We refer to such states as \emph{gateway states}, since they provide the key to jumping between both phases. It is these states which we wish to over-sample,
and we set the weight function accordingly. The idea is that by over-sampling these states, lattice switches are accepted reasonably often, 
enabling both phases to be explored in a reasonable simulation time. This in turn allows us to determine
$t_1$ and $t_2$ (which recall are the time averages of $\theta_1$ and $\theta_2$ defined earlier, i.e. $t_1=\langle\theta_1\rangle$ and 
$t_2=\langle\theta_2\rangle$) via Eqn. \eqref{equilX_MCMC}, and hence ultimately $\Delta \mathcal{F}$ via Eqn. \eqref{DeltaF_stat_mech}.

But how does the above discussion change for lattice switches which alter the volume of the system? The answer is `not much'. For the
case of volume-preserving lattice switches a gateway state is a state from which a lattice switch yields another state of comparable energy.
This reflects the fact that $p_{\sigma\to\sigma'}\approx 1$ if $E_{\sigma'}\approx E_{\sigma}$ in Eqn. \eqref{p_LSMC_NVT}. For the general case of a
non-volume-preserving lattice switch the analogous condition for a gateway state, as can be seen from Eqn. \eqref{p_LSMC_NPT}, is that
$J_{\sigma}\approx J_{\sigma'}$, where
\begin{equation}
J_{\sigma}\equiv H_{\sigma}+\ln(V_{\sigma})/\beta.
\end{equation}
Note that for the case of volume-preserving lattice switches the condition $J_{\sigma}\approx J_{\sigma'}$ is equivalent to $E_{\sigma}\approx E_{\sigma'}$.

With the above in mind, how should the weight function be engineered such that gateway states are over-sampled? 
Consider a state $\sigma$, and let $\sigma'$ denote the state which results from a lattice switch performed from $\sigma$. Let us define the 
state-dependent quantity
\begin{equation}\label{M_def}
M_{\sigma}=
\begin{cases}
(J_{\sigma}-J_{\sigma'}) & \text{if $\sigma$ belongs to phase 1} \\
-(J_{\sigma}-J_{\sigma'}) & \text{if $\sigma$ belongs to phase 2}.
\end{cases}
\end{equation}
This quantity in practice provides a means for resolving gateway states, states corresponding to equilibrium (for the true ensemble under consideration)
for phase 1, and states corresponding to equilibrium for phase 2. Accordingly we refer to $M$ as the `order parameter'. Consider first gateway states.
Above we illustrated that gateway states correspond to the condition $J_{\sigma}\approx J_{\sigma'}$. As can be seen from the above this corresponds to
states with $M_{\sigma}\approx 0$. By contrast, if $|M_{\sigma}|\gg 0$, then the two states have significantly different values of $J$. In this case, while
switching from the state with the higher value of $J$ to that with the lower value of $J$ is guaranteed, the converse is not: the two states are not 
concordant with switching \emph{to and from} both phases. $|M_{\sigma}|$ therefore provides a measure of how `un-gateway-like' state $\sigma$ is, with 
zero corresponding to `very gateway-like'. 
Consider now phase-1-equilibrium states. From such states we generally expect a lattice switch to be unsuccessful, and hence
$J_{\sigma'}\gg J_{\sigma}$. Therefore for such states $M_{\sigma}\ll 0$. Finally consider phase-2-equilibrium states. Similarly we generally expect 
a lattice switch from such states to be unsuccessful, and hence $J_{\sigma'}\gg J_{\sigma}$. However this time $M_{\sigma}\gg 0$. We therefore have three regimes:
$M_{\sigma}\ll 0$ corresponds to phase-1-equilibrium states; $M_{\sigma}\approx 0$ corresponds to gateway states; and $M_{\sigma}\gg 0$ corresponds to 
phase-2-equilibrium states.

With this in mind, if we choose the weight function $\eta_{\sigma}$ to take the same value $\eta_{M}$ 
for all states with the same $M$, and also choose $\eta_{M}$ to be peaked at $M=0$ and to decay monotonically with 
$|M|$, then the weight function corresponds to a `force' which drives the system towards gateway states, allowing the system to transition between
the phase-1 and phase-2 regions of phase space, corresponding to $M\ll 0$ and $M\gg 0$ respectively, in a reasonable simulation time.
This is, of course, just a \emph{qualitative} description of a form for $\eta_{M}$ which is sufficient for our purposes. As one might expect, 
the quantitative details of the weight function $\eta_{M}$ strongly affect the efficiency of the path traversed though phase space with regards 
to calculating $\Delta \mathcal{F}$; a `bad' weight function might result in the system getting stuck in one phase, or an unimportant region of phase 
space, for a long time. Furthermore, it is not obvious \emph{a priori} what a suitable weight function for a given system should be. Hence one must 
\emph{generate} a weight function which leads to an efficient sampling of phase space. After this \emph{weight function generation simulation},
the resulting weight function can be used in a \emph{production simulation} to calculate $\Delta \mathcal{F}$ as described earlier.

Given that we are constraining the weight function to take the same value for all states with the same $M$, it is convenient to define a
macrostate, which we also denote as $M$, which is comprised of all such states. Thus in implementing multicanonical Monte Carlo
in the computer, it is sufficient to store the value of the weight function for each $M$ considered, instead of for each state -- which is
intractable. Of course, it is impossible to treat $M$ as a continuous variable in the computer; in reality the considered range of $M$ will
be split into $N_{\text{macro}}$ bins each corresponding to a range of $M$. Furthermore only a finite range of $M$ can be considered: one must
decide upon a suitable maximum and minimum for the problem at hand. Each bin itself corresponds to a macrostate: the macrostate is the
collection of states corresponding to the range of $M$ covered by the bin. We will henceforth explicitly take the discretisation of $M$ into
account. Let $\mathcal{M}$ denote the macrostate corresponding to the $\mathcal{M}$th bin, where $\mathcal{M}=1,2,\dotsc,N_{\text{macro}}$.
Accordingly let $\eta_{\mathcal{M}}$ denote the weight function for macrostate $\mathcal{M}$. 


\section{Weight function generation}\label{sec:weight_generation}
We will now describe how weight functions can be generated for use in a production simulation.
In multicanonical Monte Carlo the `ideal' weight function, which we denote as $\eta_{\mathcal{M}}^*$, is regarded as that which leads to 
all macrostates within the considered order parameter range to be sampled with equal probability in the multicanonical Monte Carlo simulation.
Let $\tilde{p}_{\mathcal{M}}$ denote the probability that the multicanonical Monte Carlo simulation is in macrostate $\mathcal{M}$; formally,
\begin{equation}
\tilde{p}_{\mathcal{M}}=\sum_{\sigma\in\mathcal{M}}\tilde{p}_{\sigma}.
\end{equation}
Thus $\eta_{\mathcal{M}}^*$ would yield $\tilde{p}_{\mathcal{M}}=C$ for all $\mathcal{M}$ within the allowed range, where $C$ is some constant.
$\eta^*_{\mathcal{M}}$, or at least a close estimate of it, can be determined using various methods; below we 
describe the methods supported by \emph{monteswitch}. 
However we emphasise that strictly speaking it is unnecessary to use the ideal weight function, which samples all macrostates with exactly equal 
probablility, during the
production simulation. The choice of weight function affects the accuracy of physical quantities determined during the production simulation
(evaluated using Eqn. \eqref{equilX_MCMC}) only in that it determines the efficiency with which phase space is explored. For this reason though a
weight function close to the ideal is desirable because it is a convenient way of ensuring that gateway states are visited often, hence 
allowing both phases to be explored regularly: a weight function which is `far from ideal' may not result in gateway states being visited often
enough to enable useful estimates of $t_1$ and $t_2$ to be obtained. However, using the latter weight function would enable useful estimates 
for $t_1$ and $t_2$ to be obtained \emph{eventually}.

\subsection{Visited states method}\label{sec:visited_states}
The \emph{visited states method} (see Ref. \cite{Smith_1995} and references therein) is arguably the simplest method for generating the weight function. 
In this method, the simulation consists of a number of
`blocks', which themselves consist of a large number of Monte Carlo sweeps. Multicanonical sampling is used throughout, and the weight function is updated at
the end of each block. The weight function is different -- closer to the ideal -- in each subsequent block, and information
collected during each block is used to inform the weight function to be used in the next block. Eventually the weight function converges on the 
ideal: it provides a `flat' macrostate histogram; the weight function is such that all macrostates are sampled with equal probability.

Let $H^{(n)}_{\mathcal{M}}$ denote the number of states belonging to macrostate $\mathcal{M}$ which were visited during block $n$.
The specific equation used to obtain the weight function for the next block $n+1$ is
\begin{equation}
\eta^{(n+1)}_{\mathcal{M}}=\eta^{(n)}_{\mathcal{M}}-\ln\Biggl\lbrace
\frac{H^{(n)}_{\mathcal{M}}+1}{\sum_{\mathcal{M}'}\bigl(H^{(n)}_{\mathcal{M}'}+1\bigr)}
\Biggr\rbrace
+k,
\end{equation}
where $\eta^{(n)}_{\mathcal{M}}$ denotes the weight function for block $n$; the summation over $\mathcal{M}'$ on the denominator of the fraction is
over all macrostates $1,2,\dotsc,N_{\text{macro}}$; and $k$ is an inconsequential arbitrary constant, which we choose such that the minimum value of 
$\eta^{(n+1)}_{\mathcal{M}}$ over all $\mathcal{M}$ is 0.
\footnote{Like energies, only differences in the values of the weight function between states are `physically significant'; the absolute values 
of the weight function are not. Hence performing a global shift to the weight function for our own convenience is inconsequential to the
multicanonical distribution $\tilde{p}_{\sigma}$. This can be seen by applying the transformation $\eta_{\sigma}\to\eta_{\sigma}+C$ to Eqn. \eqref{MCMC_prob},
where $C$ is ab arbitrary constant}
The above equation acts to enhance the value of the weight function for macrostates which have not been visited often during the previous block, and
diminish the weight function for macrostates which have been visited. Eventually the weight function is such that all macrostates are visited equally
often. 
With regards to the choice of initial weight function for the simulation, i.e., $\eta^{(0)}_{\mathcal{M}}$, we use $\eta^{(0)}_{\mathcal{M}}=1$
for all $\mathcal{M}$. 

In practice the visited states method converges to the ideal weight function very slowly, and is not amenable to parallelisation. 
For this reason we do not recommend that it is the sole method used to 
generate weight function with \emph{monteswitch}. We recommend that the other methods for generating weight functions described 
in a moment are used instead, at least at first. These other methods are much more efficient at obtaining a weight function close to the ideal. 
However, these methods, as implemented in \emph{monteswitch}, perhaps never converge on the ideal, while the visited states method does \cite{Smith_1995}. 
This limitation of the other methods is in practice probably
unimportant. As mentioned earlier, it is unnecessary to use the `exact' ideal weight function, just a weight function `close' to the ideal, which
these methods provide. Nevertheless the visited states method is included within \emph{monteswitch} in order that the exact ideal weight function can
be calculated if required, possibly after a weight function close to the ideal has already been obtained using the aforementioned faster methods.


\subsection{Transition matrix method}\label{sec:transition_matrix}
$\eta_{\mathcal{M}}^*$ can be related to $p_{\mathcal{M}}$, the \emph{canonical} probability of the system being in macrostate $\mathcal{M}$. (Multicanonical
quantities are signified by a `$\sim$'). Firstly, note that the multicanonical probability $\tilde{p}_{\mathcal{M}}$ of the system being in macrostate 
$\mathcal{M}$ given a weight function $\eta_{\mathcal{M}}$ is
\begin{equation}
\tilde{p}_{\mathcal{M}}\propto e^{\eta_{\mathcal{M}}}p_{\mathcal{M}}.
\end{equation}
This follows from Eqn. \eqref{MCMC_prob_2}: summing over all $\sigma\in\mathcal{M}$ on the left-hand expression, and recalling that 
$\eta_{\sigma}=\eta_{\mathcal{M}}$ for such $\sigma$. Applying the condition $\tilde{p}_{\mathcal{M}}=C$ for $\eta_{\mathcal{M}}=\eta_{\mathcal{M}}^*$ yields
\begin{equation}
C\propto e^{\eta^*_{\mathcal{M}}}p_{\mathcal{M}},
\end{equation}
which can be rearranged to give
\begin{equation}\label{ideal_wf}
\eta^*_{\mathcal{M}}=C'-\ln p_{\mathcal{M}},
\end{equation}
where $C'$ is a constant. Eqn. \eqref{ideal_wf} reveals that $\eta^*_{\mathcal{M}}$ can be derived from $p_{\mathcal{M}}$. $p_{\mathcal{M}}$ 
in turn can be determined from the \emph{macrostate transition probability matrix} $\mathcal{T}_{\mathcal{MM}'}$, which describes the probability that
the system, currently in macrostate $\mathcal{M}$, transitions to macrostate $\mathcal{M}'$ \emph{in the canonical ensemble}.
In the \emph{transition matrix method} \cite{Smith_1995,Fitzgerald_1999} we determine $\mathcal{T}_{\mathcal{MM}'}$, then use this to obtain
$p_{\mathcal{M}}$, and finally the ideal weight function $\eta_{\mathcal{M}}^*$ via Eqn. \eqref{ideal_wf}.

How do we determine $\mathcal{T}_{\mathcal{MM}'}$, and how do we obtain $p_{\mathcal{M}}$ from $\mathcal{T}_{\mathcal{MM}'}$? Let us first deal with how
$\mathcal{T}_{\mathcal{MM}'}$ is determined.
Surprisingly $\mathcal{T}_{\mathcal{MM}'}$, a canonical quantity, can be obtained from a simulation utilising canonical sampling, multicanonical sampling,
or even more exotic methods. Consider the case of canonical sampling first.
Here, $\mathcal{T}_{\mathcal{MM}'}$ can be determined in an intuitive manner as follows. During the simulation we keep track of the 
number of observed transitions between all pairs of macrostates, which we store in a matrix $H_{\mathcal{M}\mathcal{M}'}$ -- where $H_{\mathcal{M}\mathcal{M}'}$
denotes the number of observed transitions from macrostate $\mathcal{M}$ to macrostate $\mathcal{M}'$. We then use $H_{\mathcal{M}\mathcal{M}'}$ to obtain
an estimate for $\mathcal{T}_{\mathcal{M}\mathcal{M}'}$ via the equation
\begin{equation}\label{T_estimate}
\mathcal{T}_{\mathcal{M}\mathcal{M}'}\approx \frac{H_{\mathcal{M}\mathcal{M}'}+1}
{\displaystyle\sum_{\mathcal{M}^{\prime\prime}}\bigl(H_{\mathcal{M}\mathcal{M}^{\prime\prime}}+1\bigr)}.
\end{equation}
However, this procedure is never used in \emph{monteswitch} because the following superior alternative exists. Consider a trial state $\sigma'$ 
generated from $\sigma$ which, if accepted, would take the system from macrostate $\mathcal{M}$ to macrostate $\mathcal{M}'$, and let the probability 
of the move being accepted be $p_{\sigma\to\sigma'}$. Instead of performing the update $H_{\mathcal{M}\mathcal{M}'}\to H_{\mathcal{M}\mathcal{M}'}+1$ if the move is 
accepted and $H_{\mathcal{M}\mathcal{M}'}\to H_{\mathcal{M}\mathcal{M}'}$ if it is not, one can perform the update 
\begin{equation}
\begin{split}
H_{\mathcal{M}\mathcal{M}'}\to H_{\mathcal{M}\mathcal{M}'}+p_{\sigma\to\sigma'}, \\
H_{\mathcal{M}\mathcal{M}}\to H_{\mathcal{M}\mathcal{M}}+1-p_{\sigma\to\sigma'},
\end{split}
\end{equation} 
regardless of whether it is accepted or not. In this case $H_{\mathcal{M}\mathcal{M}'}$ is no longer the number of observed transitions from macrostate 
$\mathcal{M}$ to $\mathcal{M}'$, but is instead the number of \emph{inferred} transitions. 
In fact, as alluded to above, this procedure can be used in conjunction with a multicanonical simulation, so long as one bears in mind that
$p_{\sigma\to\sigma'}$ is the \emph{canonical} probability of transitioning from state $\sigma$ to $\sigma'$ -- a quantity which is trivial to calculate
during a multicanonical simulation.
Why would one wish to use multicanonical sampling instead of canonical sampling to obtain $\mathcal{T}_{\mathcal{MM}'}$, which after all is a canonical
quantity? If multicanonical sampling is used, while the canonical transition probability $p_{\sigma\to\sigma'}$ is used to update $H_{\mathcal{M}\mathcal{M}'}$
via the above equation, it is the multicanonical transition probability $\tilde{p}_{\sigma\to\sigma'}$, which depends on the weight functions of
$\sigma$ and $\sigma'$ ($\eta_{\mathcal{M}}$ and $\eta_{\mathcal{M}'}$ respectively), which is actually used to determine whether the move is accepted or not.
This is useful because canonical sampling alone may not be sufficient to explore the full range of macrostates $\mathcal{M}$, which is necessary to 
`fill up' the matrix $H_{\mathcal{M}\mathcal{M}'}$ and ultimately enable $\mathcal{T}_{\mathcal{M}\mathcal{M}'}$ to be calculated (Eqn. \eqref{T_estimate}). 
For instance, typically canonical sampling will never result in the macrostates containing gateway states being visited during a reasonable simulation
time.
One can take this idea further and even go beyond multicanonical sampling to sample phase space. We discuss methods for exploring the phase space
with the aim of determining $\mathcal{T}_{\mathcal{MM}'}$, and ultimately $\eta_{\mathcal{M}}^*$, in a moment.

Having determined  $\mathcal{T}_{\mathcal{MM}'}$, our task is to now calculate $p_{\mathcal{M}}$. It can be shown that the macrostates obey the following
detailed balance condition \cite{Smith_1995}:
\begin{equation}
\mathcal{T}_{\mathcal{M}'\mathcal{M}}p_{\mathcal{M}'}=\mathcal{T}_{\mathcal{MM}'}p_{\mathcal{M}}.
\end{equation}
Setting $\mathcal{M}'=\mathcal{M}+1$ and rearranging the above gives
\begin{equation}\label{shooting}
p_{(\mathcal{M}+1)}=\frac{\mathcal{T}_{\mathcal{M}(\mathcal{M}+1)}}{\mathcal{T}_{(\mathcal{M}+1)\mathcal{M}}}p_{\mathcal{M}}.
\end{equation}
Using this equation, $p_{\mathcal{M}}$ can be obtained from the matrix $\mathcal{T}_{\mathcal{M}\mathcal{M}'}$ via the following procedure.
Firstly, one chooses some arbitrary value for $p_1$. With this $p_2$ can be obtained from the above equation ($\mathcal{M}=1$ in Eqn. \eqref{shooting}). 
This in turn can be used to obtain $p_3$ ($\mathcal{M}=2$ in Eqn. \eqref{shooting}), which in turn can be used to obtain $p_4$, etc., until
$p_{N_{\text{macro}}}$ is obtained. Finally, one normalises the resulting function $p_{\mathcal{M}}$ such that
\begin{equation}
\sum_{\mathcal{M}=1}^{N_{\text{macro}}}p_{\mathcal{M}}=1,
\end{equation}
as is required. The final step is to use $p_{\mathcal{M}}$ to obtain an estimate for the ideal weight function. This is done simply by substituting 
$p_{\mathcal{M}}$ into Eqn. \eqref{ideal_wf}. The accuracy of the resulting ideal weight function depends on how good our statistics are with regards to
the matrix $H_{\mathcal{M}\mathcal{M}'}$ (specifically the elements in the diagonals immediately above and below the main diagonal), which is used to
estimate $\mathcal{T}_{\mathcal{M}\mathcal{M}'}$ via Eqn. \eqref{T_estimate}, and ultimately $\eta^*_{\mathcal{M}}$. 


\subsubsection{Methods for exploring phase space}
As alluded to above, since the updates to $H_{\mathcal{M}\mathcal{M}'}$ always use the canonical probabilities of transitioning between states, 
with the transition matrix method one can \emph{choose} how phase space is explored. Effectively the only constraint is that there is fast local 
equilibration within each macrostate. We will now describe the various methods which can be implemented in \emph{monteswitch}.

The first method is to use multicanonical sampling to explore phase space with an evolving weight function, where the weight function
at a given time is the current estimate for the ideal weight function derived from the current $H_{\mathcal{M}\mathcal{M}'}$ as described above.
This is the `natural' way of applying the transition state method.

The second method is to use what we refer to as \emph{artificial dynamics} to force the system to explore all macrostates in a reasonable amount of time. 
In this method, the system is first locked into a macrostate for a certain period of time. After that period of time has elapsed, the `barriers' preventing
the system from moving into an adjacent macrostate is moved such that the system is free to transition into an adjacent macrostate. Once this occurs,
the system is locked into this new macrostate, and the procedure starts again. There is of course the question of which adjacent macrostate to `open'
to the system. Assuming we are not in macrostate $\mathcal{M}=1$ or $N_{\text{macro}}$, then there are two options: $(\mathcal{M}+1)$ and $(\mathcal{M}-1)$.
In \emph{monteswitch} one can specify whether to select the new macrostate at random \cite{thesis:Jackson}, 
or whether to sweep through the macrostates systematically, e.g.,
to explore macrostates $3,4,5,\dotsc,(N_{\text{macro}}-1),N_{\text{macro}},(N_{\text{macro}}-1),\dotsc,3,2,1,2,3,\dotsc$. This method is faster than the `natural'
method just described because one does not have to wait for the weight function to evolve such that it pushes the system to explore macrostates which
are unlikely to be visited in the canonical ensemble.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Preliminaries}\label{chapter:preliminaries}

\section{Compiling \emph{monteswitch}}
\emph{monteswitch} is provided as an archive. This should be extracted to create a directory which consitutes the \emph{monteswitch} package. The 
package should then be compiled using the Make utility: see the `README' section in the file \texttt{Makefile}, which contains details regarding how to
specify the Fortran and MPI compiler and any flags used during compilation, as well as how to compile only the serial (i.e., non-MPI) programs
if the user's platform does not contain MPI.
The default paths to the Fortran and MPI compilers in \texttt{Makefile} are \texttt{gfortran} and \texttt{mpif90} respectively; for platforms in which
these paths apply \emph{monteswitch} can be compiled `out of the box' by invoking the command 
\begin{verbatim}
$ make serial
\end{verbatim} 
(to compile only serial executables) or 
\begin{verbatim}
$ make mpi
\end{verbatim}
(to compile \emph{all} executables).


\section{Differences in \emph{monteswitch} between platforms and compilers}
\emph{monteswitch} has not yet been tested on many platforms, and hence there may be unforeseen problems when implementing \emph{monteswitch} on
the user's platform. We have overwhelmingly used GFortran and Open MPI compilers with \emph{monteswitch}; hence these compilers can be considered 
to be the most `safe'.

[***************************** NOTE ABOUT PLATFORM-DEPENDENCE OF SCRIPTS FOR SED AND AWK IN RUN.SH IN TESTS *************************]

One issue we have found with regards to using \emph{monteswitch} on different platforms stems from the fact that \emph{monteswitch} uses Fortran's 
list-directed input and output. This means the nature of the output from \emph{monteswitch} programs is noticeably compiler-dependent. This in itself
is not a problem, though the post-processing commands given in forthcoming chapters may need to be subtly modified to work with programs compiled using 
something other than GFortran.

\section{Package overview}
After compilation, the \emph{monteswitch} directory will contain the following programs:
\begin{itemize}
\item\texttt{monteswitch}
\item\texttt{monteswitch\_mpi}
\item\texttt{monteswitch\_post}
\item\texttt{lattices\_in\_hcp\_fcc}
\item\texttt{lattices\_in\_bcc\_fcc}
\item\texttt{lattices\_in\_bcc\_hcp}
\end{itemize}
\texttt{monteswitch} and \texttt{monteswitch\_mpi} are the key programs of the package: they perform Monte Carlo simulations. 
By contrast \texttt{monteswitch\_post}, \texttt{lattices\_in\_hcp\_fcc}, \texttt{lattices\_in\_bcc\_fcc} and 
\texttt{lattices\_in\_bcc\_hcp} are utility programs: \texttt{monteswitch\_post} is for post-processing one of the output files created 
by the main programs; and \texttt{lattices\_in\_hcp\_fcc}, \texttt{lattices\_in\_bcc\_fcc} and \texttt{lattices\_in\_bcc\_hcp} are for generating 
one of the input files for the main programs. We will elaborate upon the function of each of these programs later.

\subsection{Test cases and examples}
There are a number of subdirectories within the package. The directory \texttt{Tests} contains a suite of test cases for the main programs. 
Chapter \ref{chapter:tests} contains descriptions of the tests, including how to run each test and what results 
to expect. We recommend that the tests be performed by the user to ensure that the Monte Carlo programs, as compiled by their system, work
correctly. Furthermore, these tests are also instructive, providing examples of how to perform various tasks which the typical user would be 
interested in performing. Finally, the tests serve to validate the Monte Carlo programs by illustrating that they reproduce known results.

While the test cases serve as examples, more pedagogical examples can be found in the directory \texttt{Examples}, including the worked example
of Chapter \ref{chapter:example}.

\subsection{Plug-ins for various interatomic potentials}\label{sec:plugins}
The directory \texttt{Interactions} contains Fortran files corresponding to various interatomic potentials. However, only one of these can be implemented 
by \texttt{monteswitch} at a time. The module which is implemented is stored in the file \texttt{interactions.f95} in the main directory; it is only the 
contents of this file which is used in the package -- after compilation. Hence to implement a specific interatomic potential one must copy
the desired `\texttt{interactions\_} file' in \texttt{Interactions} to \texttt{interactions.f95}, and then (re-)compile the package.

Note that by default the \texttt{interactions.f95} is identical to the file \texttt{interactions\_EAM.f95}, and hence compiling \emph{monteswitch}
out-of-the-box yields a version which pertains to EAM potentials.

Further information regarding interatomic potentials is provided in Chapter \ref{chapter:interactions}.

\section{Source code documentation}
HTML documentation for the source code can be generated from `marked-up' comments in the source code files. Invoking the command 
\begin{verbatim}
$ make srcdocs
\end{verbatim}
generates this documentation: each HTML file corresponds to a particular source code file.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Monte Carlo simulation programs}\label{chapter:simulation_programs}
The key programs in the package are \texttt{monteswitch} and \texttt{monteswitch\_mpi}, which run (LSMC) Monte Carlo simulations. 
The latter is the MPI-parallelised analogue of the former, and the two programs are almost identical in terms of usage.
In this chapter we describe the usage of \texttt{monteswitch} in detail. Unless otherwise stated, the following information
is also pertinent to \texttt{monteswitch\_mpi}. Information specific to \texttt{monteswitch\_mpi} can be found in 
the final section of this chapter.

\section{Starting a new simulation: the argument \texttt{-new}}
There are three allowed command-line arguments to \texttt{monteswitch}: 
\begin{itemize}
\item\texttt{-new}
\item\texttt{-resume}
\item\texttt{-reset}
\end{itemize}
The command-line argument \texttt{-new} (Example usage: \texttt{monteswitch -new}) runs a new simulation. 
The simulation is initialised using information contained in input files located in the current directory. There are two input files
which are required for all simulations. These are \texttt{lattices\_in} and \texttt{params\_in}. 
The file \texttt{lattices\_in} contains specifications of two microstates. This file determines the two phases which will be 
considered, and defines the lattice switch which will be used in the simulation. The file \texttt{params\_in} contains the variables
which determine the nature of the simulation, except variables pertaining to the interatomic potentials, which are specified in an additional input
file (or possibly multiple files) whose nature depends on the specific version of \texttt{interactions.f95} used when compiling \emph{monteswitch} 
(see Section \ref{sec:plugins}).
We defer discussion of input files pertaining to the interatomic potentials to Chapter \ref{chapter:interactions}. We now describe
the format of the input files \texttt{lattices\_in} and \texttt{params\_in}.

\subsection{Input file: \texttt{lattices\_in}}\label{sec:lattices_in}
The input file \texttt{lattices\_in} contains specifications for two states (i.e., supercell dimensions and particle positions), one for
each phase. These two states are the reference states described in Section \ref{sec:lattice_switch}. Recall that they serve two purposes. Firstly,
they act as prospective initial state for the simulation: if the system is to be initialised in phase 1, then the phase-1 state will be used as 
the initial state, and similarly if the system is to be initialised in phase 2. Secondly they determine the nature of the lattice switch; see
Section \ref{sec:lattice_switch} for details.
The format of \texttt{lattices\_in} is as follows. The 1st line is a comment line, and is ignored by the main programs. The 2nd line contains
the number of particles $N$ in both phases (and must be the same for both phases). The 3rd, 4th and 5th lines contain the dimensions of the
supercell for phase 1 in the x-, y- and z-directions respectively. The next $N$ lines contain the species and positions of the particles within 
the supercell for phase 1 \emph{in fractional coordinates}: each line contains the fractional x-, y- and z-coordinates for the particle, followed 
by an integer which signifies its species. (A particle's species potentially determines how it interacts with other particles; \emph{monteswitch} 
allows different interatomic potentials between sets of particles belonging to different species. The specifics of this are determined by the file 
\texttt{interactions.f95} -- see Chapter \ref{chapter:interactions}). The remaining lines in \texttt{lattices\_in} similarly specify the state 
for phase 2: the next 3 lines contains the dimensions of the supercell for phase 2 in the x-, y- and z-directions respectively; and the next $N$ 
lines contain the fractional positions and species of the particles for phase 2.

Below is an example of a \texttt{lattices\_in} file corresponding to phase 1 being an 8-particle bcc supercell and phase 2 being an 8-particle hcp 
supercell, where the phase-1 state consists entirely of particles belonging to species `1'and the phase-2 state consists of a mixture of species `1'
and `2'. Further examples of \texttt{lattices\_in} files can be found in the \texttt{Tests} and \texttt{Examples} directories.
\begin{verbatim}
 bcc-hcp, rho = 0.5, nx,ny,nz = 1, 1, 2
   8
 2.2449241     
 1.5874012     
 4.4898482
   0.0000000   0.0000000   0.0000000   1
   0.5000000   0.5000000   0.0000000   1
   0.5000000   0.0000000   0.2500000   1
   0.0000000   0.5000000   0.2500000   1
   0.0000000   0.0000000   0.5000000   1
   0.5000000   0.5000000   0.5000000   1
   0.5000000   0.0000000   0.7500000   1
   0.0000000   0.5000000   0.7500000   1
 2.4494897     
 1.4142136     
 4.6188021     
   0.0000000   0.0000000   0.0000000   1
   0.5000000   0.5000000   0.0000000   2
   0.3333333   0.0000000   0.2500000   1
   0.8333333   0.5000000   0.2500000   2
   0.0000000   0.0000000   0.5000000   1
   0.5000000   0.5000000   0.5000000   2
   0.3333333   0.0000000   0.7500000   1
   0.8333333   0.5000000   0.7500000   2
\end{verbatim}
Bearing in mind our description of the lattice switch utilised in \emph{monteswitch} given in Section \ref{sec:lattice_switch}, it can be seen that
the above file results in the following lattice switch from phase 1 to 2:
\begin{itemize}
\item A scaling of the x-dimension of the supercell by a factor of $\mathcal{L}_x^{(2)}/\mathcal{L}_x^{(1)}=2.2449/2.2449=1$, i.e., not at all.
\item A scaling of the y-dimension of the supercell by a factor of $\mathcal{L}_y^{(2)}/\mathcal{L}_y^{(1)}=1.414/1.587=0.891$.
\item A scaling of the z-dimension of the supercell by a factor of $\mathcal{L}_z^{(2)}/\mathcal{L}_z^{(1)}=4.619/4.490=1.029$.
\item A transformation of the fractional position of the underlying lattice site for particle $i$ from the $i$th fractional position specified in the file
for phase 1 to the $i$th fractional position specified for phase 2. E.g. the underlying lattice site for particle 3 has its fractional position
$(0.5000000,0.0000000,0.2500000)$ transformed to $(0.3333333,0.0000000,0.2500000)$.
\item A transformation of the species of particles 2, 4, 6 and 8 from `1' to `2'.
\end{itemize}
The lattice switch from phase 2 to 1 is the inverse of the above transformation.


\subsection{Input file: \texttt{params\_in}}\label{section:params_in}
The input file \texttt{params\_in} contains the variables which determine the nature of the simulation. Each variable corresponds to a
specific single line in the file, and each line must consist of a string (we recommend the name of the variable followed immediately
by an `=' character with no spaces), followed by whitespace, followed by the value of the variable. The variables which must appear
in a \texttt{params\_in}, as well as a description of their function, are given in Table \ref{table:params_in_variables}. 
\emph{Note that the variables must appear in params\_in in the order that they appear in the table}. E.g., the first 
variable must be \textbf{init\_lattice}, the second must be \textbf{M\_grid\_size}, etc. Examples of \texttt{params\_in} files can
be found in the \texttt{Tests} and \texttt{Examples} directories, which can serve as templates for the user.
%
Note that by `move' we mean one of either a: particle move, in which one particle is moved to generate a trial microsate; a lattice move, in 
which the lattice is switched; and a volume move, in which the unit cell itself is altered. Furthermore if the move is rejected then it is 
still deemed to have taken place. For an NVT ensemble with lattice moves enabled the following move `cycle' is performed: particle move, 
lattice move. For an NPT ensemble with lattice moves enabled the move cycle is: particle move, lattice move, (volume move, lattice move), 
where the set of moves in the brackets occur on average \textbf{vol\_freq} times per sweep, where a `sweep' consists of $N$ move cycles,
where $N$ is the number of particles in the system.

\begin{landscape}
\begin{center}\label{table:params_in_variables}
\begin{longtable}{l l l p{8cm}}
\caption{Control variables for \texttt{monteswitch}, and descriptions of their functions. These variables must be specified in the \texttt{params\_in} file, 
one per line, in the order specified in the table. `Line' refers to the line number in \texttt{params\_in} on which the corresponding variable must appear.}
\\

Line & Variable & Type & Description \\
\hline
1 & \textbf{init\_lattice}  &  \texttt{INTEGER}  & Starting phase for the simulation (1 or 2). \\
2 & \textbf{M\_grid\_size}  &  \texttt{INTEGER}  & Number of macrostates to divide the considered order parameter range (\textbf{M\_grid\_min} to \textbf{M\_grid\_max})
into. \\
3 & \textbf{M\_grid\_min}  &  \texttt{REAL}  & Minimum of considered order parameter range. Note that moves which take the system outwith the considered range are
automatically rejected. In other words, the system is constrained to have an order parameter between \textbf{M\_grid\_min} and \textbf{M\_grid\_max}. Hence
if one wants to perform a simulation in which the order parameter is unconstrained, one should set \textbf{M\_grid\_min} and \textbf{M\_grid\_max} to
values which would never be realised by the system, e.g., $-1\times 10^{100}$ and $1\times 10^{100}$ respectively. This would be the case if one wishes
to use \texttt{monteswitch} to perform a conventional Monte Carlo simulation. \\
4 & \textbf{M\_grid\_max}  &  \texttt{REAL}  & Maximum of considered order parameter range. (See also comments for \textbf{M\_grid\_min})  \\
5 & \textbf{enable\_multicanonical}  &  \texttt{LOGICAL}  & \texttt{T} enables multicanonical sampling using the current weight function; \texttt{F} enables canonical sampling \\
6 & \textbf{beta}  &  \texttt{REAL}  & Thermodynamic beta.  \\
7 & \textbf{P}  &  \texttt{REAL}  & Pressure (only relevant in NPT ensemble simulations)  \\
8 & \textbf{enable\_lattice\_moves}  &  \texttt{LOGICAL}  & \texttt{T} enables lattice-switch moves (performed after evey particle and volume move). \\
9 & \textbf{enable\_part\_moves}  &  \texttt{LOGICAL}  & \texttt{T} enables particle moves. Of course this should be set to \texttt{T}; however disabling particle moves and 
enabling volume moves may be useful for `relaxing' the volume of the system before simulations with particle moves are performed. \\
10 & \textbf{enable\_vol\_moves}  &  \texttt{LOGICAL}  & \texttt{T} enables volume moves and selects the NPT ensemble; \texttt{F} selects the NVT ensemble. A volume move will be
attempted on average \textbf{vol\_freq} times per sweep. We recommend that this be set to 1. \\
11 & \textbf{part\_select}  &  \texttt{CHARACTER(30)}  & Flag determining how the next particle to move is selected: \texttt{cycle} selects particles sequentially, \texttt{rand} selects
particles at random.  \\
12 & \textbf{part\_step}  &  \texttt{REAL}  & Particle move maximum size; particles are moved according to a random walk, with a maximum move size of \textbf{part\_step}
in any Cartesian direction.  \\
13 & \textbf{enable\_COM\_frame}  &  \texttt{LOGICAL}  & \texttt{T} performs the simulation in the center-of-momentum reference frame; \texttt{F} uses the lab frame. Using the 
centre-of-momentum frame prevents `drift' in the centre-of-momentum. This is especially important for lattice-switch simulations. Hence this should be set 
to \texttt{T} unless the user has a very good reason not to. \\
14 & \textbf{vol\_dynamics}  &  \texttt{CHARACTER(30)}  & Flag determining which type of volume moves are performed: \texttt{FVM} (fixed volume move) keeps the supercell 
shape unchanged during a volume move; \texttt{UVM} (unconstrained volume move) allows the x-, y- and z-dimensions to move independently. Note that currently
lattice moves are forbidden in conjunction with unconstrained volume moves, though this may be relaxed in the future. \\
15 & \textbf{vol\_freq}  &  \texttt{INTEGER}  & Number of volume moves performed per sweep on average.  \\
16 & \textbf{vol\_step}  &  \texttt{REAL}  & Volume move maximum step size; the volume is moved according to a random walk in `$\ln(V)$-space', with a maximum move size 
of \textbf{vol\_step}.  \\
17 & \textbf{stop\_sweeps}  &  \texttt{INTEGER}  & Total number of sweeps to perform in the simulation. If this is set to 0 then no Monte Carlo moves are performed,
but tasks performed periodically during the Monte Carlo loop (i.e, updating the weight function, checking whether or not the system has melted, checking for
`divergences' in the energy, calculating equilibrium quantities and their uncertainties) are performed. \\
18 & \textbf{equil\_sweeps}  &  \texttt{INTEGER}  & Number of sweeps to disregard before the system is considered to be equilibrated; statistics are not gathered during
these sweeps. \\
19 & \textbf{enable\_melt\_checks}  &  \texttt{LOGICAL}  & \texttt{T} enables periodic checks of whether the system has `melted', i.e., if one or more of the particles has
moved more than a distance of \textbf{melt\_threshold} from its lattice site in any Cartesian direction then the system is considered to have `melted'.
We recommend that this feature is used, since the LSMC method relies upon the fact that the two phases under consideration are metastable,
and that particles will not move too far from their lattice sites on the timescale of the simulation. \\
20 & \textbf{melt\_sweeps}  &  \texttt{INTEGER}  & Period (sweeps) to check for melting.  \\
21 & \textbf{melt\_threshold}  &  \texttt{REAL}  & See \textbf{enable\_melt\_checks}.  \\
22 & \textbf{melt\_option}  &  \texttt{CHARACTER(30)}  & Flag determining what the simulation does if the system has `melted': \texttt{zero\_1} and \texttt{zero\_2} move the system 
to the zero-displacement microstates in phases 1 and 2, respectively; \texttt{zero\_current} does the same but for the current phase; \texttt{stop} stops the simulation
with an exit status of 2. For \texttt{zero\_1}, \texttt{zero\_2}, \texttt{zero\_current} the system is allowed to re-equilibrate before statistics are gathered. Also, the
current block with regards to the calculation of equilibrium quantities is disregarded. \\
23 & \textbf{enable\_divergence\_checks}  &  \texttt{LOGICAL}  & \texttt{T} enables periodic checks of whether the energy of the system is correct. To elaborate, for particle 
moves, the energy of the trial microstate is not calculated exactly because it is very computationally expensive and unnecessary. Instead the energy 
\emph{change} with respect to the current microstate is calculated. This is far less demanding to calculate. If the move is accepted this change is 
\emph{ammended} to the total energy. However, over time it is possible that this `running total' approach will yield incorrect energies due to the finite 
precision of the computer. Hence one should periodically recalculate the energy exactly. This is done during volume moves. If 
\textbf{enable\_divergence\_checks} is set to \texttt{T}, then this is also done every \textbf{divergence\_sweeps} sweeps, after which the recalculated energy 
is compared to the 'current' energy, and the simulation is stopped with an exit status of 3 if they are different -- outwith a tolerence of 
\textbf{divergence\_tol}. Note that the order parameter is also ammended after the energy (for phases 1 and 2) is recalculated. We recommend that this 
feature is used in NVT simulations, since it forces the energy of the system to be recalculated from scratch every so often. For NPT simulations this 
should not an issue since the energy is calculated from scratch every accepted volume move. \\
24 & \textbf{divergence\_sweeps}  &  \texttt{INTEGER}  & Period (sweeps) to check for `energy divergences' as just mentioned. Note that checking entails re-calculating
the energy from scratch.  \\
25 & \textbf{divergence\_tol}  &  \texttt{REAL}  & See \textbf{enable\_divergence\_checks}.  \\
26 & \textbf{output\_file\_period}  &  \texttt{INTEGER}  & Period (sweeps) at which information is output to the file \texttt{data}. See Section \ref{sec:output}. \\
27 & \textbf{output\_file\_Lx}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
28 & \textbf{output\_file\_Ly}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
29 & \textbf{output\_file\_Lz}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
30 & \textbf{output\_file\_V}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
31 & \textbf{output\_file\_R\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
32 & \textbf{output\_file\_R\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
33 & \textbf{output\_file\_u}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
34 & \textbf{output\_file\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
35 & \textbf{output\_file\_E}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
36 & \textbf{output\_file\_M}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
37 & \textbf{output\_file\_eta}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
38 & \textbf{output\_file\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
39 & \textbf{output\_file\_accepted\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
40 & \textbf{output\_file\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
41 & \textbf{output\_file\_accepted\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
42 & \textbf{output\_file\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
43 & \textbf{output\_file\_accepted\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
44 & \textbf{output\_file\_rejected\_moves\_M\_OOB}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
45 & \textbf{output\_file\_M\_OOB\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
46 & \textbf{output\_file\_M\_OOB\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
47 & \textbf{output\_file\_barrier\_macro\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
48 & \textbf{output\_file\_barrier\_macro\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
49 & \textbf{output\_file\_rejected\_moves\_M\_barrier}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
50 & \textbf{output\_file\_moves\_since\_lock}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
51 & \textbf{output\_file\_melts}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
52 & \textbf{output\_file\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
53 & \textbf{output\_file\_sigma\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
54 & \textbf{output\_file\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
55 & \textbf{output\_file\_sigma\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
56 & \textbf{output\_file\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
57 & \textbf{output\_file\_sigma\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
58 & \textbf{output\_file\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
59 & \textbf{output\_file\_sigma\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
60 & \textbf{output\_file\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
61 & \textbf{output\_file\_sigma\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
62 & \textbf{output\_file\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
63 & \textbf{output\_file\_sigma\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
64 & \textbf{output\_file\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
65 & \textbf{output\_file\_sigma\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
66 & \textbf{output\_file\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
67 & \textbf{output\_file\_sigma\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
68 & \textbf{output\_file\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
69 & \textbf{output\_file\_sigma\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
70 & \textbf{output\_stdout\_period}  &  \texttt{INTEGER}  & Period (sweeps) at which information is output to stdout. See Section \ref{sec:output}. \\
71 & \textbf{output\_stdout\_Lx}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
72 & \textbf{output\_stdout\_Ly}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
73 & \textbf{output\_stdout\_Lz}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
74 & \textbf{output\_stdout\_V}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
75 & \textbf{output\_stdout\_R\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
76 & \textbf{output\_stdout\_R\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
77 & \textbf{output\_stdout\_u}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
78 & \textbf{output\_stdout\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
79 & \textbf{output\_stdout\_E}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
80 & \textbf{output\_stdout\_M}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
81 & \textbf{output\_stdout\_eta}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
82 & \textbf{output\_stdout\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
83 & \textbf{output\_stdout\_accepted\_moves\_lattice}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
84 & \textbf{output\_stdout\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
85 & \textbf{output\_stdout\_accepted\_moves\_part}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
86 & \textbf{output\_stdout\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
87 & \textbf{output\_stdout\_accepted\_moves\_vol}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
88 & \textbf{output\_stdout\_rejected\_moves\_M\_OOB}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
89 & \textbf{output\_stdout\_M\_OOB\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
90 & \textbf{output\_stdout\_M\_OOB\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
91 & \textbf{output\_stdout\_barrier\_macro\_low}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
92 & \textbf{output\_stdout\_barrier\_macro\_high}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
93 & \textbf{output\_stdout\_rejected\_moves\_M\_barrier}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
94 & \textbf{output\_stdout\_moves\_since\_lock}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
95 & \textbf{output\_stdout\_melts}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
96 & \textbf{output\_stdout\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
97 & \textbf{output\_stdout\_sigma\_equil\_DeltaF}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
98 & \textbf{output\_stdout\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
99 & \textbf{output\_stdout\_sigma\_equil\_H\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
100 & \textbf{output\_stdout\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
101 & \textbf{output\_stdout\_sigma\_equil\_H\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
102 & \textbf{output\_stdout\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
103 & \textbf{output\_stdout\_sigma\_equil\_V\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
104 & \textbf{output\_stdout\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
105 & \textbf{output\_stdout\_sigma\_equil\_V\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
106 & \textbf{output\_stdout\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
107 & \textbf{output\_stdout\_sigma\_equil\_umsd\_1}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
108 & \textbf{output\_stdout\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
109 & \textbf{output\_stdout\_sigma\_equil\_umsd\_2}  &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
110 & \textbf{output\_stdout\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
111 & \textbf{output\_stdout\_sigma\_equil\_L\_1} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
112 & \textbf{output\_stdout\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
113 & \textbf{output\_stdout\_sigma\_equil\_L\_2} &  \texttt{LOGICAL}  & See Section \ref{sec:output}. \\
114 & \textbf{checkpoint\_period}  &  \texttt{INTEGER}  & Period (sweeps) at which the simulation is checkpointed, i.e., how often all simulation variables are
output to the file \texttt{state}. If \textbf{checkpoint\_period} is $\leq 0$ then \texttt{state} will be an empty file. See Section \ref{sec:output}. \\
115 & \textbf{update\_eta}  &  \texttt{LOGICAL}  & \texttt{T} results in the weight function being periodically updated every \textbf{update\_eta\_sweeps} sweeps, according
to the method specified in \textbf{update\_eta\_method}; \texttt{F} results in the weight function not being updated -- it remains frozen at its current state.  \\
116 & \textbf{update\_eta\_sweeps}  &  \texttt{INTEGER}  & Period (seeps) at which the weight function is updated. \\
117 & \textbf{update\_trans}  &  \texttt{LOGICAL}  & \texttt{T} results in the transition matrix being updated; \texttt{F} results in it not being updated.  \\
118 & \textbf{update\_eta\_method}  &  \texttt{CHARACTER(30)}  & Method used to update the weight function: \texttt{VS} uses the visited states method; \texttt{shooting} uses the
shooting method (using the current transition matrix). ELABORATE.  \\
119 & \textbf{enable\_barriers}  &  \texttt{LOGICAL}  & \texttt{T} enables artificial dynamics; for \texttt{F} the system is free to explore any macrostate, but is constrained to
reside within the considered order parameter range (\textbf{M\_grid\_min} to \textbf{M\_grid\_max}).  \\
120 & \textbf{barrier\_dynamics}  &  \texttt{CHARACTER(30)}  & Flag determining how the macrostate barriers will evolve during artificial dynamics. 
All methods lock the system into a single
macrostate for \textbf{lock\_moves} moves, before unlocking an adjacent macrostate. Once the system has moved into the adjacent macrostate, the system
is then locked into that macrostate, and the procedure starts again. \texttt{random} evolves the macrostate the system is locked into via a random walk: the
next macrostate is decided with equal probability to be that above or that below the current macrostate. \texttt{pong\_up} moves to increasingly higher 
macrostates until the upper limit of the supported order parameter range is encountered, at which point it reverses direction and proceeds to 
increasingly lower macrostates until it reaches the lower limit of the order parameter range, at which point it reverses direction, etc. \texttt{pong\_down}
instead moves initially to increasingly lower macrostates.  \\
121 & \textbf{lock\_moves}  &  \texttt{INTEGER}  & The number of moves to lock the system into one macrostate for if artificial dynamics is used. 
This should be greater than 0. \\
122 & \textbf{calc\_equil\_properties}  &  \texttt{LOGICAL}  & \texttt{T} enables calculation of equilibrium quantities using block analysis. ELABORATE.  \\
123 & \textbf{block\_sweeps}  &  \texttt{INTEGER}  & The number of sweeps which comprise a 'block' which will be used to evaluate equilibrium properties and
their uncertainties as just described. This should be greater than 0. \\
\end{longtable}
\end{center}
\end{landscape}


\section{Output: stdout, \texttt{state} and \texttt{data}}\label{sec:output}
During a simulation,information is periodically output to stdout and the file \texttt{data}. The variables with names beginning with 
\textbf{output\_file\_} and \textbf{output\_stdout\_} determine which variables are output to \texttt{data} and stdout respectively.
The variable \textbf{output\_file\_X}, where \textbf{X} is the name of a simulation variable (a list is given below), when set to \texttt{T}, 
will result in a line consisting of \texttt{X: } followed by the number of completed sweeps, followed by the current value of \textbf{X} 
being printed to \texttt{data} every \textbf{output\_file\_period} sweeps. However, if \textbf{output\_file\_period} is set to 0, then instead 
the output is after every move; and if \textbf{output\_file\_period} is a negative integer, then there is no output to the file, i.e., the
output is suppressed. The above also applies to \textbf{output\_stdout\_X}, but for the output to stdout. 
The only exceptions to the aforedescribed significance of variables beginning with \textbf{output\_file\_} and \textbf{output\_stdout\_}
are \textbf{output\_file\_eta} and \textbf{output\_stdout\_eta}. For these quantities \textbf{eta} refers to the
value of the weight function \emph{for the current microstate} -- as opposed to the entire weight function. This point is reiterated below.
Note that there is no internal variable named \textbf{eta} in \verb|monteswitch|: the entire weight function is refered to as \textbf{eta\_grid}
in \verb|monteswitch|; \textbf{eta} is calculated on-the-fly when required from \textbf{eta\_grid} and never stored in memory.

The file \texttt{data} can be used to deduce how the system evolves with time during the simulation. For instance, one can use the information contained 
within \texttt{data} to check whether or not the system has equilibrated within a certain number of Monte Carlo sweeps. In a production simulation it
can also be used to store the `observations' performed on the system, which could be used in subsequent analysis.

In addition to \texttt{data}, a file \texttt{state} is also created by the program periodically throughout a simulation. This file contains all of the 
simulation variables, and can be used to `resume' the simulation by running \texttt{monteswitch} with the \texttt{-resume} or \texttt{-reset} argument
(see Sections \ref{sec:resume} and \ref{sec:reset}), or to extract the `results' of the simulation, e.g., equilibrium quantities, the current weight 
function, the number of accepted vs. rejected Monte Carlo moves of a certain type -- perhaps using the \texttt{monteswitch\_post} program 
(see Section \ref{sec:monteswitch_post}).
The variable \textbf{checkpoint\_period} determines how often the simulation is checkpointed: a file \texttt{state} is created every 
\textbf{checkpoint\_period} sweeps. It is also \emph{always} created at the completion of the program. Note that if \textbf{checkpoint\_period} is $\leq 0$, 
then there is no output to \texttt{state}, i.e., the file will be empty.
In the \texttt{state} file, similarly to \texttt{params\_in}, each line corresponds to a particular variable: for variable $X$ the corresponding line contains
\texttt{X=} followed by the value of that variable. The relevant line can be extracted from \texttt{state} using the utility \texttt{grep}. E.g. the command
\begin{verbatim}
$ grep "E=" state
\end{verbatim}
can be used to extract the current energy of the system from \texttt{state}.
Note that \texttt{state} contains \emph{all} the simulation variables, including those
pertaining to the interatomic potential. Hence the format of \texttt{state} depends on the details of the \texttt{interactions.f95} file. However,
all variables pertaining to the interatomic potential are stored at the end of \texttt{state}. Hence the format of \texttt{state} files down to the
point where the variables pertaining to the interatomic potential are stored is universal.

Table \ref{table:state_variables} contains a list of \texttt{monteswitch} internal variables, not already covered by Table \ref{table:params_in_variables},
which have corresponding \textbf{output\_file\_} or \textbf{output\_stdout\_} flags, or can be found in \texttt{state} and could possibly be of interest
to the user. Note that there are other variables in \texttt{state} which are not mentioned in Tables \ref{table:params_in_variables} or 
\ref{table:state_variables} -- aside from those stemming from \texttt{interactions.f95}. We do not mention them because these are not likely to be of
interest to the user; for more information see the HTML documentation for \texttt{monteswitch\_mod.f95}.
Note that the internal variable names output in \texttt{state} are case-sensitive, and exactly reflect the names given in Tables 
\ref{table:params_in_variables} and \ref{table:state_variables}.

\begin{landscape}
\begin{center}\label{table:state_variables}
\begin{longtable}{ l l p{8cm}}
\caption{Useful variables found in the file \texttt{state}.}
\\

Variable & Fortran type & Description \\
\hline
\textbf{n\_part} & \texttt{INTEGER} & Number of particles in the system. \\
\textbf{Lx} & \texttt{REAL(2)} & Dimension of supercells in x-direction: the first value pertains to phase 1 while the second pertains to phase 2.\\
\textbf{Ly} & \texttt{REAL(2)} & Dimension of supercells in y-direction: the first value pertains to phase 1 while the second pertains to phase 2.\\
\textbf{Lz} & \texttt{REAL(2)} & Dimension of supercells in z-direction: the first value pertains to phase 1 while the second pertains to phase 2.\\
\textbf{V} & \texttt{REAL} & Current volume of the system.\\
\textbf{lattice} & \texttt{INTEGER} & Current phase of the system (1 or 2).\\
\textbf{E\_1} & \texttt{REAL} & Energy of phase 1 for the current displacements. \\
\textbf{E\_2} & \texttt{REAL} & Energy of phase 2 for the current displacements. \\
\textbf{E} & \texttt{REAL} & Current energy of the system. This is \textbf{E\_1} if we are in phase 1 and \textbf{E\_2} if we are in phase 2.\\
\textbf{M} & \texttt{REAL} & Current order parameter of the system.\\
\textbf{switchscalex} & \texttt{REAL} & Scaling of the supercell in the x-dimension when performing a lattice switch from phase 1 to phase 2. The 
reciprocal of this is the scaling when performing a lattice switch from phase 2 to phase 1.\\
\textbf{switchscaley} & \texttt{REAL} & Scaling of the supercell in the x-dimension when performing a lattice switch from phase 1 to phase 2. The 
reciprocal of this is the scaling when performing a lattice switch from phase 2 to phase 1. \\
\textbf{switchscalez} & \texttt{REAL} & Scaling of the supercell in the x-dimension when performing a lattice switch from phase 1 to phase 2. The 
reciprocal of this is the scaling when performing a lattice switch from phase 2 to phase 1. \\
\textbf{sweeps} & \texttt{INTEGER} & Number of sweeps performed so far, including over previous simulations if we have used the \texttt{-resume} argument.\\
\textbf{moves} & \texttt{INTEGER} & Total number of moves performed so far in total, including over previous simulations if we have used the \texttt{-resume} 
argument.\\
\textbf{moves\_lattice} & \texttt{INTEGER} & Number of lattice moves performed so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{accepted\_moves\_lattice} & \texttt{INTEGER} & Number of accepted lattice moves so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{moves\_part} & \texttt{INTEGER} & Number of particle moves performed so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{accepted\_moves\_part} & \texttt{INTEGER} & Number of accepted particle moves so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{moves\_vol} &\texttt{INTEGER} & Number of volume moves performed so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{accepted\_moves\_vol} & \texttt{INTEGER} & Number of accepted volume moves so far, including over previous simulations if we have used the 
 \texttt{-resume} argument.\\
\textbf{rejected\_moves\_M\_OOB} & \texttt{INTEGER} & Number of moves rejected because the order parameter of the trial state was outwith the considered range 
(`OOB' means `out of bounds'), i.e., \textbf{M\_grid\_min} to \textbf{M\_grid\_max}.\\
\textbf{M\_OOB\_high} & \texttt{INTEGER} & The highest order parameter value to be rejected because the order parameter of the trial state was outwith the 
considered range.\\
\textbf{M\_OOB\_low} & \texttt{INTEGER} & The lowest order parameter value to be rejected because the order parameter of the trial state was outwith the considered 
range.\\
\textbf{melts} & \texttt{INTEGER} & The number of times the system has melted. \\
\textbf{barrier\_macro\_low} & \texttt{INTEGER} & The macrostate number corresponding to the lowest currently allowed macrostate (relevant only when artificial
dynamics is enabled). \\
\textbf{barrier\_macro\_high} & \texttt{INTEGER} & The macrostate number corresponding to the highest currently allowed macrostate (relevant only when artificial
dynamics is enabled). \\
\textbf{rejected\_moves\_M\_barrier} & \texttt{INTEGER} & The number of moves rejected because the order parameter of the trial state was outwith the range
corresponding to the macrostate barriers (relevant only when artificial dynamics is enabled).\\
\textbf{block\_counts} & \texttt{INTEGER} & The total number of `blocks' considered so far for evaluating equilibrium quantities and their uncertainties.  \\
\textbf{equil\_DeltaF} & \texttt{REAL} & The free energy difference between the phases ($F_1-F_2$; extensive) evaluated using block analysis.\\
\textbf{sigma\_equil\_DeltaF} & \texttt{REAL} & The uncertainty in \textbf{equil\_DeltaF}.\\
\textbf{block\_counts\_DeltaF} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_DeltaF} and \textbf{sigma\_equil\_DeltaF}. Note that
blocks are disregarded if during the block the system melts, or if the system does not visit both phases. \\
\textbf{equil\_H\_1} & \texttt{REAL} & The energy (for NVT simulations) or enthalpy (for NPT simulations) of phase 1 evaluated using block analysis.\\
\textbf{equil\_H\_2} & \texttt{REAL} & The energy (for NVT simulations) or enthalpy (for NPT simulations) of phase 2 evaluated using block analysis.\\
\textbf{sigma\_equil\_H\_1} & \texttt{REAL} & The uncertainty in \textbf{equil\_H\_1}.\\
\textbf{sigma\_equil\_H\_2} & \texttt{REAL} & The uncertainty in \textbf{equil\_H\_2}.\\
\textbf{block\_counts\_H\_1} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_H\_1} and \textbf{sigma\_equil\_H\_1}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{block\_counts\_H\_2} & \texttt{INTEGER} &  The number of blocks used in evaluating \textbf{equil\_H\_2} and \textbf{sigma\_equil\_H\_2}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{equil\_V\_1} & \texttt{REAL} & The volume of phase 1 evaluated using block analysis.\\
\textbf{equil\_V\_2} & \texttt{REAL} & The volume of phase 2 evaluated using block analysis.\\
\textbf{sigma\_equil\_V\_1} & \texttt{REAL} &  The uncertainty in \textbf{equil\_V\_1}.\\
\textbf{sigma\_equil\_V\_2} & \texttt{REAL} &  The uncertainty in \textbf{equil\_V\_2}.\\
\textbf{block\_counts\_V\_1} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_V\_1} and \textbf{sigma\_equil\_V\_1}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{block\_counts\_V\_2} & \texttt{INTEGER} &  The number of blocks used in evaluating \textbf{equil\_V\_2} and \textbf{sigma\_equil\_V\_2}. Note that blocks are
disregarded if during the block the system melts. \\
\textbf{block\_counts\_umsd\_1} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_umsd\_1} and \textbf{sigma\_equil\_umsd\_1}. 
Note that blocks are disregarded if during the block the system melts. \\
\textbf{block\_counts\_umsd\_2} & \texttt{INTEGER} & The number of blocks used in evaluating \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2}. 
Note that blocks are disregarded if during the block the system melts. \\
\textbf{R\_1} & \texttt{REAL(n\_part,3)} & The current lattice vectors for phase 1. \\
\textbf{R\_2} & \texttt{REAL(n\_part,3)} & The current lattice vectors for phase 2.\\
\textbf{u} & \texttt{REAL(n\_part,3)} & The current displacement vectors.\\
\textbf{M\_grid} & \texttt{REAL(M\_grid\_size)} & Array containing the minimum order parameter for each macrostate: macrostate $n$ corresponds to 
order parameters between \textbf{M\_grid}$(n)$ and \textbf{M\_grid}$(n+1)$.\\
\textbf{M\_counts\_1} & \texttt{INTEGER(M\_grid\_size)} & \textbf{M\_counts\_1}($n$) is the number of times macrostate $n$ has been visited while the
system was in phase 1 so far, including over previous simulations if we have used the \texttt{-resume} argument.\\
\textbf{M\_counts\_2} & \texttt{INTEGER(M\_grid\_size)} & \textbf{M\_counts\_2}($n$) is the number of times macrostate $n$ has been visited while the
system was in phase 2 so far, including over previous simulations if we have used the \texttt{-resume} argument. \\
\textbf{eta\_grid} & \texttt{REAL(M\_grid\_size)} & \textbf{eta\_grid}($n$) is the value o the weight function for macrostate $n$. \\
\textbf{trans} & \texttt{REAL(M\_grid\_size,M\_grid\_size)} & \textbf{eta\_grid}($m,n$) is the number of inferred transitions from macrostate
$m$ to macrostate $n$; it is the matrix $H_{\mathcal{M}\mathcal{M}'}$ in Section \ref{sec:transition_matrix}. \\
\textbf{equil\_umsd\_1} & \texttt{REAL(n\_part)} & \textbf{equil\_umsd\_1}($n$) is the mean-squared displacement of particle $n$ from its lattice site
in phase 1, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{equil\_umsd\_2} & \texttt{REAL(n\_part)} & \textbf{equil\_umsd\_2}($n$) is the mean-squared displacement of particle $n$ from its lattice site
in phase 2, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{sigma\_equil\_umsd\_1} & \texttt{REAL(n\_part)} & \textbf{sigma\_equil\_umsd\_1}($n$) is the uncertainty in \textbf{equil\_umsd\_1}($n$). \\
\textbf{sigma\_equil\_umsd\_2} & \texttt{REAL(n\_part)} & \textbf{sigma\_equil\_umsd\_2}($n$) is the uncertainty in \textbf{equil\_umsd\_2}($n$). \\

\textbf{equil\_L\_1} & \texttt{REAL(3)} & The 1st, 2nd and 3rd values in the array \textbf{equil\_L\_1} are the mean x-, y- and z-dimensions of the
supercell in phase 1, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{equil\_L\_2} & \texttt{REAL(3)} &  The 1st, 2nd and 3rd values in the array \textbf{equil\_L\_2} are the mean x-, y- and z-dimensions of the
supercell in phase 2, evaluated using block analysis. Note that blocks are disregarded if during the block the system melts. \\
\textbf{sigma\_equil\_L\_1} & \texttt{REAL(3)} & \textbf{sigma\_equil\_L\_1}($n$) is the uncertainty in \textbf{equil\_L\_1}($n$). \\
\textbf{sigma\_equil\_L\_2} & \texttt{REAL(3)} & \textbf{sigma\_equil\_L\_2}($n$) is the uncertainty in \textbf{equil\_L\_2}($n$). \\
\end{longtable}
\end{center}
\end{landscape}


\section{Resuming a simulation: the argument \texttt{-resume}}\label{sec:resume}
The command-line argument \texttt{-resume} continues an `old' simulation, whose variables are contained in the file \texttt{state} in the current 
directory. The `resumed' simulation is run for the number of Monte Carlo sweeps specified in the variable \textbf{stop\_sweeps} in \texttt{state}.
By default this is the number of sweeps which were performed in the old simulation, though one of course this can be manually altered if one wants
the resumed simulation to be of a different length to the old simulation.

For a simulation invoked using the argument \texttt{-resume}, the file \texttt{data} is ammended: the resumed simulation does not overwrite the
\texttt{data} file; all information from the old simulation is retained in it.

\section{`Resetting' a simulation: the argument \texttt{-reset}}\label{sec:reset}
The command-line argument \texttt{-reset} invokes a simulation from an old \texttt{state} file similarly to \texttt{-resume}, except that it
resets all `counter variables' to zero. This has the effect of starting a `new' simulation whose nature corresponds to the old simulation, 
but instead uses the microstate of the system specified in \texttt{state}. By contrast, the command-line argument \texttt{-new} initialises the 
microstate to be such that the particles form a perfect crystal lattice, which usually does not correspond to an equilibrated microstate.
By `counter variables' we mean those such as variables describing the number of moves performed for each move type, the number of accepted moves 
for each move type, and variables pertaining to equilibrium quantities. However, note that the weight function (\textbf{eta\_grid}) and the
collection transition matrix (\textbf{trans}) are \emph{not} regarded as counter variables, and are as such retained from the old simulation
if one uses the \texttt{-reset} argument.

Note that for a simulation invoked using the argument \texttt{-reset}, the file \texttt{data} is overwritten, i.e., the information from the `old'
simulation is not retained.

\section{Exit statuses}
\texttt{monteswitch} exits with a non-zero exit status of 1 for most errors. However, if the system has melted, and \textbf{melt\_option} is set to
`stop', then the exit status is 2, and if the energy has diverged from its true value then the exit status is 3. 
Note though that exit statuses are not part of the Fortran standard, and may not work for all operating systems or compilers. 

\section{MPI simulations: \texttt{monteswitch\_mpi}}
As mentioned at the beginning of this chapter, the program \texttt{monteswitch\_mpi} is the MPI-parallelised analogue of \texttt{monteswitch}. 
It is identical to the program \texttt{monteswitch}, except that instead of a single simulation for \textbf{stop\_sweeps} Monte Carlo sweeps, 
\texttt{monteswitch\_mpi} runs $n$ simulations -- replicas -- in parallel using MPI, each being approximately \textbf{stop\_sweeps}$/n$ sweeps in 
length. Accordingly, during the simulation multiple \texttt{data}- and \texttt{state}-format files are created -- one for each replica. These 
are named \texttt{state\_0}, \texttt{state\_1}, \texttt{state\_2}, etc., and similarly for the \texttt{data}-format files. At the completion of 
all replicas, the statistics from all are combined, and the results are stored in the file \texttt{state}. The microstate stored in state
corresponds to the microstate in \texttt{state\_0}. 
Note that, since \texttt{state}-format files can be large, by default the files \texttt{state\_0}, \texttt{state\_1}, 
\texttt{state\_2}, etc. created by \texttt{monteswitch\_mpi} are empty. This can be disabled if \texttt{-explicit} is used as the second command line 
argument to \texttt{monteswitch\_mpi}, e.g., \texttt{mpiexec -n 4 monteswitch\_mpi -new -explicit}. Similar applies to the arguments \texttt{-resume} and 
\texttt{-reset}.

Further details of the parallelisation are as follows. All replicas are always initialised to be in the same microstate. For a new simulation this is 
determined by the \textbf{init\_lattice} variable in \texttt{params\_in} similarly to \texttt{monteswitch}. For a resumed simulation this is the microstate 
contained in the \texttt{state} file from which the simulation is to be resumed. We emphasise that \emph{all replicas of the system are initialised with 
the same microstate} when the \texttt{-resume} argument is used with \texttt{monteswitch\_mpi}. In future we hope to allow `true' checkpointing 
whereby a simulation picks up exactly where it left off , i.e., by having the $n$th replica initialised from the file \texttt{state\_}$n$ instead of having
all replicas initialised from \texttt{state}, and to ammend \texttt{data\_}$n$ with information pertaining to replica $n$ during the resumed
simulation. Note that the files \texttt{data\_}$n$ are thus always overwritten by \texttt{monteswitch\_mpi} when the \texttt{-resume} argument is
invoked since, given the nature of the parallelisation, there is no continuity between the replicas in subsequent simulations. The excpetion is replica `0',
whose microstate is always stored in the file \texttt{state}, as well as \texttt{state\_0}.

To expand upon what was just said, in a resumed simulation, only replica 0 -- the `master' replica -- inherits the counter variables from the previous 
simulation via the file \texttt{state}. All other replicas have counter variables initialised to zero at the start of the resumed simulation.
During the simulation, the counter variables for each replica are of course ammended according to the evolution of the replica. Once all replicas have
completed their allocated number of sweeps, the variables for the $n$th replica are exported to the file \texttt{state\_}$n$. Then 
the counter variables of all replicas, other than replica 0, are summed and ammended to replica 0. At the end of the simulation replica 0 thus has
variables which corresponding to an evolution of, if there are $N$ tasks, approximately \textbf{stop\_sweeps}$/N$ sweeps from the starting state, 
but with counter variables which correspond to \textbf{stop\_sweeps} sweeps worth of information. The variables in replica 0 are then updated to reflect 
its new counters, e.g., the weight function is recalculated using the information from the new counters. Finally, the variables are
exported to the file \texttt{state}. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interatomic potentials}\label{chapter:interactions}
As mentioned in Chapter \ref{chapter:preliminaries}, the file \texttt{interactions.f95} determines the interatomic potential implemented by
\emph{monteswitch}. The \texttt{Interactions} directory contains files which correspond to a number of interatomic potentials. For example, copying
\texttt{interactions\_LJ.f95} to \texttt{interactions.f95} in the main directory, and then (re-)compiling \emph{monteswitch}, results in a version 
of \emph{monteswitch} in which the particles interact via a Lennard-Jones potential. 
In this chapter we first describe these potentials, as well as the input files which must be used in conjunction with each potential in order to
specify the free parameters for the potential.
Then in Section \ref{sec:user_defined} we describe how users can write their own `\texttt{interactions\_}' files to implement their own potentials.

Note that most potentials included with \emph{monteswitch} are for single-species systems, and do not exploit the ability of \emph{monteswitch} to 
treat multicomponent systems. Furthermore, the potentials included with \emph{monteswitch} all use a single input file named \texttt{interactions\_in}
to specify the potential's free parameters. In time we expect more potentials to be added to \emph{monteswitch}. 

\section{Embedded atom model}
The file \texttt{interactions\_EAM.f95} implements the embedded atom model (EAM) \cite{Daw_1984}. Here the energy of the system 
is given by
\begin{equation}
E = \frac{1}{2}\sum_{i,j\neq i}\phi(r_{ij}) + \sum_iF(\rho_i),
\end{equation}
\begin{equation}
\rho_i=\sum_{j\neq i}\rho(r_{ij}),
\end{equation}
where $r_{ij}$ is the separation between particles $i$ and $j$, and $\phi$, $F$ and $\rho$ are functions which must be specified
and constitute the parametrisation of the EAM potential. If \texttt{interactions\_EAM.f95} is used then the \texttt{interactions\_in}
file must be a description of the potential in DYNAMO/LAMMPS `setfl' format. A file with this format is often indicated with the 
suffix `\texttt{.eam.alloy}', and a description of the format can be found at \url{http://lammps.sandia.gov/doc/pair\_eam.html}. 

Note that \texttt{interactions\_EAM.f95} currently only supports single-component systems, and hence \texttt{interactions\_in} must not correspond to a 
multicomponent system. An error is returned if this is the case. Furthermore, at initialisation three additional files are created by the
Monte Carlo programs in \emph{monteswitch} if \texttt{interactions\_EAM.f95} is used: \texttt{F.dat}, \texttt{rho.dat} and \texttt{rphi.dat}. 
\texttt{F.dat} and \texttt{rho.dat} contain plots of the functions $F$ and $\rho$ read from \texttt{interactions\_in}, while 
\texttt{rphi.dat} contains a plot of $r\times\phi(r)$ vs. $r$ read from \texttt{interactions\_in}. 

By default \texttt{interactions.f95} is the same as \texttt{interactions\_EAM.f95}.

\section{Analytical pair potentials [TOO MANY!]}\label{section:pair_potentials}
Table \ref{table:pair_potentials} gives a list of analytical (as opposed to tabulated) 
pair potentials included with \emph{monteswitch}, and the name of the corresponding
\texttt{interactions\_} file in \texttt{Interactions}. All of these potentials are implemented in the same way.
Firstly, the pair potential $\phi(r)$ is assumed to be 0 for inter-particle separations $r$ greater than some cut-off distance $r_{\text{c}}$. In other
words the potential is \emph{truncated} at $r_{\text{c}}$.
Secondly, only pairs of particles within a distance $r_{\text{list}}$ of each other \emph{in the reference states of the simulation} interact
with each other throughout the entire simulation. To elaborate, a list of particles which particle $i$ interacts with in phase $p$ is created at 
the start of a simulation. This list consists of all those particles which are initially within distance $r_{\text{list}}$ of $i$ in the reference
state for phase $p$. Note that \emph{monteswitch} stores two sets of lists, one for each phase, and hence it is possible that particle $i$ interacts
with different sets of particles in different phases. We emphasise that the same same cut-off $r_{\text{list}}$ is used for both phases.
To clarify the difference between $r_{\text{c}}$ and $r_{\text{list}}$: the former is the distance at which the potential is truncated, while
the latter determines which pairs of particles `see each other' throughout the simulation. Normally one would set $r_{\text{c}}>r_{\text{list}}$.

The format of the \texttt{interactions\_in} files for these potentials is similar to \texttt{params\_in} described in Section \ref{section:params_in}:
each variable which parametrises the potential corresponds to a specific line in \texttt{interactions\_in}, and each line must contain a string
(we recommend the name of the variable followed immediately by an `=' character with no spaces), followed by whitespace, followed by the value
of the variable. The final column of Table \ref{table:pair_potentials} gives the order of variables as they should appear, one per line, in
\texttt{interactions\_in} for each potential. In this column the names of the variables are those used by \emph{monteswitch}, as opposed to those
used in the preceding mathematical expression for the potential $\phi(r)$. Where it is not obvious to which variable in the mathematical expression
a variable in the last column relates, the analogous variable in the mathematical expression is given in parenthesis immediately after it. In all
cases the variables \textbf{cutoff} and \textbf{list\_cutoff} correspond to $r_{\text{c}}$ and $r_{\text{list}}$ described above. 
%
\textbf{list\_size} is the size of the array which stores the list of particles which any particle in the system interacts with. For particle $i$,
the list includes all particles within $r_{\text{list}}$ of particle $i$, \emph{including particle $i$ itself}, in the reference state for phase $p$. All
of these particles are stored in the array. However for technical reasons the array must have at least one additional element. Thus
\textbf{list\_size} should be at least the largest number of particles within $r_{\text{list}}$ of any particle $i$ (including $i$ itself) over the
reference states for both phases, +1. 

To illustrate the above, here is an example \texttt{interactions\_in} file for the Lennard-Jones potential (\texttt{interactions\_LJ.f95}):
\begin{verbatim}
lj_epsilon= 1.0
lj_sigma= 1.0
lj_cutoff= 1.5
list_cutoff= 1.000000001
list_size= 14
\end{verbatim}
This file is designed for a LSMC simulation in which phase 1 is hcp and phase 2 is fcc, both with nearest neighbour distance $r_{\text{nn}}=1.0$, in
which we wish only nearest neighbours to interact with each other interact via a Lennard-Jones potential with $\epsilon=\sigma=1$ truncated at
distance $r_{\text{c}}=1.5$. We have specified that only nearest neighbours ever interact by setting \textbf{list\_cutoff} to be just above 
the nearest neighbour distance. Furthermore we have set \textbf{list\_size} to 14 because there are 12 nearest neighbours of any particle, 
which means that there are 13 particles within a distance $r_{\text{nn}}$ of any particle $i$ including particle $i$ itself, and, as mentioned above, 
we must add 1 to this for technical reasons. 
Note that 14 is the minimal value of \textbf{list\_size} suitable for this system. However one could set \textbf{list\_size} 
to be greater than 14. The result would be that the array which stores the list is larger than necessary, and accordingly some of the array would
remain `unused'. This becomes a problem if one sets \textbf{list\_size} to a massive value, resulting in the array taking up a lot of memory
unnecessarily.

\begin{landscape}
\begin{center}\label{table:pair_potentials}
\begin{longtable}{ l l l p{5cm} }
\caption{Pair potentials included with \emph{monteswitch}}
\\
Potential & File name & Expression for potential & Order of variables in \texttt{interactions\_in}  \\

\hline

12-10 & \texttt{interactions\_12-10.f95} & $\phi(r)=A/r^{12}-B/r^{10}$ 
& \textbf{A}, \textbf{B}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

12-6  &  \texttt{interactions\_12-6.f95} & $\phi(r)=A/r^{12}-B/r^{6}$ 
& \textbf{A}, \textbf{B}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Buckingham & \texttt{interactions\_Buckingham.f95} & $\phi(r)=A\exp(-r/\rho)-C/r^6$ 
& \textbf{A}, \textbf{rho}, \textbf{C}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Gaussian & \texttt{interactions\_Gaussian.f95} & $\phi(r)=-A\exp(-Br^2)$ 
& \textbf{A}, \textbf{B}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Lennard-Jones & \texttt{interactions\_LJ.f95} & $\phi(r)=\phi_{\text{LJ}}(r)=4\epsilon\bigl[(\sigma/r)^{12}-(\sigma/r)^6\bigr]$
& \textbf{lj\_epsilon} ($\epsilon$), \textbf{lj\_sigma} ($\sigma$), \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Lennard-Jones - shifted  & \texttt{interactions\_LJ\_shifted.f95} & $\phi(r)=\phi_{\text{LJ}}(r)-\phi_{\text{LJ}}(r_{\text{c}})$ 
& \textbf{lj\_epsilon} ($\epsilon$), \textbf{lj\_sigma} ($\sigma$), \textbf{lj\_cutoff} ($r_{\text{c}}$), \textbf{list\_cutoff}, \textbf{list\_size} \\

Lennard-Jones - 9-6 & \texttt{interactions\_LJ\_9-6.f95} & $\phi(r)=4\epsilon\bigl[(\sigma/r)^9-(\sigma/r)^6\bigr]$
& \textbf{lj\_epsilon} ($\epsilon$), \textbf{lj\_sigma} ($\sigma$), \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Morse & \texttt{interactions\_Morse.f95} & $\phi(r)=E_0\bigg\lbrace \Bigl[1-\exp\bigl(-k(r-r_0)\bigr)\Bigr]^2 -1 \biggr\rbrace$ 
& \textbf{E0}, \textbf{k}, \textbf{r0}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

$n$-$m$ & \texttt{interactions\_n-m.f95} & $\displaystyle\phi(r)=\bigl[E_0/(n-m)\bigr]\bigl[m(r_0/r)^n-n(r_0/r)^m\bigr]$
& \textbf{E0}, \textbf{npot} ($n$), \textbf{mpot} ($m$), \textbf{r0}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

Yukawa & \texttt{interactions\_Yukawa.f95} & $\phi(r)=A\exp(-kr)/r$ 
& \textbf{A}, \textbf{k}, \textbf{cutoff}, \textbf{list\_cutoff}, \textbf{list\_size} \\

\end{longtable}
\end{center}
\end{landscape}


\section{Hard/penetrable spheres}
There are two implementations of the penetrable (including hard) spheres model included with \emph{monteswitch}.
\texttt{interactions\_HS.f95} implements the penetrable spheres model for single-species systems only; while 
\texttt{interactions\_HS\_multi.f95} supports multiple-species systems. The latter file supercedes the former, but we retain
the former for legacy reasons: some of the test cases included with \emph{monteswitch} utilise \texttt{interactions\_HS.f95}.
We now describe both implementations.

\subsection{\texttt{interactions\_HS.f95}}
In \texttt{interactions\_HS.f95} the pair potential is given by
\begin{equation}
\phi(r)=
\begin{cases} 
\epsilon & \text{if }r<\sigma \\
0 & \text{otherwise},
\end{cases}
\end{equation}
where $\epsilon$ is the energy cost of a pair of spheres overlaping, and $\sigma$ is the diameter of the spheres.
The format for \texttt{interactions\_in} here, and the implementation of the potential, is similar to the analytical pair potentials 
described earlier in Section \ref{section:pair_potentials}; the order of variables as they should occur in \texttt{interactions\_in} 
is \textbf{epsilon}, \textbf{sigma}, \textbf{list\_cutoff}, then \textbf{list\_size}, where the significance of 
\textbf{list\_cutoff} and \textbf{list\_size} is the same as for the analytical pair potentials.

Note that hard spheres are realised in the limit $\beta\epsilon\to\infty$, where $\beta=1/(k_BT)$. Thus hard spheres can be modeled by 
setting either $\epsilon$ or $\beta$, or both, to a very high value. We recommend setting $\beta=1$ and $\epsilon=100000$ to realise
hard spheres. In this case $\epsilon$ is not so high that numerical issues occur,
but also not so small that moves which lead to overlapping spheres -- which are always possible unless $\epsilon$ is actually
$\infty$ -- are likely to happen during even a very long simulation.

It is noteworthy that the order parameter $M$ has a straightforward physical interpretation for penetrable spheres: if the system is
currently in phase 1(2) then $-(+)M/\epsilon$ is the number of overlapping spheres which result from performing a lattice switch from the 
current microstate. This is similar to the definition of $M$ used in the original LSMC papers (Refs. \cite{Bruce_1997,Bruce_2000}).

\subsection{\texttt{interactions\_HS\_multi.f95}}
In \texttt{interactions\_HS\_multi.f95} the sphere diameter is allowed to vary with species. Here, the pair potential between two particles
belonging to species $s$ and $t$ is given by
\begin{equation}
\phi_{st}(r)=
\begin{cases} 
\epsilon & \text{if }r<\frac{1}{2}(\sigma_s+\sigma_t) \\
0 & \text{otherwise},
\end{cases}
\end{equation}
where $\sigma_s$ denotes the diameter of spheres belonging to species $s$. The format of the \texttt{interactions\_in}
and the implementation of the potential is similar to \texttt{interactions\_HS.f95} described above, except an additional
\texttt{INTEGER} variable \textbf{n\_species} is introduced, which specifies the number of different species in the system,
and \textbf{sigma} is now a \texttt{REAL(n\_species)} array which contains the hard sphere diameters for each species. Note
that the $i$th value in \textbf{sigma} is the diameter for species $i$: the species labels range from 1 to 
\textbf{n\_species}, e.g., species '0' or '-2' are not used).
The order of variables as they should occur in \texttt{interactions\_in} is \textbf{epsilon}, \textbf{n\_species}, \textbf{sigma}, 
\textbf{list\_cutoff}, then \textbf{list\_size}.




\section{Other potentials included with \emph{monteswitch}}
Some other \texttt{interactions\_} files are included in the directory \texttt{Interactions}, namely \texttt{interactions\_EC.f95}, 
\texttt{interactions\_EC\_NPT.f95}, \texttt{interactions\_LJ\_hcp\_fcc.f95}, \texttt{interactions\_TEMPLATE\_pair.f95} and
\texttt{interactions\_TEMPLATE\_minimal.f95}. The last two of are templates to assist users in creating an \texttt{interactions.f95} 
files of their own design, and will be discussed in more detail in a moment. The other files correspond to potentials which we do not anticipate will
be of any interest to most users. These files were used to validate \emph{monteswitch} via test cases which are described in Chapter
\ref{chapter:tests}. Hence we do not describe them here. Interested parties should inspect the files themselves for further information,
as well as Chapter \ref{chapter:tests}.


\section{User-defined pair potentials}\label{sec:user_defined}
The file \texttt{interactions\_TEMPLATE\_pair.f95} is a template which can be used to easily create \texttt{interactions.f95} files for `new'
pair potentials. In fact this template was used to create the files for almost all of the potentials described in Section
\ref{section:pair_potentials}. Instructions are provided in the file regarding how the file should be modified to realise the user's potential
of interest. The resulting implementation of the potential, and the required format of the \texttt{interactions\_in} file, will be the same as described 
in Section \ref{section:pair_potentials}. Regarding the order in which the variables which parametrise the potential are read from 
\texttt{interactions\_in}, the user-defined variables are read first, and then the variables \textbf{cutoff}, \textbf{list\_cutoff}, 
\textbf{list\_size} are read.

Note that one is by no means limited to using \texttt{interactions\_TEMPLATE\_pair.f95} to create `analytical' pair potentials. For instance
piecewise pair potentials could be created from \texttt{interactions\_TEMPLATE\_pair.f95}, e.g., the soft sphere model:
\begin{equation}
\phi(r)=
\begin{cases} 
\epsilon(\sigma/r)^n & \text{if }r\leq\sigma \\
0 & \text{if }r>\sigma.
\end{cases}
\end{equation}


\section{General user-defined potentials}
The file \texttt{interactions\_TEMPLATE\_minimal.f95} is a template which can be built upon by users to implement their own potentials
in \emph{monteswitch}. The template includes empty Fortran procedures which must be filled in by the user. Comments within the template
act as a guide for the user, who may also find it useful to examine the \texttt{interactions\_} files included with \emph{monteswitch} in the 
\texttt{Interactions} directory as examples. The user is of course free to add their own functions and variables within their custom
\texttt{interactions\_} file. Furthermore they can use external Fortran modules in the usual manner. 
%
Note that there is no universal procedure for determining the separation between two particles in \emph{monteswitch}. Separations are
required only in that they are used to determine the energy of the system, something is within the remit of the file 
\texttt{interactions.f95}. Hence when making a custom \texttt{interactions\_} file it is up to the user to calculate the separations
between pairs of particles themselves, possibly by adding their own procedure which does this (which takes into account the periodic
boundary conditions). 

We emphasise that there is considerable flexibility with regards to potentials which can be implemented within an \texttt{interactions\_} file. 
Possibilities include different Hamiltonians for each phase, position-dependent `external' potentials, and many-body potentials.
However recall that \emph{monteswitch} is limited to `atomic' systems, i.e., particles cannot have rotational degrees of freedom.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Utility programs}\label{chapter:utility_programs}
In this chapter we describe the utility programs included in the package, which assist with post-processing of the data and the construction
of input files.

\section{Programs for generating \texttt{lattices\_in} files}
The programs \texttt{lattices\_in\_hcp\_fcc}, \texttt{lattices\_in\_bcc\_fcc} and \texttt{lattices\_in\_bcc\_hcp} generate \texttt{lattices\_in} 
files corresponding to, respectively, hcp--fcc, bcc--fcc and bcc--hcp pairs of phases.
Each program takes four arguments. The first is the density, i.e., the number of atoms per unit volume, of the pair of microstates to
construct. The second, third and fourth arguments are the integers which correspond
to the number of unit cells (described in a moment) which will be tiled in the x-, y- and z-directions respectively to construct the
supercell for each phase. The program outputs the text for the \texttt{lattices\_in} file to stdout. Hence one must redirect the output
to create the required \texttt{lattices\_in} file.
For example, to generate a \texttt{lattices\_in} file for hcp--fcc corresponding to a density of 0.25, consisting
of 2, 3 and 5 unit cells tiled in the z-, y-, and z-directions, the command is (assuming the \texttt{lattices\_in\_hcp\_fcc} executable
is in the current directory)
\begin{verbatim}
$ ./lattices\_in\_hcp\_fcc 0.5 2 3 5 > lattices\_in
\end{verbatim}
Note that the \texttt{lattices\_in} files created by these programs have the species of all particles set to `1'.

What follows is a description of the unit cells for each pair of phases for each program. More specific information regarding the unit
cells can be obtained by invoking the programs with `1' for the second, third and fourth arguments. 

\subsection{\texttt{lattices\_in\_hcp\_fcc}}
The unit cell here contains 12 atoms. The atoms are spread over 6 planes in the z-direction; each plane contains two atoms. The positions
of the atoms corresponds to a stacking sequence for the planes of ABCABC for the fcc unit cell, and  ABABAB for the hcp unit cell. 
Note that the unit cell is far longer in the z-directon than the x- and y-directions. Hence one should normally use more unit cells in 
the x- and y-directions than the z-direction to construct the supercells. In the output of this program lattice 1 corresponds to hcp and
lattice 2 corresponds to fcc.

\subsection{\texttt{lattices\_in\_bcc\_fcc}}
The unit cell here is the conventional 2-atom body-centred tetragonal (bct) unit cell; for the bcc(fcc) lattice the relative dimensions of 
the bct unit cell in each Cartesian direction correspond to the bct representation of the bcc(fcc) lattice. In the output of this program
lattice 1 corresponds to bcc and lattice 2 corresponds to fcc.

\subsection{\texttt{lattices\_in\_bcc\_hcp}}
The unit cell here contains 4 atoms. The bcc unit cell is the 4-atom face-centred tetragonal (fct) corresponding to the fct representation of 
the bcc lattice. The hcp unit cell is the `fct-like' representation of the hcp lattice. In the output of this program
lattice 1 corresponds to bcc and lattice 2 corresponds to hcp.


\section{Post-processing \texttt{state} files: \texttt{monteswitch\_post}}\label{sec:monteswitch_post}
\texttt{monteswitch\_post} is for post-processing a file \texttt{state} generated by \texttt{monteswitch} or \texttt{monteswitch\_mpi}, and can
be used to extract useful information from that file. The \texttt{state} file which the program operates on is that in the current directory.
The command-line arguments determine the task performed by the program, and are as follows.

\subsection{\texttt{-extract\_wf}}
Extract the weight function from \texttt{state} and output it to stdout. In the output the first token on each line is the order parameter, 
and the second is the corresponding value of the weight function.

\subsection{\texttt{-extract\_M\_counts}}
Extract order parameter histograms from \texttt{state} and output them to stdout. In the output the first token on each line is the order 
parameter, the second is the corresponding number of counts for lattice type 1, and the third is the corresponding number of counts for 
lattice type 2. 

\subsection{\texttt{-extract\_pos}}
Extract the current positions of the particles, and output them to stdout. In the output the first, second and third tokens on each line 
are the x-, y- and z-coordinates respectively for a particle. 

\subsection{\texttt{-extract\_R\_1}}
Extract the current positions of the lattice sites for lattice type 1, and output them to stdout. In the output the first, second and third 
tokens on each line are the x-, y- and z-coordinates respectively for a particle. 

\subsection{\texttt{-extract\_R\_2}}
Extract the current positions of the lattice sites for lattice type 2, and output them to stdout. In the output the first, second and third 
tokens on each line are the x-, y- and z-coordinates respectively for a particle.

\subsection{\texttt{-extract\_u}}
Extract the displacements of the particles, and output them to stdout. In the output the first, second and third tokens on each line are 
the x-, y- and z-displacements respectively for a particle. 

\subsection{\texttt{-calc\_rad\_dist bins}}
Calculate the radial distribution function, based on the current microstate, and output it to stdout. In the output, each line corresponds 
to a distance, which is the first token, and the second token contains the average number of particles at this distance from a particle. The 
output is like a histogram, with each line corresponding to a bin, the first token corresponding to the minimum of the range covered by the 
bin, and the second token corresponding to the number of counts for that bin. The range of the bin is inclusive at its minimum, and 
exclusive at its maximum. The upper distance considered for the radial distribution function is the lowest of $L_x/2$, $L_y/2$ and $L_z/2$,
where $L_x$ denotes the length of the current supercell in the x-direction, and similarly for $L_y$ and $L_z$; and the number of bins for 
the histogram is specified in the second argument \texttt{bins}. Note that the upper distance corresponds to the 'limit of periodicity' for the system. 

\subsection{\texttt{-merge\_trans} \texttt{state\_in\_1}  \texttt{state\_in\_2} \texttt{state\_out}}
Combine the \textbf{trans} matrices from the files \texttt{state\_in\_1} and \texttt{state\_in\_2}, and store the result in the 
file \texttt{state\_out}, where all variables in \texttt{state\_out} other than the matrix \textbf{trans} are inherited from 
\texttt{state\_in\_1}. Note that \textbf{M\_grid} must be the same for both input files (in which case the matrices \textbf{trans} for
each are of the same size). This argument can be used for pooling the results of multiple simulations which utilise the same underlying
`order parameter grid' \textbf{M\_grid}.

\subsection{\texttt{-extract\_lattices\_in vectors\_in\_1 vectors\_in\_2}}
Output the geometrical properties of the system in the format of a \texttt{lattices\_in} file. The arguments \texttt{vectors\_in\_1}
and \texttt{vectors\_in\_2} can be either \texttt{pos} or \texttt{R}. If \texttt{vectors\_in\_1} is \texttt{pos}, then
the positions of the particles in phase 1 of the forthcomning \texttt{lattices\_in} file will be the positions of the particles in phase 1
in the \texttt{state} file; if \texttt{vectors\_in\_1} is \texttt{R}, then the positions of the particles in phase 1 of the 
\texttt{lattices\_in} file will be the current lattice vectors (i.e., \textbf{R\_1}) corresponding to phase 1 in the \texttt{state} file.
Similar applies for \texttt{vectors\_in\_2} with phase 2.

\subsection{\texttt{-extract\_pos\_xyz}}
Extract the positions of the particles, and output them to stdout in `.xyz' format. In the output the first line contains the number of 
particles, the second line is a comment line, and the subsequent lines contain the particle positions and species: the first token is 
the `element' (set to `A' for species `1`, `B' for species 2, ..., `Z` for species 26, and `?` otherwise), and the second, third, 
fourth and fifth tokens are the x-, y- and z-coordinates respectively.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Worked example}\label{chapter:example}
We now provide a worked example to elucidate how the \emph{monteswitch} package as a whole can be used to solve a `real' problem.
Specifically, we use \emph{monteswitch} to calculate the Gibbs free energy difference $\Delta G$ between the bcc and hcp
phases of Zr, modeled using the EAM potential of Ref. \cite{Mendelev_2007}, at 1234K and 0 pressure. 
In our calculation we use artificial dynamics to quickly determine a reasonable weight function, and \texttt{monteswitch\_mpi} to
parallelise the calculations. Below we go through the entire procedure we used to obtain the free energy
difference. Of course, the procedure here will surely not be applicable to all problems, though it provides a good starting point. 
For this reason we try to anticipate problems that the user may encounter more generally, and provide remarks accordingly.

The example can be found in the \texttt{Examples/EAM\_Zr\_bcc\_hcp} directory of the \emph{monteswitch} package. Within 
\texttt{Examples/EAM\_Zr\_bcc\_hcp} there are a number of subdirectories which correspond to different simulations, all of which are 
necessary to obtain the free energy difference. The subdirectories are \texttt{bcc\_preliminary}, \texttt{hcp\_preliminary},
\texttt{weight\_function\_generation}, \texttt{weight\_function\_verification} and \texttt{production\_simulation}. We will describe the
purpose of the corresponding simulations in a moment. For now we wish to elaborate upon the contents of the subdirectories. Firstly, each 
subdirectory contains the input and output files for the corresponding simulation. Recall that the input files for `new' 
\texttt{monteswitch} and \texttt{monteswitch\_mpi} simulations (i.e., using the \texttt{-new} argument)
are \texttt{params\_in}, \texttt{interactions\_in} and \texttt{lattices\_in}, and that the output files are \texttt{state} and \texttt{data} 
for serial simulations (using the \texttt{monteswitch} program), and \texttt{data\_0}, \texttt{state\_0}, \texttt{data\_1}, \texttt{state\_1},
\texttt{data\_2}, \texttt{state\_2}, etc. and \texttt{state} for MPI simulations (using the \texttt{monteswitch\_mpi} program). Regarding the input
files, those for new simulations differ only in the \texttt{params\_in} files: the \texttt{interactions\_in} and \texttt{lattices\_in} files,
which define, respectively, the interatomic potential, and the phases and lattice switch, for a simulation, 
are the same for all simulations. Hence we have annotated the \texttt{params\_in} file corresponding to each simulation
to highlight the important variable choices. Recall that for resumed simulations (which use the \texttt{-resume} or \texttt{-reset} arguments)
an existing \texttt{state} file is the input file. To distinguish the input input state file from the state file output
by such simulations, we name the input file \texttt{state\_start}. To restate, in directories corresponding to resumed simulations,
\texttt{state\_start} is the input state file for the simulation, while \texttt{state} is the output state file.
Recall also that \texttt{monteswitch} and \texttt{monteswitch\_mpi} output information to stdout. 
In each subdirectory the file \texttt{stdout} contains a copy of the output to stdout -- if there is any. Finally, the 
subdirectories may contain other files (\texttt{.dat} files) which correspond to data obtained from post-processing. These files,
and how they were created, will be described.


\section{The \texttt{interactions\_in} and \texttt{lattices\_in} files}
Before performing any simulations, we must first construct the input files \texttt{interactions\_in} and \texttt{lattices\_in}
which specify, respectively, the interatomic potential, and pair of supercells we will use in all simulations. 
For the EAM version of monteswitch (which uses \texttt{interactions\_EAM.f95} as \texttt{interactions.f95} - which is the case by
default) the \texttt{interactions\_in} file must be a `setfl'-format description of the EAM potential of interest.
We wish to use the aforementioned Zr potential. It can be seen by inspecting the \texttt{interactions\_in} in the main
directory for the worked example that it (and the \texttt{interactions\_in} files in all subdirectories - they 
are all identical) corresponds to a `setfl'-format description of the aforementioned Zr potential - as required.

Consider now the \texttt{lattices\_in} file. Recall that this contains specifications of the supercells for both phases;
the atomic positions specified in \texttt{lattices\_in} define the crystal lattices which define each phase.
Given that we are considering the bcc and hcp phases, we can use the \texttt{lattices\_in\_bcc\_hcp} program to generate
a \texttt{lattices\_in} file, as opposed to creating it from scratch. We know the density of both phases is about
0.043\AA$^{-3}$ at the temperature under consideration. Hence we use this as the first argument to \texttt{lattices\_in\_bcc\_hcp}.
We generated  \texttt{lattices\_in} using the command
\begin{verbatim}
$ ../../lattices_in_bcc_hcp 0.042710367 4 6 4 > lattices_in
\end{verbatim}
Recall that the second, third and fourth arguments to \texttt{lattices\_in\_bcc\_hcp} give how many unit cells to tile in the
x-, y- and z-directions. As can be seen from inspection of the resulting \texttt{lattices\_in} file, a copy of which can be found in
the current directory, the above command yields a supercell of reasonable size (384 atoms), and supercell
dimensions which are greater than twice the cut-off of the EAM potential (which is 7.6\AA -- the last value on the second
line of \texttt{interactions\_in}) as is required to avoid finite size effects associated with `missing' neighbours.

\section{Preliminary simulations}
Now we turn to simulations. Before performing lattice-switch Monte Carlo simulations, it is necessary to first perform
preliminary conventional Monte Carlo simulations for each phase, bcc and hcp. The directories \texttt{bcc\_preliminary}
and \texttt{hcp\_preliminary} correspond to these simulations. The aim of these simulations is to determine:
\begin{enumerate}
\item the appropriate Monte Carlo maximum particle and volume move sizes;
\item an estimate for the equilibration time;
\item the appropriate range of order parameter to use in subsequent simulations.
\end{enumerate}

\subsection{\texttt{params\_in} files}
The salient features of the \texttt{params\_in} files for these simulations are as follows:
\begin{itemize}
\item \textbf{init\_lattice} = 1 for the bcc simulation and 2 for the hcp simulation, since in the \textbf{lattices\_in} file phase 1 corresponds to
  bcc and phase 2 corresponds to hcp.
\item \textbf{M\_grid\_min} and \textbf{M\_grid\_max} are set to extremely low and extremely high values respectively. This is necessary because
  the simulation automatically constrains the system such that its order parameter lies between \textbf{M\_grid\_min} and \textbf{M\_grid\_max};
  setting them to very low and high values respectively allows the system to have total freedom in order-parameter space --
  which is what we desire for a single phase conventional Monte Carlo simulation. This should always be done if one wishes
  to perform a conventional Monte Carlo simulation using monteswitch.
\item \textbf{enable\_multicanonical} and \textbf{enable\_lattice\_moves} are set to \texttt{F} for a conventional Monte Carlo simulation. Note that by
  disabling lattice switch moves the system is `locked in' to the phase in which it is initialised.
\item \textbf{enable\_vol\_moves} is set to \texttt{T}, in which case the simulation corresponds to the NPT ensemble. 
\item \textbf{part\_step} and \textbf{vol\_step} are the maximum particle and volume move sizes. One of the aims of the preliminary simulations is
  to determine a reasonable value for these variables. The values in the \texttt{params\_in} files are 0.3 and 0.03 respectively. These
  were obtained by trial and error. To elaborate, we started the simulation with a guess for these values, and examined the 
  information output to stdout as the simulation was running, specifically the total and accepted number of particle and 
  volume moves. If \textbf{part\_step} or \textbf{vol\_step} are too high then the number of accepted particle or volume moves will be very low 
  relative to the total number of moves; if they are too low then the number of accepted particle or volume moves will be close
  to the total number of moves. If either is the case we simply stopped the simulation, and restarted with a new informed guess for
  \textbf{part\_step} or \textbf{vol\_step}. The whole process does not take very long since it becomes obvious very quickly whether the acceptance
  rates are reasonable. In principle of course one could automate the process of determining the appropriate values of \textbf{part\_step}
  and \textbf{vol\_step}.
\item \textbf{stop\_sweeps} is set to 1000; the simulation will consist of 1000 sweeps, which is very short, though sufficient (in this system, though
  not in general) to obtain an estimate of 1), 2) and 3) described above. 
\item \textbf{output\_file\_period} is set to 1, which means information is output to the \texttt{data} file every sweep. Normally outputing information
  so frequently might be considered excessive, but we need such high resolution information regarding the time evolution of the simulation to 
  determine the equilibration time.
\item \textbf{output\_file\_V}, \textbf{output\_file\_E} and \textbf{output\_file\_V} are set to \texttt{T}: the system's volume, energy and order parameter 
  are periodically output 
  to the \texttt{data} file. We will use the first three quantities to determine the equilibration time; we will examine how the order parameter
  varies with time to obtain an idea of the range of order parameters exhibited by each phase at equilibrium, which in turn will inform the
  values of \textbf{M\_grid\_min} and \textbf{M\_grid\_max} to be used in subsequent simulations.
\item \textbf{output\_stdout\_period} is set to 10; information is output to stdout every 10 sweeps. The information we are interested in while the simulation
  is running, for reasons mentioned above, is the acceptance rates of the particle and volume moves for the chosen values of \textbf{part\_step} and 
  \textbf{vol\_step}.
  Accordingly we set \textbf{output\_stdout\_moves\_part}, \textbf{output\_stdout\_accepted\_moves\_part}, \textbf{output\_stdout\_moves\_vol} and 
  \textbf{output\_moves\_accepted\_moves\_vol} to \texttt{T}; with the corresponding variables one can calculate the acceptance rate for the chosen
  \textbf{part\_step} and \textbf{vol\_step} (acceptance rate = number of
  accepted moves / total moves)
\item Finally, \textbf{enable\_barriers} is set to \texttt{F}; otherwise artificial dynamics will be used - which we don't want.
\end{itemize}


\subsection{Running the simulations}
The simulation is run using the \texttt{-new} argument. Given that the simulation is short, it is unnecessary to use MPI: the \texttt{monteswitch} executable
should be used. The following command invokes the executable (from within the \texttt{Examples/EAM\_Zr\_bcc\_hcp/bcc\_preliminary} or 
\texttt{Examples/EAM\_Zr\_hcp\_preliminary} directories within the \texttt{monteswitch} package itself):
\begin{verbatim}
$ ../../../monteswitch -new
\end{verbatim}

\subsection{Estimating the (one-phase canonical) equilibration time}
One can post-process the file \texttt{data} to create a plot of the system's energy and volume vs. number of sweeps (i.e., simulation `time'):
\begin{verbatim}
$ grep 'E:' data | awk '{print $2,$3}' > E_vs_t.dat
$ grep 'V:' data | awk '{print $2,$3}' > V_vs_t.dat
\end{verbatim}
Plotting the files \texttt{E\_vs\_t.dat} and \texttt{V\_vs\_t.dat} reveals that the system equilibrates quickly: within 200 sweeps.

\subsection{Extracting the appropriate order parameter range}
One can create a plot of the order parameter $M$ vs. number of sweeps similarly to above:
\begin{verbatim}
$ grep 'M:' data | awk '{print $2,$3}' > M_vs_t.dat
\end{verbatim}
Plotting this file immediately gives an idea of the range of order parameters exhibitted at equilibrium for each phase. We see that for
bcc the exhibitted range is -62 to 20, and for hcp the range is 14 to 32. Hence the appropriate range of order parameters which encompasses
both phases is -62 to 32. We will use this in subsequent simulations.

Note that the system is constrained to be within the chosen order parameter range. It is therefore possible that imposing this artificial
constraint on the system could invalidate the results of the simulation. To avoid this, one should choose the maximum and minimum of the order
parameter range to be values which are `sufficiently unlikely to be realised at equilibrium so not to affect the results'. At this point it is
not clear whether this is the case for our chosen range. Fortunately we can check this \emph{a postiori} using the results of later simulations 
(see Section \ref{section:double_check} below). On the other hand the maximum and minimum should not be too far from what is likely to be 
encountered at equilibrium. 
Choosing too large an order parameter range lowers the efficiency of the forthcoming multicanonical simulation, or worse, it forces the system to 
visit `unnatural' states in the multicanonical system, causing the system to melt.

\section{Weight function generation simulations}\label{sec:example_generation}
The preliminary simulations have provided us with appropriate values for the maximum particle and volume move sizes, an estimate for
the equilibration time, and the range of order parameters which encompass both phases at equilibrium. With this information we can
now proceed to lattice-switch Monte Carlo simulations. The first such simulation is to generate the weight function. The directory
\texttt{weight\_function\_generation} corresponds to this simulation. We use the mobile barrier method. Furthermore, we use \texttt{monteswitch\_mpi}
to perform a parallelised calculation. Specifically we used 4 threads on a 4-core desktop machine. The following command was used
to invoke the simulation (from within the \texttt{Examples/weight\_function\_generation} within the \emph{monteswitch} package itself):
\begin{verbatim}
$ nohup mpiexec -n 4 ../../../monteswitch_mpi -new -explicit < 
/dev/null &
\end{verbatim}
This command is, of course, specific to our computing platform; one would have to ascertain the analogous command for other platforms. Note, however,
that we have used the \texttt{-explicit} argument to \texttt{monteswitch\_mpi}, which is necessary for storing the \texttt{data} and \texttt{state} 
files pertaining to each MPI thread.

\subsection{The \texttt{params\_in} file}
The salient features of the \texttt{params\_in} files for this simulation is as follows:
\begin{itemize}
\item \textbf{init\_lattice} is set to 1, which means the simulation is initialised in the bcc phase. However, the choice of initial phase is 
  unimportant since both phases will be explored during the simulation.
\item \textbf{M\_grid\_size}, \textbf{M\_grid\_min} and \textbf{M\_grid\_max} define the macrostates. We set \textbf{M\_grid\_min} and \textbf{M\_grid\_max}
  to -62 and 32, which corresponds to the
  range determined in our preliminary simulations. Furthermore, we set \textbf{M\_grid\_size} to 100: the order parameter range will be divided into
  100 macrostates. The choice of 100 is based upon our previous experience of LSMC simulations (and may not be appropriate for all systems). 
  If the number of macrostates is too high, then the weight function will take longer to generate. On the other hand if the number of macrostates
  is too low, then the system is unable to explore the whole range of order-parameter space in a reasonable simulation time -- regardless
  of the weight function. This occurs because the order-parameter grid is too coarse to be able to guide the system over any free energy barriers.
  Often it will be more efficient to use more macrostates (see below).
\item \textbf{enable\_multicanonical} is set to \texttt{T}, which means that the continually updated weight function is used to bias the dynamics of the system.
  This is actually unnecessary here since we elect to use mobile barriers to guide the system through order-parameter space. The method would
  work well with canonical sampling. However, using multicanonical sampling in theory should slightly help the system transition between 
  macrostates with a high free energy difference between them.
\item \textbf{enable\_lattice\_moves} is set to \texttt{T}: the system can explore both phases using lattice moves.
\item \textbf{part\_step} and \textbf{vol\_step} are informed by our preliminary simulations
\item \textbf{stop\_sweeps} is set to 160000. Note that since we are using 4 MPI threads, each thread will perform 40000 sweeps.
\item \textbf{output\_file\_period} is set to 250. We do this mainly to avoid creating massive output files. At this point we do not need to know 
  information regarding the time-evolution of the system during the simulation on the scale of less than 250 sweeps -- given that the equilibration time is
  $\lesssim 100$ sweeps. Note that since we are using \texttt{monteswitch\_mpi} there is one output file for each thread; within each thread $n$, every 
  250 sweeps information is output to the file \texttt{data\_n}.
\item \textbf{output\_stdout\_period} is set to -1, which suppresses all output to stdout. This is normally desirable for MPI simulations, since each thread 
  will itself output to stdout every \textbf{output\_stdout\_period} sweeps, which can result in an overwhelming amount of (and confusing) information to 
  stdout. 
  Furthermore, for long simulations we have no interest in watching the simulation variables during the running of the simulation -- which is the primary
  purpose of the simulation outputting information to stdout. Instead we let the simulation run, say, overnight, and extract the information we require
  from the \texttt{data} and \texttt{state} files once it is completed -- no information is output to stdout which cannot be obtained from these files.
\item \textbf{checkpoint\_period} is set to 2000; every 2000 sweeps the state of each MPI thread $n$ is output to the file \texttt{state\_n}.
\item \textbf{update\_eta} is set to \texttt{T}, which means that the simulation periodically updates/generates the weight function
\item \textbf{update\_eta\_sweeps} is set to 2000; we update the weight function (in this case using the transition matrix method, see below) every 2000 
  sweeps.
\item \textbf{update\_eta\_method} is set to \verb|"shooting"|, which means that the weight function is determined from the transition matrix via the 
  shooting method. This obviously requires the transition collection matrix to be updated during the simulation. 
  Accordingly we set \textbf{update\_trans} to \texttt{T}, otherwise
  the transition matrix is not updated during the simulation and updating the weight function using the shooting method will not work.
\item \textbf{enable\_barriers} is set to \texttt{T} since we wish to use artificial dynamics to force the system to quickly explore the whole of
  order-parameter space.
  Specifically, we elect to have the system sweep through the macrostates sequentially, proceeding first towards macrostate 1, then from there to
  macrostate 100, thenback to macrostate 1, etc. Accordingly we set \textbf{barrier\_dynamics} to \verb|"pong\_down"|.
\item \textbf{lock\_moves} controls how long the system is locked into each macrostate by the macrostate barriers, before the `next' macrostate is 
  opened to the
  system. This should be long enough that the system has enough time to equilibrate within the macrostate, but not so long that the system never proceeds
  to explore all macrostates during the simulation. Our choice of 38400 (=100 sweeps) seems to do the job. Note that while the equilibration time in our 
  preliminary simulations was ~100 sweeps, the time to equilibrate \emph{within one macrostate} is expected to be far shorter. Furthermore, the time spent in
  each macrostate if macrostate barriers are enabled will be longer than \textbf{lock\_moves}: \textbf{lock\_moves} is the number of moves before a 
  new macrostate becomes
  available to the system -- the system still must move into that new macrostate from the `old' macrostate by its own accord. As expected, it takes
  longer for the system to move from old macrostates into new macrostates if the free energy difference difference between the macrostates is high.
\end{itemize}

\subsection{Results}
At the completion of the simulation the file \texttt{state} (not \texttt{state\_0}, \texttt{state\_1}, \texttt{state\_2} or \texttt{state\_3}) 
contains the final results of the simulation --
pooled from all 4 MPI threads. We are obviously interested in the weight function. This can be obtained from the \texttt{state} file using 
\texttt{monteswitch\_post}.
After the following command, \texttt{wf.dat} contains the weight function vs. order parameter:
\begin{verbatim}
$ ../../../monteswitch_post -extract_wf > wf.dat
\end{verbatim}
Plotting the file \texttt{wf.dat} reveals a smooth curve with two minima separated by a high peak near 0. This is the perfect form for a weight function. If the
curve were not smooth, or was constant for large regions of order-parameter space, then it is probable that the weight function has not properly been
generated. This is perhaps an indication that more time is needed to generate a reasonable weight function. One possible solution is to continue
the simulation with \texttt{monteswitch\_mpi} using the \texttt{-resume} flag, e.g.
\begin{verbatim}
$ nohup mpiexec -n 4 ../../../monteswitch_mpi -resume -explicit <
/dev/null &
\end{verbatim}

Of course, just because the weight function has the aforementioned `perfect form' does not guarantee that it is very good. The ideal weight function
leads to the whole considered range of order-parameter space being sampled uniformly. A weight function with the `perfect form' could easily lead to
certain regions of order-parameter space being significantly over- or under-sampled. In principle this is not a problem because the final results -- given
a long enough production simulation -- do not depend on the weight function used. However the quality of the weight function affects how efficiently 
phase space is explored in the production simulation. Using a weight function of high quality samples order-parameter space almost uniformly, resulting
in many accepted lattice switches, and both phases being explored over short timescales. On the other hand if a lower quality weight function is used the
system will spend more time in certain regions of order-parameter space than others, and the time between lattice-switches will be less. Hence it is prudent
to perform a short simulation using the weight function to verify that it is of good quality.

\subsection{Double-checking the chosen order parameter range}\label{section:double_check}
The ideal weight function is related to the canonical macrostate probability distribution via Eqn. \eqref{ideal_wf}. Hence one can obtain a probability
distribution from the weight function. Of course, this will only be the `real' probability distribution if the weight function is ideal, which it
will not be exactly after our weight function simulation. Nevertheless we can obtain an \emph{approximate} probability distribution from the weight
function from our simulation. This is useful for double-checking that our chosen range of order parameters to consider is appropriate. We use the
following command to obtain the probability distribution from the weight function, and output it to the file \texttt{prob.dat}:
\begin{verbatim}
$ awk 'FNR==NR {sum=sum+exp(-$2); next} {print $1,exp(-$2)/sum}'
wf.dat > prob.dat
\end{verbatim}
Examining \texttt{prob.dat}, we see two peaks in the probability distribution in order-parameter space, each corresponding to one phase. The order parameter
range is suitable only if the probability distribution is effectively zero at the maximum and minimum order parameters considered. If this is not the
case, then our constraint on the order parameter range results in some states which are significantly likely at equilibrium being `cut out' of the
calculation. As can be seen from \texttt{prob.dat}, the probability distribution decays to zero within the chosen range as required. If this were not the
case then we would have to re-run the weight function generation simulation using a larger order parameter range.

\subsection{Estimating $\Delta G$ from the weight function}
With the macrostate probabilty distribution one can in fact obtain an estimate of the free energy difference between the phases. Recall that the
Helmholtz free energy difference $\Delta F$ is related to the time spent in each phase via Eqn. \eqref{DeltaF_stat_mech}. 
An analogous equation can be derived for $\Delta G$ in the NPT ensemble:
\begin{equation}\label{DeltaG_stat_mech}
\Delta F=\beta^{-1}\ln\biggl(\frac{t_2}{t_1}\biggr),
\end{equation}
where recall that $p_2/p_1$ is equal to $t_2/t_1$, and $t_1$ and $t_2$ are the total canonical time the system spends in phases 1 and 2.
The time spent in each phase can be deduced by
integrating the aforementioned peaks in the macrostate probability distribution. The peak for negative order parameters corresponds
to phase 1, and the peak in the positive region corresponds to phase 2: recall our earlier observations that phase 1 (bcc) at equilibrium corresponded to
a range of order parameters of -62 to 20, while phase 2 (hcp) corresponded to a range of 14 to 32. 
Hence the time spent in phase 1(2) is proportional to the area under the peak in the negative(positive) region. With this in mind the following command 
applies Eqn. \eqref{DeltaG_stat_mech} to obtain the free energy difference from the weight function:
\begin{verbatim}
$ awk '{if($1<0){sum1=sum1+$2}; if($1>0){sum2=sum2+$2}} END{print
-log(sum1/sum2)/9.403 }'
\end{verbatim}
Recall that 9.403 is the $\beta$ we are considering. The analogous intensive value is obtained by dividing by the number of atoms in the system (384):
\begin{verbatim}
$ awk '{if($1<0){sum1=sum1+$2}; if($1>0){sum2=sum2+$2}} END{print
-log(sum1/sum2)/(9.403*384) }'
\end{verbatim}
In the above commands we have assumed that macrostates with order parameters less than 0 `belong' to phase 1, and those with order parameters greater
than zero belong to phase 2. 0 seems a sensible choice of `cut-off' between the two peaks; note that the exact choice of cut-off doesn't really matter
since the probability distribution is essentially 0 near 0 order parameter.

We emphasise that the method just described provides only a crude estimate of $\Delta G$. One should not rely upon this approach for accurate results; however
it could be used to examine a wide range of, say, temperatures to quickly deduce the approximate position of the transition temperature if it is not known
from the outset. Note that, unlike our forthcoming production simulation, this method does not provide an uncertainty for $\Delta G$. 


\subsection{Using other weight function generation methods}
In the above example we used the transition-matrix method in conjunction with artificial dynamics to generate the weight function. This method gives a 
reasonable weight function very quickly; however, \emph{monteswitch} supports other methods for generating weight functions. These were described in 
Section \ref{sec:weight_generation}, namely the visited states method, and the transition-matrix method in conjunction with \emph{natural} dynamics.
The values for the control variables required to implement each of the aforementioned methods within \emph{monteswitch} are shown in Table 
\ref{table:wf_gen_variables}. Recall that for the transition-matrix method with artificial dynamics there are two possibilities: evolving the
macrostate barriers randomly or systematically.
Guidelines are also provided in the table regarding values for \textbf{update\_eta\_sweeps} and
\textbf{lock\_moves} for each method. The reasoning behind these values is as follows. 
For the visited states method, \textbf{update\_eta\_sweeps} corresponds to the block size mentioned in
Section \ref{sec:visited_states}. This should be long enough such that a block is representative of a `long' multicanonical simulation with the 
current weight function. Furthermore, the closer to the ideal weight function one wishes to get, the longer the blocks should be.
For the transition matrix method, if multicanonical sampling is used, then one may as well update the weight function `continuously'. In this case
the weight function used always reflects all the information gathered so far during the weight function generation simulation, thus enabling the
system to explore order parameter space as widely as possible in as short a simulation time as possible. Regarding the choice of
\textbf{lock\_moves}, see the discussion in Section \ref{sec:example_generation}.

\begin{landscape}
\begin{table}\label{table:wf_gen_variables}
\begin{center}
\begin{tabular}{l p{4cm} p{2cm} p{6cm}}
Control variable                   & VS                & TM-ND                & TM-AD \\
\hline 
\textbf{enable\_multicanonical}    & \texttt{T}        &   \texttt{T}         &  \texttt{F} or \texttt{T}   \\
\textbf{update\_eta}               & \texttt{T}        &   \texttt{T}         &  \texttt{T}                 \\
\textbf{update\_eta\_sweeps}       & $\gg$ multicanonical equilibration time (in sweeps)  & $\sim 1$ &   $\sim 1$ if \textbf{enable\_multicanonical}=\texttt{T}; 
   $\leq$ \texttt{stop\_sweeps} if \textbf{enable\_multicanonical}=\texttt{F} \\
\textbf{update\_trans}             & N/A               &   \texttt{T}         &  \texttt{T}                 \\
\textbf{update\_eta\_method}       & \texttt{VS}       &   \texttt{shooting}  &  \texttt{shooting}     \\
\textbf{enable\_barriers}          & \texttt{F}        &   \texttt{F}         &  \texttt{T}                 \\
\textbf{barrier\_dynamics}         & N/A               &   N/A                &  \texttt{random} for random macrostate barrier evolution;
    \texttt{pong\_up} or \texttt{pong\_down} for systematic evolution  \\
\textbf{lock\_moves}               & N/A               &   N/A                &  $\gtrsim$ time to equilibrate \emph{within a macrostate} (in moves) \\
\end{tabular}
\end{center}
\caption{Values of control variables in \texttt{params\_in} or \texttt{state} required to implement various weight function generation methods.
`VS' refers to the visited states method; `TM-D' refers to the transition state method with natural dynamics; `TM-AD' refers to the
transition state method with artificial dynamics. (See Section 
\ref{sec:weight_generation} for descriptions of these methods). Furthermore, `N/A' signifies that the control variable is not used in the
method, and hence its value does not matter.}
\end{table}
\end{landscape}


\section{Weight function verification simulation}
Assuming that we have a good weight function, one thing remains which is useful to know before we perform our production simulation: the correlation time 
for the multicanonical simulation using this weight function (and the chosen maximum particle and volume move step sizes)
\footnote{Presumably one could make the multicanonical simulation more efficient by optimising the maximum particle and volume move step sizes used in the 
multicanonical simulation, and not simply using the same values as for the canonical simulation. We have never done this, though it is worth investigating.}
Recall that we obtained an estimate for the equilibration time earlier; however, this pertained only to a one-phase simulation,
in a canonical ensemble. As we will see in a moment, the equilibration times in a two-phase lattice switch multicanonical simulation are far longer. 
We need to know this equilibration time because it determines how large the blocks should be in block analysis for determining equilibrium quantities -- 
in particular for the free energy difference. To determine this we perform a short simulation, using the weight function. This simulation also acts to
verify that the weight function is indeed sensible, i.e., that it leads to the entire range of order-parameter space being explored approximately 
uniformly as expected.

The directory \texttt{weight\_function\_verification} corresponds to the weight function verification simulation.
Recall that we can `resume' a simulation whose variables are stored in the \texttt{state} file by invoking \texttt{monteswitch} with the 
\texttt{-resume} argument. Furthermore
we can resume a simulation from \texttt{state} but with all counter variables reset to zero by invoking the \texttt{-reset} argument. With this in mind, we
use the \texttt{state} file from our previous simulation as a starting point. This file contains the weight function we wish to verify. We will modify this
file to suit our needs, and then run the simulation using the command
\begin{verbatim}
$ ../../../monteswitch -reset
\end{verbatim}
Note that the file \texttt{state\_start} in the directory \texttt{weight\_function\_verification} contains the \texttt{state} file from the directory 
\texttt{weight\_function\_generation}
after it has been modified for the weight function verification simulation; and the file \texttt{state} in the directory \texttt{weight\_function\_verification}
corresponds to the output of the weight function verification simulation.

\subsection{Creating the input \texttt{state} file}
The modifications to the state file can be seen before the weight function verification simulation is run can be seen by invoking the following command
in the weight\_function\_verification directory:
\begin{verbatim}
$ diff state_in ../weight_function_generation/state
\end{verbatim}
The key changes are as follows:
\begin{itemize}
\item We have changed \textbf{stop\_sweeps} to be 10000, which corresponds to a short simulation.
\item We have set \textbf{update\_eta} to \texttt{false}, so that the weight function is fixed throughout the simulation.
\item We have set \textbf{enable\_barriers} to \texttt{F}, since we want `natural' dynamics for the weight function verification simulation.
\item We have set \textbf{output\_file\_period} to 10 so we have high-resolution information about how order-parameter space is explored.
\item We have set \textbf{output\_stdout\_period} to 10 so we can keep track of the progress of the simulation.
\end{itemize}

\subsection{Results}
After the simulation is complete, as before, we can use \texttt{data} to generate a plot of the order parameter vs. time in the simulation using the
following command:
\begin{verbatim}
$ grep 'M:' data | awk '{print $2,$3}' > M_vs_t.dat
\end{verbatim}
From this we see that the entire range of order-parameter space (-62 to 32) was explored within the simulation. Note that, having realised that the
10000 sweep simulation was too perhaps short, we ran the simulation for another 10000 sweeps by using the command
\begin{verbatim}
$ ../../../monteswitch -resume
\end{verbatim}
Hence the output files \texttt{state} and \texttt{data}, and \texttt{M\_vs\_t.dat} created by the above command correspond to after 20000 sweeps, not 10000 
sweeps; a copy of the 
output \texttt{state} file after the first 10000 sweep simulation can be found in the file \texttt{state\_after\_10000\_sweeps}.

Plotting \texttt{M\_vs\_t.dat} reveals that the simulation explores the entire range of order-parameter space (-62 to 32) within 20000 sweeps. Note that this
in practice means that both phases are explored within 20000 sweeps, since high order parameters correspond to phase 2 and low order parameters correspond
to phase 1 (see above). Hence the correlation time -- which in this case involves both phases being explored -- is ~10000 sweeps. The 
block size we use in the
forthcoming production simulation must therefore be greater than this. Note that after the production run one can retrospectively check that the
block size was appropriate. We will do this later. Furthermore, one can use the `observations' in the \texttt{data} files output by the production simulation to
analyse the data -- once the production simulation is complete -- for a variety of block sizes, though software to do this is not currently included in
\emph{monteswitch}.

It is instructive to plot of how often each macrostate was visited during the weight function verification simulation. \texttt{monteswitch\_post}
provides an easy way of extracting this information; the following command creates a file \texttt{counts.dat} which is a plot of macrostate index vs. the
number of times the  macrostate was visited during the entire simulation:
\begin{verbatim}
$ ../../../monteswitch_post -extract_M_counts | awk '{print 
NR,$2+$3}' > macro_vs_counts.dat
\end{verbatim}
From this file we see that all macrostates are visited a reasonable number of times during the simulation. While it is far from the case that the
histogram is flat -- which an ideal weight function would yield -- it is sufficiently flat for our purposes: for our purposes it is acceptable that
all macrostates are visited uniformly to within, say, half an order of magnitude. In fact, we would in fact be very lucky to get a flat histogram
even with the ideal weight function, given that the simulation is so short: it is of the order of the correlation time, which is nowhere near long
enough to gather sufficient statistics.


\section{Production simulation}
We are now ready to perform the production simulation. The corresponding directory is \texttt{production\_simulation}.
As with the weight function simulation, we use the \texttt{state} file output from the weight function generation simulation as the starting point
for the production simulation. We will modify this file to suit our needs, and then run the simulation, using four MPI threads with \texttt{monteswitch\_mpi},
using the command
\begin{verbatim}
$ nohup mpiexec -n 4 ../../../monteswitch_mpi -reset -explicit <
/dev/null &
\end{verbatim}
Note that again we have used the \texttt{-reset} flag to reset the counter variables at initialisation, and that we have also used the \texttt{-explicit}
flag to keep the data from all threads.

\subsection{Creating the input \texttt{state} file}
The modifications to the state file can be seen before the weight function verification simulation is run can be seen by invoking the following command
in the \texttt{weight\_function\_verification} directory:
\begin{verbatim}
$ diff state_start ../weight_function_generation/state
\end{verbatim}
The key changes are as follows:
\begin{itemize}
\item We have changed \textbf{stop\_sweeps} to be 700000, which corresponds to 175000 sweeps to be performed for each MPI thread.
\item We have set \textbf{equil\_sweeps} to 20000, which is larger than the correlation time we determined for the multicanonical simulation using our 
weight function.
\item We have set \textbf{update\_eta} to \texttt{F}, so that the weight function is fixed throughout the simulation.
\item We have set \textbf{enable\_barriers} to \texttt{F}, since we want 'natural' dynamics for the production simulation.
\item \textbf{calc\_equil\_properties} is set to \texttt{T}. This is required for the simulation to calculate equilibrium quantities (the enthalpy, volume and 
mean-squared displacements of each particle) and their uncertainties using block analysis.
\item \textbf{block\_sweeps}, the number of sweeps which constitute a block in the block analysis is set to 155000, which is far larger than the 
correlation time of
  ~10000 sweeps determined earlier. Note that, since each MPI thread performs 175000 sweeps, and since each thread will be given 20000 sweeps to 
  equilibrate - during which time the microstates visited by the system are not used in evaluating equilibrium quantities - setting the block size to 
  155000 sweeps corresponds to each MPI thread performing exactly 1 block. Hence the simulation in total considers 4 blocks.
\end{itemize}

\subsection{Results}
At the completion of the simulation the \texttt{state} file contains the equilibrium quantities, evaluated using block analysis. It is these quantities we
are interested in, primarily the Gibbs free energy difference $\Delta G$ between the phases. The variables \textbf{equil\_DeltaF} and 
\textbf{sigma\_equil\_DeltaF} in \texttt{state} contain the free energy difference and its uncertainty evaluated using block analysis.
Hence the following command extracts the free energy difference and its uncertainty from the \texttt{state} file:
\begin{verbatim}
$ grep -E '( equil_DeltaF| sigma_equil_DeltaF)' state
\end{verbatim}
Recall that all quantities in the \texttt{state} file are extensive; to get the intensive values we must divide them by the number of atoms in the system, which
in this case is 384. Hence the following command gives the intensive free energy difference between the phases:
\begin{verbatim}
$ grep -E '( equil_DeltaF| sigma_equil_DeltaF)' state | awk
'{print $1,$2/384}'
\end{verbatim}
The final value is therefore 0.00004(4)eV, where the units are derived from the convention used in the `setfl' format used in the \texttt{interactions\_in}
file -- the units used in \emph{monteswitch} are derived entirely from the \texttt{interactions.f95} it is used in conjunction with, in this case 
\texttt{interactions\_EAM.f95}.
The convention used in \emph{monteswitch} is that the free energy difference is the free energy of phase 1 minus that of phase 2. Hence a positive free energy
difference, which is the case here, suggests that phase 2 (hcp here as opposed to bcc) is stable at the considered temperature and pressure. 
However, the uncertainty in our value is of the same magnitude as the value; hence the prefered phase cannot be discerned. This is a moot point though:
our free energy difference of 0.04(4)meV can be considered zero for all intents and purposes; this temperature and pressure can be considered to be
a coexistence point to within an error of $\sim 0.04$meV/atom. Thus our results agree with Ref. \cite{Mendelev_2007}.

Using similar commands to the above, one can extract the volume and enthalpy per atom for each phase.
\begin{verbatim}
$ grep -E '( equil_V_1| sigma_equil_V_1)' state | awk '{print $1,
 $2/384}'
\end{verbatim}
gives the volume per atom for phase 1;
\begin{verbatim}
$ grep -E '( equil_V_2| sigma_equil_V_2)' state | awk '{print $1,
  $2/384}'
\end{verbatim}
gives the volume per atom for phase 2;
\begin{verbatim}
$ grep -E '( equil_H_1| sigma_equil_H_1)' state | awk '{print $1,
 $2/384}'
\end{verbatim}
gives the enthalpy per atom for phase 1;
\begin{verbatim}
$ grep -E '( equil_H_2| sigma_equil_H_2)' state | awk '{print $1,
 $2/384}'
\end{verbatim}
gives the enthalpy per atom for phase 2. One can also obtain the mean-squared displacements for all atoms in phase 1: the following command extracts
these quantities from \texttt{state} and outputs the mean-squared displacement vs. atom number:
\begin{verbatim}
$ grep -E ' equil_umsd_1' state | awk '{for(i=2; i<=NF; i++){
print i-1,$i}}'
\end{verbatim}
Their uncertainties are similarly given by 
\begin{verbatim}
$ grep -E ' sigma_equil_umsd_1' state | awk '{for(i=2; i<=NF; 
i++){print i-1,$i}}'.
\end{verbatim}
Similar commands can be used to obtain the mean-squared displacements and associated uncertainties for phase 2. Of course, it is unnecessary to use
a lattice-switch simulation to extract such one-phase' quantities; a conventional Monte Carlo simulation will do the job more efficiently.
Here the quantities are somewhat of a by-product of the lattice-switch simulation to calculate the free energy difference.

\subsection{Consistency checks}
Once the simulation is complete, it is prudent to perform some checks to ensure that it has gone as expected, and hence that the values for equilibrium
quantities obtained from the simulation are meaningful. Of course, comparing the final values obtained from the simulation to `known' values is useful.
Below we describe some less obvious checks to perform.

The free energy difference for a block is given by Eqn. \eqref{DeltaG_stat_mech}, where in this case $t_1$ and $t_2$ are the number of moves which the 
system spent in phase 1 and phase 2 respectively during the block. Of course, this equation presupposes that both phases are explored during the block. 
In evaluating $\Delta G$, \emph{monteswitch} only considers blocks during which both phases are explored. This notwithstanding, it is good to check that
the block size is significantly larger than the time it typically takes the system to explore the whole of order-parameter space -- which in practice
is an equivalent condition to both phases being thoroughly explored during each block. Of course, this was the point of the weight function verifictaion
simulation to determine the appropriate block size. However, to check this more explicitly we plot the order parameter vs. simulation time for MPI thread 0:
\begin{verbatim}
$ grep 'M:' data_0 | awk '{print $2,$3}' > M_vs_t_0.dat
\end{verbatim}
Plotting \texttt{M\_vs\_t\_0.dat} it can be seen that the system traverses the entire range of order-parameter space (-62--32) often within the block size 
(175000 sweeps), as required.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Test Cases}\label{chapter:tests}
The directory \texttt{Tests} contains a suite of test cases for the main programs in \emph{monteswitch}. Of course, these tests can also be used as
examples.

Each test can be executed by executing the \texttt{run.sh} shell script in the corresponding directory after copying the
appropriate `\texttt{interactions\_} file' from \texttt{Interactions} to \texttt{interactions.f95}, and then (re-)compiling the
package (see Chapter \ref{chapter:preliminaries}). Note that the \texttt{run.sh} scripts assume that the main programs \texttt{monteswitch}
and \texttt{monteswitch\_mpi} are located next to the source code in the above directory -- which should be the case by default. Furthermore
the \texttt{run.sh} files may require some modification to suit your platform; see Chapter \ref{chapter:preliminaries}.


\section{Einstein crystal (\texttt{EC})}
The Einstein crystal is an excellent testing ground because analytical results can be obtained for this system:
in what follows we use those for the free energy and mean-squared displacement given in Section 10.2.1 in Ref.
\cite{book:Frenkel}. Here we use the Einstein crystal to test \texttt{monteswitch} and \texttt{monteswitch\_mpi}
in the NVT ensemble. This includes testing multicanonical sampling and weight function generation (including
mobile barrier methods), calculation of free energy differences, and calculation of equilibrium properties.
The relevant \texttt{interactions\_} file for thse tests is \texttt{interactions\_EC.f95}. Before running these 
tests one should copy \texttt{Interactions/interactions\_EC.f95} to \texttt{interactions.f95}, and then (re-)complile 
\emph{monteswitch}. 

The Hamiltonian realised in \emph{monteswitch} in conjunction with \texttt{interactions\_EC.f95} is 
as follows. In phase 1 the energy of each particle corresponds to a harmonic oscilator \emph{about the origin} with spring constant 
\textbf{alpha\_1}. Similar applies to phase 2 with spring constant \textbf{alpha\_2}. \textbf{alpha\_1} and \textbf{alpha\_2} 
are specified via the input file \texttt{interactions\_in}. The format of this file is as follows. On the first line there are two tokens. 
The first token is a \texttt{CHARACTER(LEN=20)} variable (I recommend: \texttt{alpha\_1=}); the second token is the 
value of \textbf{alpha\_1} (type \texttt{REAL}). The second line is similar, but for \textbf{alpha\_2}.


\subsection{\texttt{test\_EC\_1}}
This test calculates the free energy difference between two Einstein crystals with different spring constants,
as well as the mean-squared displacements and mean energies of both crystals. The spring constant for lattice 
1 in is 1.0, and the spring constant for lattice 2 is 2.0. The calculation in this test is 
performed at $\beta=100$ using Boltzmann (i.e., not multicanonical) sampling, for a one particle supercell, and 
consists of 10,000,000 sweeps using \textbf{part\_step}=0.12.

Checks to perform:
\begin{enumerate}
\item
The free energy difference between the two systems should be $(3/200)\ln(1/2)=-0.0103972$. 
Check that this is the case for the simulation: the free energy difference is stored in the \textbf{equil\_DeltaF}
variable output to the terminal, with its uncertainty stored in the \textbf{sigma\_equil\_DeltaF} variable. 
\item
The mean-squared displacements should be $3/200=0.015$ for phase 1 and $3/400=0.0075$ for phase 2: see the 
variables \textbf{equil\_umsd\_1}, \textbf{sigma\_equil\_umsd\_1}, \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2} 
output to the terminal.
\item
The mean energy of both crystals should be 0.015, which follows from the equipartition theorem:
there are 3 degrees of freedom, each with $0.5/\beta$, which in our case gives $1.5/100$. Check that this
is the case by examining the variables \textbf{equil\_H\_1}, \textbf{sigma\_equil\_H\_1}, \textbf{equil\_H\_2} and 
\textbf{sigma\_equil\_H\_2} in the output to the terminal. Recall that 'H' in monteswitch refers to the energy in 
an NVT simulation, and the enthalpy in an NPT simulation.   
\end{enumerate}


\subsection{\texttt{test\_EC\_1\_MPI}}
This test is the same as \texttt{test\_EC\_1}, except that an MPI simulation is run using 4 threads. One should check that
1, 2 and 3 described in \texttt{test\_EC\_1} applies to the variables listed in the \texttt{state} file as opposed to the
terminal. This test essentially verifies that \texttt{monteswitch\_mpi} works correctly, especially that it correctly pools 
the results from many threads and outputs them to the \texttt{state} file.


\subsection{\texttt{test\_EC\_2}}
This test is the same as \texttt{test\_EC\_1}, except that 10 simulations consisting of 1,000,000 sweeps each are performed
instead of one simulation of 10,000,000 sweeps, using both the \texttt{-resume} and \texttt{-new} arguments to the executable 
\texttt{monteswitch} instead of simply the \texttt{-new} argument. This test essentially verifies that checkpointing works
correctly within \texttt{monteswitch}. Checks 1, 2 and 3 described in \texttt{test\_EC\_1} should be performed on the 
\texttt{state} file.


\subsection{\texttt{test\_EC\_2\_MPI}}
This test is the same as \texttt{test\_EC\_2}, except that 10 4-thread MPI simulations are performed. This test essentially verifies 
that checkpointing works correctly for \texttt{monteswitch\_mpi}. Checks 1, 2 and 3 described in \texttt{test\_EC\_1} should be 
performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_3}}
This test calculates the equilibrium quantities as described in \texttt{test\_EC\_1}, but uses multicanonical sampling,
with a weight function generated using the visited states method. Specifically, a weight function generation 
simulation is performed which consists of 10,000,000 sweeps. Then the \texttt{state} file is altered in preparation 
for the production simulation. Then the production simulation is performed, which consists of 10,000,000 sweeps.
Checks 1, 2 and 3 described in \texttt{test\_EC\_1} should be performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_4}}
This test calculates the equilibrium quantities as described in \texttt{test\_EC\_1}, but uses multicanonical sampling,
with a weight function generated using the shooting method. Specifically, a weight function generation simulation
is performed which consists of 1,000,000 sweeps. Then the \texttt{state} file is altered in preparation 
for the production simulation. Then the production simulation is performed, which consists of 10,000,000 sweeps.
The checks to perform for this test are the same as for \texttt{test\_EC\_3}.


\subsection{\texttt{test\_EC\_4\_MPI}}
This test is the same as \texttt{test\_EC\_4}, but uses MPI (2 threads).


\subsection{\texttt{test\_EC\_5}}
This test generates the weight function using the shooting method in conjunction with \texttt{pong\_down} barrier
dynamics and Boltzmann sampling. The simulation consists of 1,000,000 sweeps. Two further files are created 
during this test: \texttt{M\_vs\_t.dat} gives the value of the order parameter vs. sweep number (data points 
every 100 sweeps), and \texttt{macro\_vs\_t.dat} similarly gives the macrostate number, i.e., the bin in the 
order parameter histogram for the system, vs. sweep number. Both plots should resemble a sawtooth.


\subsection{\texttt{test\_EC\_5\_MPI}}
This test is similar to \texttt{test\_EC\_5}, except that a 2-thread MPI simulation is performed, and \texttt{pong\_up}
barrier dynamics are used. The files \texttt{M\_vs\_t\_0.dat} and \texttt{macro\_vs\_t\_0.dat} pertain to thread '0'; and
the files \texttt{M\_vs\_t\_1.dat} and \texttt{macro\_vs\_t\_1.dat} pertain to thread 1. All files should have a sawtooth
pattern.


\subsection{\texttt{test\_EC\_6}}
This test is similar to \texttt{test\_EC\_5}, except that \texttt{random} barrier dynamics are used. The files 
\texttt{M\_vs\_t.dat} and \texttt{macro\_vs\_t.dat} should be random walks.


\subsection{\texttt{test\_EC\_7}}
This test is the same as \texttt{test\_EC\_5}, except that 10 simulations are performed (each consisting of 100,000
sweeps) instead of 1. This tests continuity of simulations using barriers over checkpoints.


\subsection{\texttt{test\_EC\_7\_MPI}}
This test is similar to \texttt{test\_EC\_7}, except that 2 2-thread MPI simulations are performed such that the total
number of sweeps is 1,000,000.


\subsection{\texttt{test\_EC\_8}}
This test is similar to \texttt{test\_EC\_1}, except that the crystal consists of 4 particles.

Checks to perform:
\begin{enumerate}
\item
The free energy difference between the two systems should be -0.0415888
Check that this is the case for the simulation: the free energy difference is stored in the \textbf{equil\_DeltaF}
variable output to the terminal, with its uncertainty stored in the \textbf{sigma\_equil\_DeltaF} variable. 
\item
The mean-squared displacements should be $3/200=0.015$ for phase 1 and $3/400=0.0075$ for phase 2: see the 
variables \textbf{equil\_umsd\_1}, \textbf{sigma\_equil\_umsd\_1}, \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2} output to the 
terminal.
\item
The mean energy of both crystals should be 0.06, which follows from the equipartition theorem:
there are $4\times 3$ degrees of freedom , each with $0.5/\beta$, which in our case gives $6/100$. Check that this
is the case by examining the variables \textbf{equil\_H\_1}, \textbf{sigma\_equil\_H\_1}, \textbf{equil\_H\_2} and \textbf{sigma\_equil\_H\_2}
in the output to the terminal. Recall that 'H' in monteswitch refers to the energy in an NVT simulation, and 
the enthalpy in an NPT simulation.
\end{enumerate}


\subsection{\texttt{test\_EC\_8\_MPI}}
This test is the same as \texttt{test\_EC\_8}, except that an MPI simulation is run using 4 threads.  One should check that
1, 2 and 3 described in \texttt{test\_EC\_8} apply to the variables listed in the \texttt{state} file as opposed to the
terminal. This test essentially verifies that \texttt{monteswitch\_mpi} works correctly for multiple particles, especially that it 
correctly pools the results from many threads and outputs them to the \texttt{state} file.


\subsection{\texttt{test\_EC\_9}}
This test is the same as \texttt{test\_EC\_8}, except that 10 simulations consisting of 1,000,000 sweeps each are performed
instead of one simulation of 10,000,000 sweeps, using both the \texttt{-resume} and \texttt{-new} arguments to the executable 
\texttt{monteswitch} instead of simply the \texttt{-new} argument. This test essentially verifies that checkpointing works
correctly for multiple particles. Checks 1, 2 and 3 described in \texttt{test\_EC\_8} should be performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_9\_MPI}}
This test is the same as \texttt{test\_EC\_9}, except that 10 4-thread MPI simulations are performed. This test essentially verifies 
that checkpointing works correctly for \texttt{monteswitch\_mpi} for multiple particles. Checks 1, 2 and 3 described in \texttt{test\_EC\_8} should be 
performed on the \texttt{state} file.




\section{`NPT Einstein crystal' (\texttt{EC\_NPT})}
The Einstein crystal cannot be used for NPT simulations. Here we consider a modification of the Einstein
crystal model in which the spring constants have a volume dependence. The relevant \texttt{interactions\_} file for these tests is 
\texttt{interactions\_EC\_NPT.f95}. Before running these tests one should copy 
\texttt{Interactions/interactions\_EC\_NPT.f95} to \texttt{interactions.f95}, and then (re-)complile 
\emph{monteswitch}.

The Hamiltonian realised in \emph{monteswitch} in conjunction with \texttt{interactions\_EC\_NPT.f95} is 
as follows. In phase 1 the energy of each particle corresponds to a harmonic oscillator about its
lattice site in which the spring constant is $2\alpha_1V^{-\gamma_1}$, where $V$ denotes the volume of 
the system; the energy of a particle in phase 1 is $\alpha_1V^{-\gamma_1}u^2$, where $u$ is the magnitude of the displacement
of the particle from its lattice site. Similarly the spring constant for phase 2 is $2\alpha_2V^{-\gamma_2}$.
The free parameters are $\alpha_1$, $\gamma_1$, $\alpha_2$ and $\gamma_2$.
The format of the file, named \texttt{interactions\_in} to import these free parameters for a simulation at initialisation
is as follows. On the first line there are two tokens. The first is a \texttt{CHARACTER(LEN=20)} variable (I recommend: \texttt{alpha\_1=});
the second is the value of $\alpha_1$. The second line is similar, but for $\alpha_2$. The third is similar for $\gamma_1$, 
and the fourth is similar for $\gamma_2$.

The following analytical results can be derived for this model in the NPT ensemble.
The partition function for one particle in phase 1 is (where $\Gamma$ denotes the gamma function, and $\beta=1/(k_BT)$)
\begin{equation}
Z_1=\frac{2^{5/2}\pi\Gamma(1.5)}{(\alpha_1\beta)^{3/2}}\frac{\Gamma(1.5\gamma_1+1)}{(\beta P)^{1.5\gamma_1+1}},
\end{equation}
the mean-squared displacements are,
\begin{equation}
\langle u^2\rangle_1=\frac{1}{\beta\alpha_1(\beta P)^{\gamma_1}}\frac{\Gamma(2.5)\Gamma(2.5\gamma_1+1)}{\Gamma(1.5)\Gamma(1.5\gamma_1+1},
\end{equation}
and the mean volume is
\begin{equation}
\langle V\rangle_1=\frac{\Gamma(1.5\gamma_1+2)}{\Gamma(1.5\gamma_1+1)}\frac{1}{\beta P}.
\end{equation}
Similar applies for lattice 2.
For $N>1$ particles the partition function for phase 1 becomes (IS THIS CORRECT?):
\begin{equation}
Z(N)=(2\pi\Gamma(1.5)(\beta\alpha_1)^{-3/2})^N\frac{\Gamma(1.5N\gamma_1+1)}{(\beta P)^{1.5N\gamma_1+1}}.
\end{equation}
Using the expression for the partition function, one can derive the following expression for the free energy difference
between the two phases for $N=1$:
\begin{equation}
F_1-F_2=-\frac{1}{\beta}\ln\Biggl\lbrace 
\frac{\Gamma(1.5\gamma_1+1)}{\Gamma(1.5\gamma_2+1)}\frac{\alpha_2}{\alpha_1}^{3/2}(\beta P)^{1.5(\gamma_2-\gamma_1)}
\Biggr\rbrace
\end{equation}

Here we test \texttt{monteswitch} and \texttt{monteswitch\_mpi} against the above model in the
NPT ensemble. This includes testing multicanonical sampling and weight function generation (including
mobile barrier methods), calculation of free energy differences, and calculation of equilibrium properties.


\subsection{\texttt{test\_EC\_NPT\_1}}
This test calculates the free energy difference between two phases with different $\alpha$ and $\gamma$,
as well as the mean-squared displacements and mean energies of both crystals. Here $\alpha_1=1000$, $\gamma_1=2$,
$\alpha_2=2000$, $\gamma_2=1.8$, $\beta=10$ and $P=0.25$. The calculation in this test is performed using Boltzmann 
sampling (i.e., not multicanonical sampling), for a one particle supercell, and consists of 10,000,000 sweeps 
using \textbf{part\_step} set to 0.03 and \textbf{vol\_step} set to 3.0.

Checks to perform:
\begin{enumerate}
\item
The mean-squared displacements should be 0.00048 for phase 1 and 0.00018089 for phase 2: see the 
variables \textbf{equil\_umsd\_1}, \textbf{sigma\_equil\_umsd\_1}, \textbf{equil\_umsd\_2} and \textbf{sigma\_equil\_umsd\_2} output to the 
terminal.
\item
The mean volume should be 1.6 for phase 1 and 1.48 for phase 2: see the variables \textbf{equil\_V\_1}, 
\textbf{sigma\_equil\_V\_1}, \textbf{equil\_V\_2} and \textbf{sigma\_equil\_V\_2} output to the terminal.
\item
The mean enthalphy should be 0.55 for phase 1 and 0.52 for phase 2. This follows from the fact that
the mean enthalpy is the mean energy + $PV$, where the mean energy of both crystals should be 0.15, which 
follows from the equipartition theorem: there are 3 degrees of freedom, each with $0.5/\beta$.
See the variables \textbf{equil\_H\_1}, \textbf{sigma\_equil\_H\_1}, \textbf{equil\_H\_2} and \textbf{sigma\_equil\_H\_2} output to the terminal.
Recall that 'H' in monteswitch refers to the energy in an NVT simulation, and the enthalpy in an NPT simulation.
\item
The free energy difference per particle between the two systems should be -0.11285. See the variables
\textbf{equil\_DeltaF} and \textbf{sigma\_equil\_DeltaF} output to the terminal.
\end{enumerate}


\subsection{\texttt{test\_EC\_NPT\_2}}
This test is the same as \texttt{test\_EC\_NPT\_1}, except that 10 simulations consisting of 1,000,000 sweeps each are performed
instead of one simulation of 10,000,000 sweeps, using both the \texttt{-resume} and \texttt{-new} arguments to the executable 
\texttt{monteswitch} instead of simply the \texttt{-new} argument. This test essentially verifies that checkpointing works
correctly. Checks 1--4 described in \texttt{test\_EC\_NPT\_1} should be performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_NPT\_2\_MPI}}
This test is the same as \texttt{test\_EC\_NPT\_2}, except that 10 4-thread MPI simulations are performed. This test essentially verifies 
that checkpointing works correctly for \texttt{monteswitch\_mpi}. Checks 1--4 described in \texttt{test\_EC\_NPT\_2} should be 
performed on the \texttt{state} file.


\subsection{\texttt{test\_EC\_NPT\_3}}
This test calculates the equilibrium quantities as described in \texttt{test\_EC\_NPT\_1}, but uses multicanonical sampling,
with a weight function generated using the visited states method. Specifically, a weight function generation 
simulation is performed which consists of 10,000,000 sweeps. Then the \texttt{state} file is altered in preparation 
for the production simulation. Then the production simulation is performed, which consists of 10,000,000 sweeps.

This test also outputs the weight function generated using the visited states method, as well as a histogram of 
the macrostates visited during the production simulation. These can be found in the files \texttt{wf.dat} and \texttt{M\_hist.dat}
respectively. 

Checks to perform beyond  1--4 described in \texttt{test\_EC\_NPT\_1}:
\begin{enumerate}
\setcounter{enumi}{4}
\item
The macrostate histogram should be fairly flat, which reflects the fact that all macrostates are
visted with equal probability in multicanonical sampling using an ideal weight function.
\end{enumerate}


\subsection{\texttt{test\_EC\_NPT\_4}}
This test is similar to \texttt{test\_EC\_NPT\_2}, but uses 5 particles, and a lattice switch which changes the system volume.
This checks that lattice switches which do not preserve the system volume sample the NPT ensemble correctly.

Checks to perform:
\begin{enumerate}
\item
The free energy difference between the two phases should be -0.7860673299.
\end{enumerate}


\section{Lennard--Jones solid: hcp vs. fcc (\texttt{LJ\_hcp\_fcc})}
A solid in which particles interact via a Lennard-Jones potential is a more realistic test for \emph{monteswitch}.
Here we try to reproduce the results of Refs. \cite{thesis:Jackson,Jackson_2002}. Specifically, we calculate the free energy
difference between hcp and fcc phases of the Lennard-Jones solid. The relevant \texttt{interactions\_} file for these tests is 
\texttt{interactions\_LJ\_hcp\_fcc.f95}. Before running these tests one should copy \texttt{Interactions/interactions\_LJ\_hcp\_fcc.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}.

The Hamiltonian realised in \emph{monteswitch} in conjunction with \texttt{interactions\_LJ\_hcp\_fcc.f95} is applicable only to
to the hcp--fcc problem. Phase 1 is assumed to be hcp and phase 2 is assumed to be fcc. The Lennard-Jones interactions
used here are not your typical Lennard-Jones interactions. Usually one truncates the interactions at
a predetermined distance, or uses a predetermined 'list' of interacting pairs of particles. However, this
approach yields errors which cannot be ignored for this problem: see Refs. \cite{thesis:Jackson,Jackson_2002} for details. A
better approach is to evaluate the \emph{difference} of the energy of the phase under consideration relative to the 
ground state for the density under consideration, and apply the usual truncations to this difference. This is what is done here:
The energy here for particle positions $\lbrace\mathbf{r}\rbrace$ in the hcp phase, given that the system currently has density $\rho$, is:
\begin{equation}
E = \Phi_{\text{LJ,trunc}}(\lbrace\mathbf{r}\rbrace)-\Phi_{\text{LJ,trunc}}(\lbrace\mathbf{R}_{\text{hcp}}\rbrace)
+ E_{\text{GS,hcp}}(\rho),
\end{equation}
where $\lbrace\mathbf{R}_{\text{hcp}}\rbrace$ are the lattice vectors corresponding to the hcp lattice at the current density $\rho$, 
$\Phi_{\text{LJ,trunc}}(\lbrace\mathbf{r}\rbrace)$ is the Lennard-Jones energy for the set of particle positions $\lbrace\mathbf{r}\rbrace$
using truncated interactions (in the conventional sense, e.g., ignore interactions between particles $i$ and $j$ if their separation is
greater than some cut-off), and $E_{\text{GS,hcp}}(\rho)$ is the \emph{exact} energy of the hcp lattice at density $\rho$, i.e., what 
$\Phi_{\text{LJ,trunc}}(\lbrace\mathbf{R}_{\text{hcp}}\rbrace)$ would be if the cut-off distance were taken to infinity. Similar applies
for the fcc phase.
Of course, this approach necessitates a tailor-made \texttt{interactions\_} file for the hcp--fcc. By contrast the \texttt{interactions\_}
file corresponding to the `conventional' Lennard-Jones Hamiltonian can be applied to any pair of phases.
Note that the usage of \texttt{interactions\_LJ\_hcp\_fcc.f95} is identical to \texttt{interactions\_LJ.f95} -- which is described in
Chapter \ref{chapter:interactions}.


\subsection{\texttt{test\_LJ\_hcp\_fcc\_1\_MPI}}
This test calculates the free energy difference between hcp and fcc for a 216-particle supercell at $P=0$ and
$\beta=10$ in the NPT ensemble, given Lennard-Jones parametrisation $\epsilon=\sigma=1$. 2 4-thread MPI simulations are used. 
The first generates the weight function using \texttt{pong\_down} barrier dynamics over 500000 sweeps. The second simulation calculates 
the free energy difference. Note that this simulation may take a while to run. The final result for the free energy difference
should match that in Ref. \cite{thesis:Jackson}, Fig. 6.21, the data-point corresponding to $k_BT=0.1$, i.e.,
the free energy difference per particle should be -0.00055 (Note that Jackson defines the free energy difference as
that of fcc minus that of hcp, while in \emph{monteswitch}, with hcp corresponding to lattice 1 and fcc corresponding to
lattice 2, the free energy difference is defined as that of hcp minus that of fcc -- hence the change of sign here
relative to Jackson's result). Hence in the test simulation the final extensive free energy difference should be -0.12.

Checks to perform:
\begin{enumerate}
\item
The final free energy difference between the two systems should be -0.12. Check that this is the case for the
simulation: the free energy difference is stored in the \textbf{equil\_DeltaF} in the \texttt{state} file, with its uncertainty
stored in the \textbf{sigma\_equil\_DeltaF} variable.
\end{enumerate}


\section{Hard spheres (single species) (\texttt{HS})}
The hard-sphere system has been well studied, and makes an excellent testing ground for \emph{monteswitch}.
The relevant \texttt{interactions\_} file for these tests is \texttt{interactions\_HS.f95}, whose usage is described in Chapter
\ref{chapter:interactions}. Before running these tests one should copy \texttt{Interactions/interactions\_HS.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}. Note that here we set the energy cost of two spheres overlapping,
$\epsilon$, to 100,000, as well as setting $\beta=1$ to realise hard spheres as described in Chapter \ref{chapter:interactions}.


\subsection{\texttt{test\_HS\_1}}
This test calculates the free energy difference between the hcp and fcc phases for a 216-particle supercell in the NPT ensemble at
$P\beta\sigma^3=14.58$ (where $\sigma$ denotes the hard-sphere diameter), using \texttt{UVM} volume moves. An analogous calculation
has been performed in Refs. \cite{thesis:Jackson,Bruce_2000}, the results of which will act as a benchmark.
2 4-thread MPI simulations are used. The first generates the weight function using \texttt{pong\_down}
barrier dynamics over 2,000,000 sweeps. The second simulation calculates the free energy difference, using
a total of 125,000,000 sweeps. Note that this simulation may take a while to run. The final result for the free energy difference
should match that Refs. \cite{thesis:Jackson,Bruce_2000}: the free energy difference per particle should be
$0.00113(4)\beta$. (Note that Jackson defines the free energy difference as that of fcc minus that of hcp,
while in \emph{monteswitch}, with hcp corresponding to phase 1 and fcc corresponding to phase 2, the free energy
difference is defined as that of hcp minus that of fcc -- hence the change of sign here
relative to Jackson's result).

Checks to perform:
\begin{enumerate}
\item
The final free energy difference between the two systems, when divided by 216, should agree with 0.00113(4).
Check that this is the case for the simulation: the free energy difference is stored in the \textbf{equil\_DeltaF}
in the 'state' file, with its uncertainty stored in the \textbf{sigma\_equil\_DeltaF} variable.
\end{enumerate}


\subsection{\texttt{test\_HS\_2}}
This test calculates the properties of the hcp phase for a 216-particle supercell at $P\beta\sigma^3=14.58$ in
the NPT ensemble. A 4-thread MPI simulation is used: a conventional (one-phase, not LSMC) Monte Carlo simulation is
performed with \texttt{UVM} volume moves, which allow each dimension of the supercell to move independently. The
results should correspond to Table 4.1 in Ref. \cite{thesis:Jackson}; specifically, the row $6^3$, hcp, etc. Note
that there is a typo in this refence: the results in Table 4.1 correspond to a reduced pressure of 14.58, \emph{not}
18.74. The densities quoted for the latter are not in agreement with those quoted in the table; however they
do correspond to other hard-sphere simulations the author performed at a reduced pressure of 14.58, which also agree with
Speedy's equation of state (Ref. 70 in Ref. \cite{thesis:Jackson}) at that pressure.

Checks to perform:
\begin{enumerate}
\item
The density obtained from the simulation, when divided by $\sqrt{2}$, should agree with the value in the table,
i.e., 0.7776(1). To calculate the density note that the supercell contains 216 particles, and the equilibrium
volume of the hcp supercell and its uncertainty obtained via block analysis are stored in the variables
\textbf{equil\_V\_1} and \textbf{sigma\_equil\_V\_1}.
\item
The hcp $c/a$ ratio should agree with the value in the table, i.e., 1.6323(7). The $c/a$ ratio can be obtained from
the following \texttt{awk} command, which extracts a measure of the instantaneous $c/a$ ratio from \textbf{Lx} and \textbf{Lz} in the
\texttt{data\_0} file:
\begin{verbatim}
$ awk 'NR%14==1 {Lx=$3}; NR%14==3 
{Lz=$3; print $2,(Lz/6)/(Lx/3)}' data_0 
| awk '$1>0 {sum=sum+$2;count=count+1}; 
END{print sum/count}'
\end{verbatim}
Doing similar for \texttt{data\_1}, \texttt{data\_2} and \texttt{data\_3} will give 4 independent results which can be combined
to give a final mean and standard error.
\end{enumerate}


\section{Embedded atom model (\texttt{EAM})}
The relevant \texttt{interactions\_} file for these tests is \texttt{interactions\_EAM.f95}, whose usage is described in Chapter
\ref{chapter:interactions}. Before running these tests one should copy \texttt{Interactions/interactions\_EAM.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}.


\subsection{\texttt{test\_EAM\_1}}
The test here is exactly the same calculation as the worked example; see Chapter \ref{chapter:example} for details.

Checks to perform:
\begin{enumerate}
\item
The final free energy difference between the two systems should be 0. Check that this is the case for the
simulation: the free energy difference is stored in the \textbf{equil\_DeltaF} in the \texttt{state} file, with its uncertainty
stored in the \textbf{sigma\_equil\_DeltaF} variable.
\end{enumerate}


\section{`Conventional' Lennard-Jones (\texttt{LJ})}
The relevant \texttt{interactions\_} file for these tests is \texttt{interactions\_LJ.f95}, whose usage is described in Chapter
\ref{chapter:interactions}. Before running these tests one should copy \texttt{Interactions/interactions\_LJ.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}.


\subsection{\texttt{test\_LJ\_1}}
This test calculates the potential energy per particle of the Lennard-Jones fluid in the NVT ensemble, with a cut-off (not shifted) of
$3\sigma$, $\epsilon=\sigma=1$, at a temperature of 0.85 and density of 0.003.

Checks to perform:
\begin{enumerate}
\item
The aforementioned energy, with tail corrections, should match those of \url{http://mmlapps.nist.gov/srs/LJ_PURE/mc.htm},
specifically, -0.03102(6).
\end{enumerate}


\section{Hard spheres (multiple species) (\texttt{HS\_multi})}
The relevant \texttt{interactions\_} file for these tests is \texttt{interactions\_HS\_multi.f95}, whose usage is described in Chapter
\ref{chapter:interactions}. Before running these tests one should copy \texttt{Interactions/interactions\_HS\_multi.f95}
to \texttt{interactions.f95}, and then (re-)compile \emph{monteswitch}.

\subsection{\texttt{test\_HS\_multi\_1}}
This test calculates the free energy difference between two systems each containing two hard spheres, where both systems have identical dimensions
$L_x=L_y=L_z=1$. In the first system, i.e., `phase 1' the two spheres both have diameter $\sigma_A=0.2$. However in the second system (i.e., phase 2) 
one sphere has diameter $\sigma_A$ and the other has $\sigma_B=0.1$. Thus phase 1 consists of two particles belonging to species `$A$', while phase 2
consists of one particle belonging to species $A$ and the other belonging to species `$B$'.
The free energy difference can be evaluated analytically. The relevant expression is (for phase 2 relative to phase 1)
\begin{equation}
\Delta F=-\frac{1}{\beta}\ln\Biggl[\frac{V-4\pi\sigma_A^3/3}{V-4\pi\sigma_{AB}^3/3}\Biggr],
\end{equation}
where
\begin{equation}
\sigma_{AB}=\frac{1}{2}(\sigma_A+\sigma_B)
\end{equation}
and $V$ is the volume of the system. Using $V=1$, $\sigma_A=0.2$, $\sigma_B=0.1$ and $\beta=1$ (which we use in the test) yields 
$\Delta F=0.019846611$. 

To evaluate the free energy difference between the phases we use canonical sampling in conjunction with a lattice switch move in which we simply the 
change of species of one of the particles from $A$ to $B$ in going from phase 1 to 2, and \emph{vica versa} in going from phase 2 to 1.

Checks to perform:
\begin{enumerate}
\item The aforementioned value of $\Delta F$ should be reproduced. Check that this is the case for the
simulation: the free energy difference is stored in the \textbf{equil\_DeltaF} in the \texttt{state} file, with its uncertainty
stored in the \textbf{sigma\_equil\_DeltaF} variable. \textbf{equil\_DeltaF} is also periodically output to stdout.
\end{enumerate}


\subsection{\texttt{test\_HS\_multi\_2}}
This test is identical to \texttt{test\_HS\_multi\_1} except that multicanonical sampling is used. Note that for this problem canonical sampling
is more efficient than multicanonical sampling, and hence the simulation may take a little longer than \texttt{test\_HS\_multi\_1} to converge
upon the correct answer.


%% And finally the references
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{ieeetr} %\bibliographystyle{plain}%\bibliographystyle{these}

\bibliography{bibliography}

\end{document}
\endinput
