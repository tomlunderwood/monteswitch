!
! By extracting lines beginning with the regular expression '\!\! ?'
! (ignoring leading whitespace), and then removing matches to the
! regular expression, html documentation corresponding to this 
! source code will be created.
!
!! <html>
!! <head>
!!  <title> monteswitch_post Documentation </title>
!! </head>
!! <body>
!! 
!! <h1> <code>monteswitch_post</code> Documentation </h1>
!!
!! <h2> Author </h2>
!! <p> Tom Underwood </p>
!!
!! <h2> General Notes </h2>
!! <p>
!! This program performs various post-processing operations on the 'state' file generated by <code>monteswitch</code> programs.
!! </p>
!! <p>
!! The command line options are as follows. Arguments in parenthesis are optional.
!! <table border="1">
!!  <tr>
!!   <td> <b> Argument </b> </td>
!!   <td> <b> Description </b> </td>
!!  </tr>
!!  <tr>
!!   <td> -extract_wf </td>
!!   <td>
!!   Extract the weight function from the 'state' file and output it to stdout. In the output the 
!!   first token on each line is the order parameter, and the second is the corresponding value of the weight
!!   function.
!!   </td>
!!  </tr>
!!  <tr>
!!   <td> -extract_M_counts </td>
!!   <td>
!!   Extract order parameter histograms from the 'state' file, and output them to stdout. In the output
!!   the first token on each line is the order parameter, the second is the corresponding number of
!!   counts for lattice type 1, and the third is the corresponding number of counts for lattice type 2.
!!   </td>
!!  </tr>
!!  <tr>
!!   <td> -extract_pos </td>
!!   <td>
!!   Extract the positions of the particles, and output them to stdout. In the output
!!   the first, second and third tokens on each line are the x-, y- and z-coordinates respectively
!!   for a particle.
!!   </td>
!!  </tr>
!!   <td> -extract_R_1 </td>
!!   <td>
!!   Extract the positions of the lattice vectors for lattice type 1, and output them to stdout. In 
!!   the output the first, second and third tokens on each line are the x-, y- and z-coordinates respectively
!!   for a particle.
!!   </td>
!!  </tr>
!!  </tr>
!!   <td> -extract_R_2 </td>
!!   <td>
!!   Extract the positions of the lattice vectors for lattice type 2, and output them to stdout. In 
!!   the output the first, second and third tokens on each line are the x-, y- and z-coordinates respectively
!!   for a particle.
!!   </td>
!!  </tr>
!!  <tr>
!!   <td> -extract_u </td>
!!   <td>
!!   Extract the displacements of the particles, and output them to stdout. In the output
!!   the first, second and third tokens on each line are the x-, y- and z-displacements respectively
!!   for a particle.
!!   </td>
!!  </tr>
!!  <tr>
!!   <td> -calc_rad_dist <i>bins</i> </td>
!!   <td>
!!   Calculate the instantaneous radial distribution function, which is output to stdout. In the output, each line corresponds
!!   to a distance, which is the first token; the second token contains the average number of particles at this distance
!!   from a particle. The output is like a histogram, with each line corresponding to a bin, the first token 
!!   corresponding to the minimum of the range covered by the bin, and the second token corresponding to the number of 
!!   counts for that bin. The range of the bin is inclusive at its minimum, and exclusive at its maximum. The range 
!!   chosen to evaluate the radial distribution function for is <code>min(Lx/2,Ly/2,Lz/2)</code>, where <code>Lx</code>, 
!!   <code>Ly</code> and <code>Lz</code> pertain to the lattice type of the system in 'state', and the number of bins 
!!   for the histogram is specified in the argument <i>bins</i>. Note that the range of distances corresponds to 
!!   the 'limit of periodicity' for the system.
!!   </td>
!!  </tr>
!!  <tr>
!!   <td> -merge_trans <i>state_in_1</i> <i>state_in_2</i> <i>state_out</i> </td>
!!   <td>
!!   Combine the <code>trans</code> matrices from the files <i>state_in_1</i> and <i>state_in_2</i>, and store the
!!   result in the file <i>state_out</i>, where all variables in <i>state_out</i> other than the matrix <code>trans</code>
!!   are inherited from <i>state_in_1</i>. Note that <code>M_grid</code> <i>must</i> be the same for both <i>state_in_1</i> and
!!   <i>state_in_2</i> (in which case the matrices <code>tran</code> are of the same size).
!!   </td>
!!  </tr>
!!  <tr>
!!   <td> -extract_lattices_in <i>vectors_in_1</i> <i>vectors_in_2</i></td>
!!   <td>
!!   Output the geometrical properties of the system in the format of a 'lattices_in' file. The arguments <i>vectors_in_1</i> 
!!   and <i>vectors_in_2</i> can be either <code>pos</code> or <code>R</code>. If <i>vectors_in_1</i> is <code>pos</code>, then
!!   the positions of the particles in lattice 1 of the 'lattices_in' file will be the positions of the particles in lattice 1
!!   in the 'state' file; if <i>vectors_in_1</i> is <code>R</code>, then the positions of the particles in lattice 1 of the 
!!   'lattices_in' file will be the lattice vectors (i.e., <code>R_1</code>) corresponding to lattice 1 in the 'state' file.
!!   Similar applies for <i>vectors_in_2</i> with lattice 2.
!!   </td>
!!  </tr>
!!  <tr>
!!   <td> -extract_pos_xyz </td>
!!   <td>
!!   Extract the positions of the particles, and output them to stdout in '.xyz' format. In the output
!!   the first line contains the number of particles, the second line is a comment line, and the subsequent lines contain the
!!   particle positions: the first token is the `element' (set to A), and the second, third, fourth and fifth tokens are the
!!   x-, y- and z-coordinates respectively.
!!   </td>
!!  </tr>
!! </table>
!! </p>
!! <p>
!! This program terminates with a non-zero exit status of 1 for errors. Note that exit statuses are not part of the 
!! Fortran standard, and may not work for all operating systems or compilers.
!! </p>
!!
program monteswitch_post

  !! <h2> Dependencies </h2>
  !! <p> 
  !! <ul>
  !!  <li> <code> kinds_mod </code> </li>
  !!  <li> <code> monteswitch_mod </code> </li>
  !! </ul>
  !! </p>
  use kinds_mod
  use monteswitch_mod

  implicit none


  ! Number of bins for -calc_rad_dist
  integer(ik) :: bins
  ! Histogram arrays for -calc_rad_dist
  real(rk), dimension(:), allocatable :: rad_dist_seps
  integer(ik), dimension(:), allocatable :: rad_dist_counts
  real(rk), dimension(:), allocatable :: rad_dist_function

  ! File names used for -merge_trans
  character(len=20) :: state_in_1, state_in_2, state_out
  ! Matrix used for merging trans
  real(rk), dimension(:,:), allocatable :: trans_toadd

  ! Positions of particles within the supercell
  real(rk), dimension(:,:), allocatable :: pos

  ! Variables used for -extract_lattices_in
  character(len=20) :: vector_in_1, vector_in_2
  real(rk), dimension(:,:), allocatable :: pos_1_temp
  real(rk), dimension(:,:), allocatable :: pos_2_temp

  ! Unimportant variables
  character(len=20) :: char
  integer(ik) :: i,j
  real(rk) :: sep
  

  ! THE PROGRAM

  ! Read the command line argument 
  call getarg(1,char)
  if(char=="") then
     write(0,*) "Error: No command line argument detected."
     stop 1
  else if(trim(char)=="-extract_wf") then

     ! CODE FOR EXTRACTING THE WEIGHT FUNCTION FROM THE STATE FILE
    
     call import("state")

     do i=1,M_grid_size
        write(*,*) M_grid(i), eta_grid(i)
     end do
     
  else if(trim(char)=="-extract_M_counts") then

     ! CODE FOR EXTRACTING THE ORDER PARAMETER HISTOGRAM FROM THE STATE FILE
    
     call import("state")

     do i=1,M_grid_size
        write(*,*) M_grid(i), M_counts_1(i),M_counts_2(i)
     end do
     
  else if(trim(char)=="-extract_pos") then

     ! CODE FOR EXTRACTING THE PARTICLE POSITIONS
    
     call import("state")

     allocate(pos(n_part,3))
     select case(lattice)
     case(1)
         pos = R_1 + u
         call translate_positions(pos,Lx(1),Ly(1),Lz(1))
     case(2)
         pos = R_2 + u
         call translate_positions(pos,Lx(2),Ly(2),Lz(2))
     end select

     do i=1,n_part
         write(*,*) pos(i,:)
     end do

  else if(trim(char)=="-extract_R_1") then

     ! CODE FOR EXTRACTING THE LATTICE VECTORS FOR LATTICE TYPE 1
    
     call import("state")

     do i=1,n_part
        write(*,*) R_1(i,:)
     end do

 else if(trim(char)=="-extract_R_2") then

     ! CODE FOR EXTRACTING THE LATTICE VECTORS FOR LATTICE TYPE 2
    
     call import("state")

     do i=1,n_part
        write(*,*) R_2(i,:)
     end do

  else if(trim(char)=="-extract_u") then

     ! CODE FOR EXTRACTING THE PARTICLE DISPLACEMENTS
    
     call import("state")

     do i=1,n_part
        write(*,*) u(i,:)
     end do
     
  else if(trim(char)=="-calc_rad_dist") then

     ! CODE FOR CALCULATING THE RADIAL DISTRIBUTION FUNCTION

     call getarg(2,char)
     if(char=="") then
        write(0,*) "Error: No 2nd command line argument detected (the 'bins' file name for -calc_rad_dist)."
        stop 1
     end if
     
     read(char,*) bins
     
     if(bins<=0) then
        write(0,*) "Error: 'bins' is <=0."
        stop 1
     end if

     call import("state")

     ! Initialise histogram
     allocate(rad_dist_seps(bins))
     allocate(rad_dist_counts(bins))
     allocate(rad_dist_function(bins))
     do i=1,bins
        select case(lattice)
        case(1)
           rad_dist_seps(i)=(i-1)*min(Lx(1)/2.0_rk,Ly(1)/2.0_rk,Lz(1)/2.0_rk)/bins
        case(2)
           rad_dist_seps(i)=(i-1)*min(Lx(2)/2.0_rk,Ly(2)/2.0_rk,Lz(2)/2.0_rk)/bins
        end select
     end do
     rad_dist_counts=0

     ! Construct histogram
     do i=1,n_part
        do j=1,n_part
           select case(lattice)
           case(1)
              sep=min_image_distance_fancy(R_1(i,:)+u(i,:),R_1(j,:)+u(j,:),Lx(1),Ly(1),Lz(1))
           case(2)
              sep=min_image_distance_fancy(R_2(i,:)+u(i,:),R_2(j,:)+u(j,:),Lx(2),Ly(2),Lz(2))
           end select
           call update_histogram(bins,rad_dist_seps,rad_dist_counts,rad_dist_seps(2),sep)
        end do
     end do

     ! Output histogram
     rad_dist_function=(rad_dist_counts*1.0_rk)/n_part
     do i=1,bins
        write(*,*) rad_dist_seps(i),rad_dist_function(i)
     end do

  else if(trim(char)=="-merge_trans") then

     ! CODE FOR MERGING TRANS MATRICES
     
     call getarg(2,state_in_1)
     if(state_in_1=="") then
        write(0,*) "Error: No 2nd command line argument detected (the 'state_in_1' file name for -merge_trans)."
        stop 1
     end if
     call getarg(3,state_in_2)
     if(state_in_2=="") then
        write(0,*) "Error: No 3rd command line argument detected (the 'state_in_2' file name for -merge_trans)."
        stop 1
     end if
     call getarg(4,state_out)
     if(state_out=="") then
        write(0,*) "Error: No 3rd command line argument detected (the 'state_out' file name for -merge_trans)."
        stop 1
     end if

     call import(trim(state_in_2))    

     allocate(trans_toadd(M_grid_size,M_grid_size))
     trans_toadd=trans

     call import(trim(state_in_1))
     trans=trans+trans_toadd

     call export(trim(state_out))


!**************************************************** >>>>>
  else if(trim(char)=="-extract_lattices_in") then

     ! CODE FOR EXPORTING IN 'lattices_in' FORMAT

     call import("state")

     call getarg(2,vector_in_1)
     call getarg(3,vector_in_2)

     allocate(pos_1_temp(n_part,3))
     allocate(pos_2_temp(n_part,3))

     ! Set pos_1_temp
     if(trim(vector_in_1)=="pos") then
        pos_1_temp = u + R_1
        call translate_positions(pos_1_temp,Lx(1),Ly(1),Lz(1))
     else if(trim(vector_in_1)=="R") then
        pos_1_temp = R_1
     else if(vector_in_1=="") then
        write(0,*) "Error: No 2nd command line argument detected (the 'vector_in_1' flag for -extract_lattices_in)."
        stop 1
     else
        write(0,*) "Error: Unrecognised 2nd command line argument to -extract_lattices_in ('pos' or 'R' only please)."
        stop 1
     end if

     ! Set pos_2_temp
     if(trim(vector_in_2)=="pos") then
        pos_2_temp = u + R_2
        call translate_positions(pos_2_temp,Lx(2),Ly(2),Lz(2))
     else if(trim(vector_in_2)=="R") then
        pos_2_temp = R_2
     else if(vector_in_2=="") then
        write(0,*) "Error: No 2nd command line argument detected (the 'vector_in_2' flag for -extract_lattices_in)."
        stop 1
     else
        write(0,*) "Error: Unrecognised 2nd command line argument to -extract_lattices_in ('pos' or 'R' only please)."
        stop 1
     end if

     ! Output comment line and the number of particles
     write(*,*) "lattices_in file created by monteswitch_post"
     write(*,*) n_part
     ! Output lattice 1 dimensions and particle positions (in fractional coordinates)
     write(*,*) Lx(1)
     write(*,*) Ly(1)
     write(*,*) Lz(1)
     do i=1,n_part
        write(*,*) pos_1_temp(i,1)/Lx(1),pos_1_temp(i,2)/Ly(1),pos_1_temp(i,3)/Lz(1)
     end do
     ! Output lattice 2 dimensions and particle positions (in fractional coordinates)
     write(*,*) Lx(2)
     write(*,*) Ly(2)
     write(*,*) Lz(2)
     do i=1,n_part
        write(*,*) pos_2_temp(i,1)/Lx(2),pos_2_temp(i,2)/Ly(2),pos_2_temp(i,3)/Lz(2)
     end do


  else if(trim(char)=="-extract_pos_xyz") then

     ! CODE FOR EXTRACTING THE PARTICLE POSITIONS
    
     call import("state")

     allocate(pos(n_part,3))
     select case(lattice)
     case(1)
         pos = R_1 + u
         call translate_positions(pos,Lx(1),Ly(1),Lz(1))
     case(2)
         pos = R_2 + u
         call translate_positions(pos,Lx(2),Ly(2),Lz(2))
     end select

     write(*,*) n_part
     write(*,*) "xyz-format file created by monteswitch_post"
     do i=1,n_part
         write(*,*) "A",pos(i,:)
     end do


  else

     ! CODE FOR ANY OTHER COMMAND LINE ARGUMENTS

     write(0,*) "Error: Unrecognised command line argument."
     stop 1

  end if




contains




  !! <h3> <code> function min_image_distance_fancy(r_1,r_2,Lx,Ly,Lz) </code> </h3>
  !! <p>
  !! <code>  min_image_distance_fancy </code>  returns the distance between the 
  !! positions <code>r_1</code> and <code>r_2</code> according to the 
  !! minimum image convention for a periodic cuboid whose faces are x=0, 
  !! x=<code>Lx</code>, y=0, y=<code>Ly</code>, z=0, and z=<code>Lz</code>.
  !! <code>r_1(1)</code> is the x-component of <code>r_1</code>, 
  !! <code>r_1(2)</code> is the y-component, and <code>r_1(3)</code> is the 
  !! z-component; and similarly for <code>r_2</code>.
  !! This function has a wider applicability than the funciton
  !! <code>min_image_distance</code>: it allows <code>r_1</code> and
  !! <code>r_2</code> to be outwith the aforementioned cube.
  !! Note that <code>r_1</code> and <code>r_2</code> must be such that
  !! <code>-Lx</code><=x<<code>2*Lx</code>, <code>-Ly</code><=y<<code>2*Ly</code>
  !! and <code>-Lz</code><=z<<code>2*Lz</code>.
  !! </p>
  !! <table border="1">
  !!  <tr>
  !!   <td> <b> Argument </b> </td>
  !!   <td> <b> Type </b> </td>
  !!   <td> <b> Description </b> </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> r_1 </code> </td>
  !!   <td> <code> real(rk), dimension(3), intent(in) </code> </td>
  !!   <td> Position within the cuboid. </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> r_2 </code> </td>
  !!   <td> <code> real(rk), dimension(3), intent(in) </code> </td>
  !!   <td> Position within the cuboid. </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> Lx </code> </td>
  !!   <td> <code> real(rk), intent(in) </code> </td>
  !!   <td> Length of cuboid along the x-axis. </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> Ly </code> </td>
  !!   <td> <code> real(rk), intent(in) </code> </td>
  !!   <td> Length of cuboid along the y-axis. </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> Lz </code> </td>
  !!   <td> <code> real(rk), intent(in) </code> </td>
  !!   <td> Length of cuboid along the z-axis. </td>
  !!  </tr>
  !! </table>
  !! <p><b>Returns:</b> <code> real(rk) </code> </p>
  function min_image_distance_fancy(r_1,r_2,Lx,Ly,Lz)
    real(rk), dimension(3), intent(in) :: r_1, r_2
    real(rk), intent(in) :: Lx, Ly, Lz
    real(rk) :: min_image_distance_fancy
    real(rk) :: xsep, ysep, zsep
    ! Calculate the x-sep
    xsep=abs(r_2(1)-r_1(1))
    xsep=xsep-Lx*floor(xsep/Lx)
    xsep=xsep-Lx*floor(2.0_rk*xsep/Lx)
    ! Calculate the y-sep
    ysep=abs(r_2(2)-r_1(2))
    ysep=ysep-Ly*floor(ysep/Ly)
    ysep=ysep-Ly*floor(2.0_rk*ysep/Ly)
    ! Calculate the z-sep
    zsep=abs(r_2(3)-r_1(3))
    zsep=zsep-Lz*floor(zsep/Lz)
    zsep=zsep-Lz*floor(2.0_rk*zsep/Lz)
    ! Calculate the distance
    min_image_distance_fancy=sqrt(xsep*xsep+ysep*ysep+zsep*zsep)
  end function min_image_distance_fancy

     
end program monteswitch_post
!!
!! </body>
!! </html>
