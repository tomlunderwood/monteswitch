!-----------------------------------------------------------------------
!
! Copyright (c) 2016 Tom L. Underwood
!
! Permission is hereby granted, free of charge, to any person obtaining 
! a copy of this software and associated documentation files (the 
! "Software"), to deal in the Software without restriction, including 
! without limitation the rights to use, copy, modify, merge, publish, 
! distribute, sublicense, and/or sell copies of the Software, and to 
! permit persons to whom the Software is furnished to do so, subject to
! the following conditions:
! 
! The above copyright notice and this permission notice shall be 
! included in all copies or substantial portions of the Software.
! 
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
! EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
! MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
! NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS 
! BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
! ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
! CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
! SOFTWARE.
!
!-----------------------------------------------------------------------
!
! By extracting lines beginning with the regular expression '\!\! ?'
! (ignoring leading whitespace), and then removing matches to the
! regular expression, html documentation corresponding to this 
! source code will be created.
!
!! <html>
!! <head>
!!  <title> rng_mod Documentation </title>
!! </head>
!! <body>
!! 
!! <h1> <code>rng_mod</code> Documentation </h1>
!!
!! <h2> Author </h2>
!! <p> Tom Underwood </p>
!!
!! <h2> Description </h2>
!! <p>
!! <code>rng_mod</code> is a module which contains procedures for
!! generating random numbers by the Mersenne twister  MT19937 algorithm
!! by acting as a wrapper for 'mt95.f90'), as well as a number of 
!! other useful random-number-related procedures.
!! </p>
!!
module rng_mod

  !! <h2> Dependencies </h2>
  !! <p> 
  !! <ul>
  !!  <li> <code> kinds_mod </code> </li>
  !!  <li> <code> mt95 </code> </li>
  !! </ul>
  !! </p>
  use kinds_mod
  use mt95

  implicit none

contains

  !! <h2> Procedures </h2>

  !! <h3> <code> subroutine init_random_seed() </code> </h3>
  !! <p>
  !! <code> init_random_seed </code> initialises the random number generator
  !! using the (optional) integer seed specified in the argument. If there is
  !! no argument then a random seed is used - which is taken from the system
  !! clock.
  !! </p>
  !! <table border="1">
  !!  <tr>
  !!   <td> <b> Argument </b> </td>
  !!   <td> <b> Type </b> </td>
  !!   <td> <b> Description </b> </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> seed </code> </td>
  !!   <td> <code> integer, intent(in), optional </code> </td>
  !!   <td> A specific seed for the random number generator. </td>
  !!  </tr>
  !! </table>
  subroutine init_random_seed(seed)
    integer, intent(in), optional :: seed
    integer :: clock
    if(present(seed)) then
        call genrand_init(seed)
    else
       call system_clock(count=clock)
       call genrand_init(clock)
    end if
  end subroutine init_random_seed



  !! <h3> <code> function get_random_number() </code> </h3>
  !! <p>
  !! <code> get_random_number </code> generates a random number between
  !! 0 and 1. We emphasise that this number may be 0, but not 1.
  !! </p>
  !! <p><b>Returns:</b> <code> real(rk) </code> </p>
  function get_random_number()
    real(rk) :: get_random_number

    call genrand_real2(get_random_number)

  end function get_random_number

  

  !! <h3> <code> function top_hat_rand(L) </code> </h3>
  !! <p>
  !! <code> top_hat_rand </code> generates a random number between
  !! <code>-L</code> and <code>L</code>, where <code>L>0</code>.
  !! </p>
  !! <table border="1">
  !!  <tr>
  !!   <td> <b> Argument </b> </td>
  !!   <td> <b> Type </b> </td>
  !!   <td> <b> Description </b> </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> L </code> </td>
  !!   <td> <code> real(rk), intent(in) </code> </td>
  !!   <td> 
  !!   The highest magnitude of random number generated by the
  !!   function.
  !!   </td>
  !!  </tr>
  !! </table>
  !! <p><b>Returns:</b> <code> real(rk) </code> </p>
  function top_hat_rand(L)
    real(rk), intent(in) :: L
    real(rk) :: top_hat_rand
    top_hat_rand=(2.0_rk*get_random_number()-1.0_rk)*L
  end function top_hat_rand


  !! <h3> <code> function bag_array(nspec) </code> </h3>
  !! <p>
  !! This function returns a random array with the specified number of occurences of the numbers 1, 2, ...
  !! Its name reflects the fact that the array reflects drawing at random balls of various types from
  !! a 'bag' containing the specified number of each type of ball.
  !! </p>
  !! <table border="1">
  !!  <tr>
  !!   <td> <b> Argument </b> </td>
  !!   <td> <b> Type </b> </td>
  !!   <td> <b> Description </b> </td>
  !!  </tr>
  !!  <tr>
  !!   <td> <code> nspec </code> </td>
  !!   <td> <code> integer(ik), dimension(:), allocatable, intent(in) </code> </td>
  !!   <td> 
  !!   Array containing the number of occurences of each number to occur in the returned array:
  !!   <code>nspec(1)</code> is the number of times 1 should occur; <code>nspec(2)</code> is the number
  !!   of times 2 should occur; etc. E.g. <code>nspec=</code>
  !!   This array should have 1 as its first index.
  !!   </td>
  !!  </tr>
  !! </table>
  !! <p><b>Returns:</b> <code> integer(ik), dimension(:), allocatable </code> </p>
  function bag_array(nspec)
    integer(ik), dimension(:), intent(in) :: nspec
    integer(ik), dimension(:), allocatable :: bag_array
    ! The total number of elements in the array to return
    integer(ik) :: nelem
    ! The total number of species to consider
    integer(ik) :: totspec
    ! The total number of elements left to assign.
    integer(ik) :: nleft
    ! An array containing the number of elements left to assign for each species
    integer(ik), dimension(size(nspec)) :: nleftspec
    ! Unimportant variables
    integer(ik) :: i,n
    real(rk) :: cutoff, rand

    nleftspec=nspec
    totspec=size(nspec)
    nelem=sum(nspec)
    allocate(bag_array(nelem))
    bag_array=0 ! For error trapping

    ! Assign the species
    nleft=nelem
    do n=1,nelem
       ! Get a random number
       rand=get_random_number()

       ! Decide which species it corresponds to. If rand<nleftspec(1)/nleft, then we choose
       ! species 1; if nleftspec(1)/nleft<=rand<(nleftspec(1)+nleftspec(2))/nleft then we choose
       ! species 2; etc.
       cutoff=0
       do i=1,totspec
          cutoff=cutoff+(1.0_rk*nleftspec(i))/nleft
          if(rand<cutoff) then
             bag_array(n)=i
             ! Update nleft and nleftspec
             nleft=nleft-1
             nleftspec(i)=nleftspec(i)-1
             exit
          end if
       end do
    
    end do
  end function bag_array




end module rng_mod
!!
!! </body>
!! </html>
